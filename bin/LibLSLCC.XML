<?xml version="1.0"?>
<doc>
    <assembly>
        <name>LibLSLCC</name>
    </assembly>
    <members>
        <member name="T:LibLSLCC.AntlrParser.LSLBaseListener">
            <summary>
            This class provides an empty implementation of <see cref="T:LibLSLCC.AntlrParser.ILSLListener"/>,
            which can be extended to create a listener which only needs to handle a subset
            of the available methods.
            </summary>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterVectorLiteral(LibLSLCC.AntlrParser.LSLParser.VectorLiteralContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.vectorLiteral"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitVectorLiteral(LibLSLCC.AntlrParser.LSLParser.VectorLiteralContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.vectorLiteral"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterRotationLiteral(LibLSLCC.AntlrParser.LSLParser.RotationLiteralContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.rotationLiteral"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitRotationLiteral(LibLSLCC.AntlrParser.LSLParser.RotationLiteralContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.rotationLiteral"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterFunctionDeclaration(LibLSLCC.AntlrParser.LSLParser.FunctionDeclarationContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.functionDeclaration"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitFunctionDeclaration(LibLSLCC.AntlrParser.LSLParser.FunctionDeclarationContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.functionDeclaration"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterElseStatement(LibLSLCC.AntlrParser.LSLParser.ElseStatementContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.elseStatement"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitElseStatement(LibLSLCC.AntlrParser.LSLParser.ElseStatementContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.elseStatement"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterControlStructure(LibLSLCC.AntlrParser.LSLParser.ControlStructureContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.controlStructure"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitControlStructure(LibLSLCC.AntlrParser.LSLParser.ControlStructureContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.controlStructure"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterCodeScope(LibLSLCC.AntlrParser.LSLParser.CodeScopeContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.codeScope"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitCodeScope(LibLSLCC.AntlrParser.LSLParser.CodeScopeContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.codeScope"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterDoLoop(LibLSLCC.AntlrParser.LSLParser.DoLoopContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.doLoop"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitDoLoop(LibLSLCC.AntlrParser.LSLParser.DoLoopContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.doLoop"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterWhileLoop(LibLSLCC.AntlrParser.LSLParser.WhileLoopContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.whileLoop"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitWhileLoop(LibLSLCC.AntlrParser.LSLParser.WhileLoopContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.whileLoop"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterForLoop(LibLSLCC.AntlrParser.LSLParser.ForLoopContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.forLoop"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitForLoop(LibLSLCC.AntlrParser.LSLParser.ForLoopContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.forLoop"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterLoopStructure(LibLSLCC.AntlrParser.LSLParser.LoopStructureContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.loopStructure"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitLoopStructure(LibLSLCC.AntlrParser.LSLParser.LoopStructureContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.loopStructure"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterCodeStatement(LibLSLCC.AntlrParser.LSLParser.CodeStatementContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.codeStatement"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitCodeStatement(LibLSLCC.AntlrParser.LSLParser.CodeStatementContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.codeStatement"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterExpressionStatement(LibLSLCC.AntlrParser.LSLParser.ExpressionStatementContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.expressionStatement"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitExpressionStatement(LibLSLCC.AntlrParser.LSLParser.ExpressionStatementContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.expressionStatement"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterReturnStatement(LibLSLCC.AntlrParser.LSLParser.ReturnStatementContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.returnStatement"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitReturnStatement(LibLSLCC.AntlrParser.LSLParser.ReturnStatementContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.returnStatement"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterLabelStatement(LibLSLCC.AntlrParser.LSLParser.LabelStatementContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.labelStatement"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitLabelStatement(LibLSLCC.AntlrParser.LSLParser.LabelStatementContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.labelStatement"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterJumpStatement(LibLSLCC.AntlrParser.LSLParser.JumpStatementContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.jumpStatement"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitJumpStatement(LibLSLCC.AntlrParser.LSLParser.JumpStatementContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.jumpStatement"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterStateChangeStatement(LibLSLCC.AntlrParser.LSLParser.StateChangeStatementContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.stateChangeStatement"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitStateChangeStatement(LibLSLCC.AntlrParser.LSLParser.StateChangeStatementContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.stateChangeStatement"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterLocalVariableDeclaration(LibLSLCC.AntlrParser.LSLParser.LocalVariableDeclarationContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.localVariableDeclaration"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitLocalVariableDeclaration(LibLSLCC.AntlrParser.LSLParser.LocalVariableDeclarationContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.localVariableDeclaration"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterGlobalVariableDeclaration(LibLSLCC.AntlrParser.LSLParser.GlobalVariableDeclarationContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.globalVariableDeclaration"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitGlobalVariableDeclaration(LibLSLCC.AntlrParser.LSLParser.GlobalVariableDeclarationContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.globalVariableDeclaration"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterExpressionListTail(LibLSLCC.AntlrParser.LSLParser.ExpressionListTailContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.expressionListTail"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitExpressionListTail(LibLSLCC.AntlrParser.LSLParser.ExpressionListTailContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.expressionListTail"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterExpressionList(LibLSLCC.AntlrParser.LSLParser.ExpressionListContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.expressionList"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitExpressionList(LibLSLCC.AntlrParser.LSLParser.ExpressionListContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.expressionList"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterDotAccessorExpr(LibLSLCC.AntlrParser.LSLParser.DotAccessorExprContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.dotAccessorExpr"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitDotAccessorExpr(LibLSLCC.AntlrParser.LSLParser.DotAccessorExprContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.dotAccessorExpr"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterModifiableLeftValue(LibLSLCC.AntlrParser.LSLParser.ModifiableLeftValueContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.modifiableLeftValue"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitModifiableLeftValue(LibLSLCC.AntlrParser.LSLParser.ModifiableLeftValueContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.modifiableLeftValue"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterParenthesizedExpression(LibLSLCC.AntlrParser.LSLParser.ParenthesizedExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>ParenthesizedExpression</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitParenthesizedExpression(LibLSLCC.AntlrParser.LSLParser.ParenthesizedExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>ParenthesizedExpression</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterExpr_PrefixOperation(LibLSLCC.AntlrParser.LSLParser.Expr_PrefixOperationContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_PrefixOperation</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitExpr_PrefixOperation(LibLSLCC.AntlrParser.LSLParser.Expr_PrefixOperationContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_PrefixOperation</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterExpr_Atom(LibLSLCC.AntlrParser.LSLParser.Expr_AtomContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_Atom</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitExpr_Atom(LibLSLCC.AntlrParser.LSLParser.Expr_AtomContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_Atom</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterExpr_TypeCast(LibLSLCC.AntlrParser.LSLParser.Expr_TypeCastContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_TypeCast</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitExpr_TypeCast(LibLSLCC.AntlrParser.LSLParser.Expr_TypeCastContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_TypeCast</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterExpr_DotAccessorExpr(LibLSLCC.AntlrParser.LSLParser.Expr_DotAccessorExprContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_DotAccessorExpr</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitExpr_DotAccessorExpr(LibLSLCC.AntlrParser.LSLParser.Expr_DotAccessorExprContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_DotAccessorExpr</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterExpr_BitwiseShift(LibLSLCC.AntlrParser.LSLParser.Expr_BitwiseShiftContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_BitwiseShift</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitExpr_BitwiseShift(LibLSLCC.AntlrParser.LSLParser.Expr_BitwiseShiftContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_BitwiseShift</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterExpr_LogicalCompare(LibLSLCC.AntlrParser.LSLParser.Expr_LogicalCompareContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_LogicalCompare</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitExpr_LogicalCompare(LibLSLCC.AntlrParser.LSLParser.Expr_LogicalCompareContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_LogicalCompare</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterExpr_LogicalEquality(LibLSLCC.AntlrParser.LSLParser.Expr_LogicalEqualityContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_LogicalEquality</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitExpr_LogicalEquality(LibLSLCC.AntlrParser.LSLParser.Expr_LogicalEqualityContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_LogicalEquality</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterExpr_BitwiseOr(LibLSLCC.AntlrParser.LSLParser.Expr_BitwiseOrContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_BitwiseOr</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitExpr_BitwiseOr(LibLSLCC.AntlrParser.LSLParser.Expr_BitwiseOrContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_BitwiseOr</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterExpr_Logical_And_Or(LibLSLCC.AntlrParser.LSLParser.Expr_Logical_And_OrContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_Logical_And_Or</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitExpr_Logical_And_Or(LibLSLCC.AntlrParser.LSLParser.Expr_Logical_And_OrContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_Logical_And_Or</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterExpr_BitwiseXor(LibLSLCC.AntlrParser.LSLParser.Expr_BitwiseXorContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_BitwiseXor</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitExpr_BitwiseXor(LibLSLCC.AntlrParser.LSLParser.Expr_BitwiseXorContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_BitwiseXor</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterExpr_Assignment(LibLSLCC.AntlrParser.LSLParser.Expr_AssignmentContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_Assignment</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitExpr_Assignment(LibLSLCC.AntlrParser.LSLParser.Expr_AssignmentContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_Assignment</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterExpr_MultDivMod(LibLSLCC.AntlrParser.LSLParser.Expr_MultDivModContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_MultDivMod</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitExpr_MultDivMod(LibLSLCC.AntlrParser.LSLParser.Expr_MultDivModContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_MultDivMod</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterExpr_BitwiseAnd(LibLSLCC.AntlrParser.LSLParser.Expr_BitwiseAndContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_BitwiseAnd</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitExpr_BitwiseAnd(LibLSLCC.AntlrParser.LSLParser.Expr_BitwiseAndContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_BitwiseAnd</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterExpr_PostfixOperation(LibLSLCC.AntlrParser.LSLParser.Expr_PostfixOperationContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_PostfixOperation</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitExpr_PostfixOperation(LibLSLCC.AntlrParser.LSLParser.Expr_PostfixOperationContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_PostfixOperation</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterExpr_FunctionCall(LibLSLCC.AntlrParser.LSLParser.Expr_FunctionCallContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_FunctionCall</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitExpr_FunctionCall(LibLSLCC.AntlrParser.LSLParser.Expr_FunctionCallContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_FunctionCall</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterExpr_ModifyingAssignment(LibLSLCC.AntlrParser.LSLParser.Expr_ModifyingAssignmentContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_ModifyingAssignment</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitExpr_ModifyingAssignment(LibLSLCC.AntlrParser.LSLParser.Expr_ModifyingAssignmentContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_ModifyingAssignment</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterExpr_AddSub(LibLSLCC.AntlrParser.LSLParser.Expr_AddSubContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_AddSub</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitExpr_AddSub(LibLSLCC.AntlrParser.LSLParser.Expr_AddSubContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_AddSub</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterOptionalExpressionList(LibLSLCC.AntlrParser.LSLParser.OptionalExpressionListContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.optionalExpressionList"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitOptionalExpressionList(LibLSLCC.AntlrParser.LSLParser.OptionalExpressionListContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.optionalExpressionList"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterOptionalParameterList(LibLSLCC.AntlrParser.LSLParser.OptionalParameterListContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.optionalParameterList"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitOptionalParameterList(LibLSLCC.AntlrParser.LSLParser.OptionalParameterListContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.optionalParameterList"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterListLiteral(LibLSLCC.AntlrParser.LSLParser.ListLiteralContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.listLiteral"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitListLiteral(LibLSLCC.AntlrParser.LSLParser.ListLiteralContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.listLiteral"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterCompilationUnit(LibLSLCC.AntlrParser.LSLParser.CompilationUnitContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.compilationUnit"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitCompilationUnit(LibLSLCC.AntlrParser.LSLParser.CompilationUnitContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.compilationUnit"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterParameterDefinition(LibLSLCC.AntlrParser.LSLParser.ParameterDefinitionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.parameterDefinition"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitParameterDefinition(LibLSLCC.AntlrParser.LSLParser.ParameterDefinitionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.parameterDefinition"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterParameterList(LibLSLCC.AntlrParser.LSLParser.ParameterListContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.parameterList"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitParameterList(LibLSLCC.AntlrParser.LSLParser.ParameterListContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.parameterList"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterEventHandler(LibLSLCC.AntlrParser.LSLParser.EventHandlerContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.eventHandler"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitEventHandler(LibLSLCC.AntlrParser.LSLParser.EventHandlerContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.eventHandler"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterDefinedState(LibLSLCC.AntlrParser.LSLParser.DefinedStateContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.definedState"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitDefinedState(LibLSLCC.AntlrParser.LSLParser.DefinedStateContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.definedState"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterDefaultState(LibLSLCC.AntlrParser.LSLParser.DefaultStateContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.defaultState"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitDefaultState(LibLSLCC.AntlrParser.LSLParser.DefaultStateContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.defaultState"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.EnterEveryRule(Antlr4.Runtime.ParserRuleContext)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.ExitEveryRule(Antlr4.Runtime.ParserRuleContext)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseListener.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="T:LibLSLCC.AntlrParser.LSLBaseVisitor`1">
            <summary>
            This class provides an empty implementation of <see cref="T:LibLSLCC.AntlrParser.ILSLVisitor`1"/>,
            which can be extended to create a visitor which only needs to handle a subset
            of the available methods.
            </summary>
            <typeparam name="Result">The return type of the visit operation.</typeparam>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitVectorLiteral(LibLSLCC.AntlrParser.LSLParser.VectorLiteralContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.vectorLiteral"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitRotationLiteral(LibLSLCC.AntlrParser.LSLParser.RotationLiteralContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.rotationLiteral"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitFunctionDeclaration(LibLSLCC.AntlrParser.LSLParser.FunctionDeclarationContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.functionDeclaration"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitElseStatement(LibLSLCC.AntlrParser.LSLParser.ElseStatementContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.elseStatement"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitControlStructure(LibLSLCC.AntlrParser.LSLParser.ControlStructureContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.controlStructure"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitCodeScope(LibLSLCC.AntlrParser.LSLParser.CodeScopeContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.codeScope"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitDoLoop(LibLSLCC.AntlrParser.LSLParser.DoLoopContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.doLoop"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitWhileLoop(LibLSLCC.AntlrParser.LSLParser.WhileLoopContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.whileLoop"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitForLoop(LibLSLCC.AntlrParser.LSLParser.ForLoopContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.forLoop"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitLoopStructure(LibLSLCC.AntlrParser.LSLParser.LoopStructureContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.loopStructure"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitCodeStatement(LibLSLCC.AntlrParser.LSLParser.CodeStatementContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.codeStatement"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitExpressionStatement(LibLSLCC.AntlrParser.LSLParser.ExpressionStatementContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.expressionStatement"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitReturnStatement(LibLSLCC.AntlrParser.LSLParser.ReturnStatementContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.returnStatement"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitLabelStatement(LibLSLCC.AntlrParser.LSLParser.LabelStatementContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.labelStatement"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitJumpStatement(LibLSLCC.AntlrParser.LSLParser.JumpStatementContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.jumpStatement"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitStateChangeStatement(LibLSLCC.AntlrParser.LSLParser.StateChangeStatementContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.stateChangeStatement"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitLocalVariableDeclaration(LibLSLCC.AntlrParser.LSLParser.LocalVariableDeclarationContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.localVariableDeclaration"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitGlobalVariableDeclaration(LibLSLCC.AntlrParser.LSLParser.GlobalVariableDeclarationContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.globalVariableDeclaration"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitExpressionListTail(LibLSLCC.AntlrParser.LSLParser.ExpressionListTailContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.expressionListTail"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitExpressionList(LibLSLCC.AntlrParser.LSLParser.ExpressionListContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.expressionList"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitDotAccessorExpr(LibLSLCC.AntlrParser.LSLParser.DotAccessorExprContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.dotAccessorExpr"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitModifiableLeftValue(LibLSLCC.AntlrParser.LSLParser.ModifiableLeftValueContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.modifiableLeftValue"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitParenthesizedExpression(LibLSLCC.AntlrParser.LSLParser.ParenthesizedExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>ParenthesizedExpression</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitExpr_PrefixOperation(LibLSLCC.AntlrParser.LSLParser.Expr_PrefixOperationContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_PrefixOperation</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitExpr_Atom(LibLSLCC.AntlrParser.LSLParser.Expr_AtomContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_Atom</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitExpr_TypeCast(LibLSLCC.AntlrParser.LSLParser.Expr_TypeCastContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_TypeCast</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitExpr_DotAccessorExpr(LibLSLCC.AntlrParser.LSLParser.Expr_DotAccessorExprContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_DotAccessorExpr</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitExpr_BitwiseShift(LibLSLCC.AntlrParser.LSLParser.Expr_BitwiseShiftContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_BitwiseShift</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitExpr_LogicalCompare(LibLSLCC.AntlrParser.LSLParser.Expr_LogicalCompareContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_LogicalCompare</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitExpr_LogicalEquality(LibLSLCC.AntlrParser.LSLParser.Expr_LogicalEqualityContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_LogicalEquality</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitExpr_BitwiseOr(LibLSLCC.AntlrParser.LSLParser.Expr_BitwiseOrContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_BitwiseOr</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitExpr_Logical_And_Or(LibLSLCC.AntlrParser.LSLParser.Expr_Logical_And_OrContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_Logical_And_Or</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitExpr_BitwiseXor(LibLSLCC.AntlrParser.LSLParser.Expr_BitwiseXorContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_BitwiseXor</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitExpr_Assignment(LibLSLCC.AntlrParser.LSLParser.Expr_AssignmentContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_Assignment</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitExpr_MultDivMod(LibLSLCC.AntlrParser.LSLParser.Expr_MultDivModContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_MultDivMod</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitExpr_BitwiseAnd(LibLSLCC.AntlrParser.LSLParser.Expr_BitwiseAndContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_BitwiseAnd</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitExpr_PostfixOperation(LibLSLCC.AntlrParser.LSLParser.Expr_PostfixOperationContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_PostfixOperation</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitExpr_FunctionCall(LibLSLCC.AntlrParser.LSLParser.Expr_FunctionCallContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_FunctionCall</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitExpr_ModifyingAssignment(LibLSLCC.AntlrParser.LSLParser.Expr_ModifyingAssignmentContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_ModifyingAssignment</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitExpr_AddSub(LibLSLCC.AntlrParser.LSLParser.Expr_AddSubContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_AddSub</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitOptionalExpressionList(LibLSLCC.AntlrParser.LSLParser.OptionalExpressionListContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.optionalExpressionList"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitOptionalParameterList(LibLSLCC.AntlrParser.LSLParser.OptionalParameterListContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.optionalParameterList"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitListLiteral(LibLSLCC.AntlrParser.LSLParser.ListLiteralContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.listLiteral"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitCompilationUnit(LibLSLCC.AntlrParser.LSLParser.CompilationUnitContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.compilationUnit"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitParameterDefinition(LibLSLCC.AntlrParser.LSLParser.ParameterDefinitionContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.parameterDefinition"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitParameterList(LibLSLCC.AntlrParser.LSLParser.ParameterListContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.parameterList"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitEventHandler(LibLSLCC.AntlrParser.LSLParser.EventHandlerContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.eventHandler"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitDefinedState(LibLSLCC.AntlrParser.LSLParser.DefinedStateContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.definedState"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.LSLBaseVisitor`1.VisitDefaultState(LibLSLCC.AntlrParser.LSLParser.DefaultStateContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.defaultState"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="F:LibLSLCC.AntlrParser.LSLLexer.IDRegex">
            <summary>
            This should be updated when the ID token rule in LSL.g4 is changed, so that the rule and this regex match
            This regex matches/validates LSL ID Tokens, IE: variable names, state names, label names, function names
            </summary>
        </member>
        <member name="F:LibLSLCC.AntlrParser.LSLLexer.IDStartCharRegex">
            <summary>
            This should be updated when the ID token rule in LSL.g4 is changed, so that the rule and this regex match
            This regex matches/validates that a character is a valid starting character for an ID Token
            </summary>
        </member>
        <member name="F:LibLSLCC.AntlrParser.LSLLexer.IDTrailingCharRegex">
            <summary>
            This should be updated when the ID token rule in LSL.g4 is changed, so that the rule and this regex match
            This regex matches/validates that a character is a valid trailing character after the first character of an ID Token
            </summary>
        </member>
        <member name="T:LibLSLCC.AntlrParser.ILSLListener">
            <summary>
            This interface defines a complete listener for a parse tree produced by
            <see cref="T:LibLSLCC.AntlrParser.LSLParser"/>.
            </summary>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterVectorLiteral(LibLSLCC.AntlrParser.LSLParser.VectorLiteralContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.vectorLiteral"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitVectorLiteral(LibLSLCC.AntlrParser.LSLParser.VectorLiteralContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.vectorLiteral"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterRotationLiteral(LibLSLCC.AntlrParser.LSLParser.RotationLiteralContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.rotationLiteral"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitRotationLiteral(LibLSLCC.AntlrParser.LSLParser.RotationLiteralContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.rotationLiteral"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterFunctionDeclaration(LibLSLCC.AntlrParser.LSLParser.FunctionDeclarationContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.functionDeclaration"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitFunctionDeclaration(LibLSLCC.AntlrParser.LSLParser.FunctionDeclarationContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.functionDeclaration"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterElseStatement(LibLSLCC.AntlrParser.LSLParser.ElseStatementContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.elseStatement"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitElseStatement(LibLSLCC.AntlrParser.LSLParser.ElseStatementContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.elseStatement"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterControlStructure(LibLSLCC.AntlrParser.LSLParser.ControlStructureContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.controlStructure"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitControlStructure(LibLSLCC.AntlrParser.LSLParser.ControlStructureContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.controlStructure"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterCodeScope(LibLSLCC.AntlrParser.LSLParser.CodeScopeContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.codeScope"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitCodeScope(LibLSLCC.AntlrParser.LSLParser.CodeScopeContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.codeScope"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterDoLoop(LibLSLCC.AntlrParser.LSLParser.DoLoopContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.doLoop"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitDoLoop(LibLSLCC.AntlrParser.LSLParser.DoLoopContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.doLoop"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterWhileLoop(LibLSLCC.AntlrParser.LSLParser.WhileLoopContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.whileLoop"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitWhileLoop(LibLSLCC.AntlrParser.LSLParser.WhileLoopContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.whileLoop"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterForLoop(LibLSLCC.AntlrParser.LSLParser.ForLoopContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.forLoop"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitForLoop(LibLSLCC.AntlrParser.LSLParser.ForLoopContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.forLoop"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterLoopStructure(LibLSLCC.AntlrParser.LSLParser.LoopStructureContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.loopStructure"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitLoopStructure(LibLSLCC.AntlrParser.LSLParser.LoopStructureContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.loopStructure"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterCodeStatement(LibLSLCC.AntlrParser.LSLParser.CodeStatementContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.codeStatement"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitCodeStatement(LibLSLCC.AntlrParser.LSLParser.CodeStatementContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.codeStatement"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterExpressionStatement(LibLSLCC.AntlrParser.LSLParser.ExpressionStatementContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.expressionStatement"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitExpressionStatement(LibLSLCC.AntlrParser.LSLParser.ExpressionStatementContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.expressionStatement"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterReturnStatement(LibLSLCC.AntlrParser.LSLParser.ReturnStatementContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.returnStatement"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitReturnStatement(LibLSLCC.AntlrParser.LSLParser.ReturnStatementContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.returnStatement"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterLabelStatement(LibLSLCC.AntlrParser.LSLParser.LabelStatementContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.labelStatement"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitLabelStatement(LibLSLCC.AntlrParser.LSLParser.LabelStatementContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.labelStatement"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterJumpStatement(LibLSLCC.AntlrParser.LSLParser.JumpStatementContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.jumpStatement"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitJumpStatement(LibLSLCC.AntlrParser.LSLParser.JumpStatementContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.jumpStatement"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterStateChangeStatement(LibLSLCC.AntlrParser.LSLParser.StateChangeStatementContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.stateChangeStatement"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitStateChangeStatement(LibLSLCC.AntlrParser.LSLParser.StateChangeStatementContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.stateChangeStatement"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterLocalVariableDeclaration(LibLSLCC.AntlrParser.LSLParser.LocalVariableDeclarationContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.localVariableDeclaration"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitLocalVariableDeclaration(LibLSLCC.AntlrParser.LSLParser.LocalVariableDeclarationContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.localVariableDeclaration"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterGlobalVariableDeclaration(LibLSLCC.AntlrParser.LSLParser.GlobalVariableDeclarationContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.globalVariableDeclaration"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitGlobalVariableDeclaration(LibLSLCC.AntlrParser.LSLParser.GlobalVariableDeclarationContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.globalVariableDeclaration"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterExpressionListTail(LibLSLCC.AntlrParser.LSLParser.ExpressionListTailContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.expressionListTail"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitExpressionListTail(LibLSLCC.AntlrParser.LSLParser.ExpressionListTailContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.expressionListTail"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterExpressionList(LibLSLCC.AntlrParser.LSLParser.ExpressionListContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.expressionList"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitExpressionList(LibLSLCC.AntlrParser.LSLParser.ExpressionListContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.expressionList"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterDotAccessorExpr(LibLSLCC.AntlrParser.LSLParser.DotAccessorExprContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.dotAccessorExpr"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitDotAccessorExpr(LibLSLCC.AntlrParser.LSLParser.DotAccessorExprContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.dotAccessorExpr"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterModifiableLeftValue(LibLSLCC.AntlrParser.LSLParser.ModifiableLeftValueContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.modifiableLeftValue"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitModifiableLeftValue(LibLSLCC.AntlrParser.LSLParser.ModifiableLeftValueContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.modifiableLeftValue"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterParenthesizedExpression(LibLSLCC.AntlrParser.LSLParser.ParenthesizedExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>ParenthesizedExpression</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitParenthesizedExpression(LibLSLCC.AntlrParser.LSLParser.ParenthesizedExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>ParenthesizedExpression</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterExpr_PrefixOperation(LibLSLCC.AntlrParser.LSLParser.Expr_PrefixOperationContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_PrefixOperation</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitExpr_PrefixOperation(LibLSLCC.AntlrParser.LSLParser.Expr_PrefixOperationContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_PrefixOperation</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterExpr_Atom(LibLSLCC.AntlrParser.LSLParser.Expr_AtomContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_Atom</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitExpr_Atom(LibLSLCC.AntlrParser.LSLParser.Expr_AtomContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_Atom</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterExpr_TypeCast(LibLSLCC.AntlrParser.LSLParser.Expr_TypeCastContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_TypeCast</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitExpr_TypeCast(LibLSLCC.AntlrParser.LSLParser.Expr_TypeCastContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_TypeCast</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterExpr_DotAccessorExpr(LibLSLCC.AntlrParser.LSLParser.Expr_DotAccessorExprContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_DotAccessorExpr</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitExpr_DotAccessorExpr(LibLSLCC.AntlrParser.LSLParser.Expr_DotAccessorExprContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_DotAccessorExpr</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterExpr_BitwiseShift(LibLSLCC.AntlrParser.LSLParser.Expr_BitwiseShiftContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_BitwiseShift</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitExpr_BitwiseShift(LibLSLCC.AntlrParser.LSLParser.Expr_BitwiseShiftContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_BitwiseShift</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterExpr_LogicalCompare(LibLSLCC.AntlrParser.LSLParser.Expr_LogicalCompareContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_LogicalCompare</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitExpr_LogicalCompare(LibLSLCC.AntlrParser.LSLParser.Expr_LogicalCompareContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_LogicalCompare</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterExpr_LogicalEquality(LibLSLCC.AntlrParser.LSLParser.Expr_LogicalEqualityContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_LogicalEquality</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitExpr_LogicalEquality(LibLSLCC.AntlrParser.LSLParser.Expr_LogicalEqualityContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_LogicalEquality</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterExpr_BitwiseOr(LibLSLCC.AntlrParser.LSLParser.Expr_BitwiseOrContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_BitwiseOr</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitExpr_BitwiseOr(LibLSLCC.AntlrParser.LSLParser.Expr_BitwiseOrContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_BitwiseOr</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterExpr_Logical_And_Or(LibLSLCC.AntlrParser.LSLParser.Expr_Logical_And_OrContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_Logical_And_Or</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitExpr_Logical_And_Or(LibLSLCC.AntlrParser.LSLParser.Expr_Logical_And_OrContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_Logical_And_Or</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterExpr_BitwiseXor(LibLSLCC.AntlrParser.LSLParser.Expr_BitwiseXorContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_BitwiseXor</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitExpr_BitwiseXor(LibLSLCC.AntlrParser.LSLParser.Expr_BitwiseXorContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_BitwiseXor</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterExpr_Assignment(LibLSLCC.AntlrParser.LSLParser.Expr_AssignmentContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_Assignment</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitExpr_Assignment(LibLSLCC.AntlrParser.LSLParser.Expr_AssignmentContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_Assignment</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterExpr_MultDivMod(LibLSLCC.AntlrParser.LSLParser.Expr_MultDivModContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_MultDivMod</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitExpr_MultDivMod(LibLSLCC.AntlrParser.LSLParser.Expr_MultDivModContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_MultDivMod</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterExpr_BitwiseAnd(LibLSLCC.AntlrParser.LSLParser.Expr_BitwiseAndContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_BitwiseAnd</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitExpr_BitwiseAnd(LibLSLCC.AntlrParser.LSLParser.Expr_BitwiseAndContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_BitwiseAnd</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterExpr_PostfixOperation(LibLSLCC.AntlrParser.LSLParser.Expr_PostfixOperationContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_PostfixOperation</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitExpr_PostfixOperation(LibLSLCC.AntlrParser.LSLParser.Expr_PostfixOperationContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_PostfixOperation</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterExpr_FunctionCall(LibLSLCC.AntlrParser.LSLParser.Expr_FunctionCallContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_FunctionCall</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitExpr_FunctionCall(LibLSLCC.AntlrParser.LSLParser.Expr_FunctionCallContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_FunctionCall</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterExpr_ModifyingAssignment(LibLSLCC.AntlrParser.LSLParser.Expr_ModifyingAssignmentContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_ModifyingAssignment</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitExpr_ModifyingAssignment(LibLSLCC.AntlrParser.LSLParser.Expr_ModifyingAssignmentContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_ModifyingAssignment</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterExpr_AddSub(LibLSLCC.AntlrParser.LSLParser.Expr_AddSubContext)">
            <summary>
            Enter a parse tree produced by the <c>Expr_AddSub</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitExpr_AddSub(LibLSLCC.AntlrParser.LSLParser.Expr_AddSubContext)">
            <summary>
            Exit a parse tree produced by the <c>Expr_AddSub</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterOptionalExpressionList(LibLSLCC.AntlrParser.LSLParser.OptionalExpressionListContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.optionalExpressionList"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitOptionalExpressionList(LibLSLCC.AntlrParser.LSLParser.OptionalExpressionListContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.optionalExpressionList"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterOptionalParameterList(LibLSLCC.AntlrParser.LSLParser.OptionalParameterListContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.optionalParameterList"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitOptionalParameterList(LibLSLCC.AntlrParser.LSLParser.OptionalParameterListContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.optionalParameterList"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterListLiteral(LibLSLCC.AntlrParser.LSLParser.ListLiteralContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.listLiteral"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitListLiteral(LibLSLCC.AntlrParser.LSLParser.ListLiteralContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.listLiteral"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterCompilationUnit(LibLSLCC.AntlrParser.LSLParser.CompilationUnitContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.compilationUnit"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitCompilationUnit(LibLSLCC.AntlrParser.LSLParser.CompilationUnitContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.compilationUnit"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterParameterDefinition(LibLSLCC.AntlrParser.LSLParser.ParameterDefinitionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.parameterDefinition"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitParameterDefinition(LibLSLCC.AntlrParser.LSLParser.ParameterDefinitionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.parameterDefinition"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterParameterList(LibLSLCC.AntlrParser.LSLParser.ParameterListContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.parameterList"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitParameterList(LibLSLCC.AntlrParser.LSLParser.ParameterListContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.parameterList"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterEventHandler(LibLSLCC.AntlrParser.LSLParser.EventHandlerContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.eventHandler"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitEventHandler(LibLSLCC.AntlrParser.LSLParser.EventHandlerContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.eventHandler"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterDefinedState(LibLSLCC.AntlrParser.LSLParser.DefinedStateContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.definedState"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitDefinedState(LibLSLCC.AntlrParser.LSLParser.DefinedStateContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.definedState"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.EnterDefaultState(LibLSLCC.AntlrParser.LSLParser.DefaultStateContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.defaultState"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLListener.ExitDefaultState(LibLSLCC.AntlrParser.LSLParser.DefaultStateContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.defaultState"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="T:LibLSLCC.AntlrParser.ILSLVisitor`1">
            <summary>
            This interface defines a complete generic visitor for a parse tree produced
            by <see cref="T:LibLSLCC.AntlrParser.LSLParser"/>.
            </summary>
            <typeparam name="Result">The return type of the visit operation.</typeparam>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitVectorLiteral(LibLSLCC.AntlrParser.LSLParser.VectorLiteralContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.vectorLiteral"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitRotationLiteral(LibLSLCC.AntlrParser.LSLParser.RotationLiteralContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.rotationLiteral"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitFunctionDeclaration(LibLSLCC.AntlrParser.LSLParser.FunctionDeclarationContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.functionDeclaration"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitElseStatement(LibLSLCC.AntlrParser.LSLParser.ElseStatementContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.elseStatement"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitControlStructure(LibLSLCC.AntlrParser.LSLParser.ControlStructureContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.controlStructure"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitCodeScope(LibLSLCC.AntlrParser.LSLParser.CodeScopeContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.codeScope"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitDoLoop(LibLSLCC.AntlrParser.LSLParser.DoLoopContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.doLoop"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitWhileLoop(LibLSLCC.AntlrParser.LSLParser.WhileLoopContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.whileLoop"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitForLoop(LibLSLCC.AntlrParser.LSLParser.ForLoopContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.forLoop"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitLoopStructure(LibLSLCC.AntlrParser.LSLParser.LoopStructureContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.loopStructure"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitCodeStatement(LibLSLCC.AntlrParser.LSLParser.CodeStatementContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.codeStatement"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitExpressionStatement(LibLSLCC.AntlrParser.LSLParser.ExpressionStatementContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.expressionStatement"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitReturnStatement(LibLSLCC.AntlrParser.LSLParser.ReturnStatementContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.returnStatement"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitLabelStatement(LibLSLCC.AntlrParser.LSLParser.LabelStatementContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.labelStatement"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitJumpStatement(LibLSLCC.AntlrParser.LSLParser.JumpStatementContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.jumpStatement"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitStateChangeStatement(LibLSLCC.AntlrParser.LSLParser.StateChangeStatementContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.stateChangeStatement"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitLocalVariableDeclaration(LibLSLCC.AntlrParser.LSLParser.LocalVariableDeclarationContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.localVariableDeclaration"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitGlobalVariableDeclaration(LibLSLCC.AntlrParser.LSLParser.GlobalVariableDeclarationContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.globalVariableDeclaration"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitExpressionListTail(LibLSLCC.AntlrParser.LSLParser.ExpressionListTailContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.expressionListTail"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitExpressionList(LibLSLCC.AntlrParser.LSLParser.ExpressionListContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.expressionList"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitDotAccessorExpr(LibLSLCC.AntlrParser.LSLParser.DotAccessorExprContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.dotAccessorExpr"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitModifiableLeftValue(LibLSLCC.AntlrParser.LSLParser.ModifiableLeftValueContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.modifiableLeftValue"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitParenthesizedExpression(LibLSLCC.AntlrParser.LSLParser.ParenthesizedExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>ParenthesizedExpression</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitExpr_PrefixOperation(LibLSLCC.AntlrParser.LSLParser.Expr_PrefixOperationContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_PrefixOperation</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitExpr_Atom(LibLSLCC.AntlrParser.LSLParser.Expr_AtomContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_Atom</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitExpr_TypeCast(LibLSLCC.AntlrParser.LSLParser.Expr_TypeCastContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_TypeCast</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitExpr_DotAccessorExpr(LibLSLCC.AntlrParser.LSLParser.Expr_DotAccessorExprContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_DotAccessorExpr</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitExpr_BitwiseShift(LibLSLCC.AntlrParser.LSLParser.Expr_BitwiseShiftContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_BitwiseShift</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitExpr_LogicalCompare(LibLSLCC.AntlrParser.LSLParser.Expr_LogicalCompareContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_LogicalCompare</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitExpr_LogicalEquality(LibLSLCC.AntlrParser.LSLParser.Expr_LogicalEqualityContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_LogicalEquality</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitExpr_BitwiseOr(LibLSLCC.AntlrParser.LSLParser.Expr_BitwiseOrContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_BitwiseOr</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitExpr_Logical_And_Or(LibLSLCC.AntlrParser.LSLParser.Expr_Logical_And_OrContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_Logical_And_Or</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitExpr_BitwiseXor(LibLSLCC.AntlrParser.LSLParser.Expr_BitwiseXorContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_BitwiseXor</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitExpr_Assignment(LibLSLCC.AntlrParser.LSLParser.Expr_AssignmentContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_Assignment</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitExpr_MultDivMod(LibLSLCC.AntlrParser.LSLParser.Expr_MultDivModContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_MultDivMod</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitExpr_BitwiseAnd(LibLSLCC.AntlrParser.LSLParser.Expr_BitwiseAndContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_BitwiseAnd</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitExpr_PostfixOperation(LibLSLCC.AntlrParser.LSLParser.Expr_PostfixOperationContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_PostfixOperation</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitExpr_FunctionCall(LibLSLCC.AntlrParser.LSLParser.Expr_FunctionCallContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_FunctionCall</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitExpr_ModifyingAssignment(LibLSLCC.AntlrParser.LSLParser.Expr_ModifyingAssignmentContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_ModifyingAssignment</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitExpr_AddSub(LibLSLCC.AntlrParser.LSLParser.Expr_AddSubContext)">
            <summary>
            Visit a parse tree produced by the <c>Expr_AddSub</c>
            labeled alternative in <see cref="M:LibLSLCC.AntlrParser.LSLParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitOptionalExpressionList(LibLSLCC.AntlrParser.LSLParser.OptionalExpressionListContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.optionalExpressionList"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitOptionalParameterList(LibLSLCC.AntlrParser.LSLParser.OptionalParameterListContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.optionalParameterList"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitListLiteral(LibLSLCC.AntlrParser.LSLParser.ListLiteralContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.listLiteral"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitCompilationUnit(LibLSLCC.AntlrParser.LSLParser.CompilationUnitContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.compilationUnit"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitParameterDefinition(LibLSLCC.AntlrParser.LSLParser.ParameterDefinitionContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.parameterDefinition"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitParameterList(LibLSLCC.AntlrParser.LSLParser.ParameterListContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.parameterList"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitEventHandler(LibLSLCC.AntlrParser.LSLParser.EventHandlerContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.eventHandler"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitDefinedState(LibLSLCC.AntlrParser.LSLParser.DefinedStateContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.definedState"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:LibLSLCC.AntlrParser.ILSLVisitor`1.VisitDefaultState(LibLSLCC.AntlrParser.LSLParser.DefaultStateContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:LibLSLCC.AntlrParser.LSLParser.defaultState"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="T:LibLSLCC.AutoComplete.LSLAutoCompleteParseOptions">
            <summary>
            Autocompleter options.
            </summary>
        </member>
        <member name="F:LibLSLCC.AutoComplete.LSLAutoCompleteParseOptions.None">
            <summary>
            Specify no options.
            </summary>
        </member>
        <member name="F:LibLSLCC.AutoComplete.LSLAutoCompleteParseOptions.BlockOnInvalidPrefix">
            <summary>
            Block autocomplete if a invalid prefix character is found before <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset"/>. <para/>
            Invalid prefixes are determined by <see cref="M:LibLSLCC.AutoComplete.ILSLAutoCompleteParser.IsValidSuggestionPrefix(System.String)"/>.
            </summary>
            <seealso cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InvalidPrefix"/>
        </member>
        <member name="F:LibLSLCC.AutoComplete.LSLAutoCompleteParseOptions.BlockOnInvalidKeywordPrefix">
            <summary>
            Block autocomplete if a invalid prefix keyword is found before <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset"/>. <para/>
            Invalid prefixes are determined by <see cref="M:LibLSLCC.AutoComplete.ILSLAutoCompleteParser.IsInvalidSuggestionKeywordPrefix(System.String)"/>. <para/>
            An invalid keyword followed only by space before the ParseToOffset will cause autocomplete to be blocked.
            </summary>
            <seealso cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InvalidKeywordPrefix"/>
        </member>
        <member name="T:LibLSLCC.AutoComplete.ILSLAutoCompleteParser">
            <summary>
                Interface for auto complete parsers.
            </summary>
        </member>
        <member name="M:LibLSLCC.AutoComplete.ILSLAutoCompleteParser.GetLocalLabels(System.String)">
            <summary>
                Get an enumerable of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteLocalLabel" /> objects representing local labels
                that are accessible at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
            </summary>
            <param name="sourceCode">The source code of the entire script.</param>
            <returns>An enumerable of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteLocalLabel" /> objects that are accessible at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.</returns>
        </member>
        <member name="M:LibLSLCC.AutoComplete.ILSLAutoCompleteParser.GetLocalJumps(System.String)">
            <summary>
                Get an enumerable of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteLocalJump" /> objects representing local jump statements
                that are accessible at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />. 
            </summary>
            <param name="sourceCode">The source code of the entire script.</param>
            <returns>An enumerable of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteLocalJump" /> objects that are accessible at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.</returns>
        </member>
        <member name="M:LibLSLCC.AutoComplete.ILSLAutoCompleteParser.Parse(System.String,System.Int32,LibLSLCC.AutoComplete.LSLAutoCompleteParseOptions)">
            <summary>
                Preforms an auto-complete parse on the specified stream of LSL source code, up to an arbitrary offset.
            </summary>
            <param name="code">The input source code.</param>
            <param name="toOffset">To offset to parse up to (the cursor offset).</param>
            <param name="options">Parse options.</param>
        </member>
        <member name="M:LibLSLCC.AutoComplete.ILSLAutoCompleteParser.IsInvalidSuggestionKeywordPrefix(System.String)">
            <summary>
            Determine if autocomplete should be blocked if the only thing separating a given keyword from <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is whitespace. <para/>
            In other words, autocomplete cannot continue if <paramref name="keyword"/> comes before the cursor with only whitespace inbetween.
            </summary>
            <param name="keyword">The keyword or character sequence to test.</param>
            <returns><c>true</c> if the keyword/sequence blocks autocomplete.</returns>
            <seealso cref="F:LibLSLCC.AutoComplete.LSLAutoCompleteParseOptions.BlockOnInvalidKeywordPrefix"/>
            <seealso cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InvalidKeywordPrefix"/>
            <exception cref="T:System.ArgumentNullException"><paramref name="keyword"/> is <see langword="null" />.</exception>
        </member>
        <member name="M:LibLSLCC.AutoComplete.ILSLAutoCompleteParser.IsValidSuggestionPrefix(System.String)">
            <summary>
            Determine if a given character can come immediately before an autocomplete suggestion.  An empty string represents the begining of the source code.
            </summary>
            <param name="character">The character to test, or an empty string.</param>
            <returns><c>true</c> if the given character can appear before a suggestion.</returns>
            <seealso cref="F:LibLSLCC.AutoComplete.LSLAutoCompleteParseOptions.BlockOnInvalidPrefix"/>
            <seealso cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InvalidPrefix"/>
            <exception cref="T:System.ArgumentNullException"><paramref name="character"/> is <see langword="null" />.</exception>
        </member>
        <member name="M:LibLSLCC.AutoComplete.ILSLAutoCompleteParser.IsValidSuggestionSuffix(System.String)">
            <summary>
            Determine if a given character can come immediately after an autocomplete suggestion.  An empty string represents the end of the source code.
            </summary>
            <param name="character">The character to test, or an empty string.</param>
            <returns><c>true</c> if the given character can appear after a suggestion.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="character"/> is <see langword="null" />.</exception>
        </member>
        <member name="T:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState">
            <summary>
                Interface for <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteParser" />'s parse state.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset">
            <summary>
                The offset the <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteParser" /> last parsed to.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.CurrentState">
            <summary>
                The name of the state block <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> resides in.
                <c>null</c> if the parse to offset is outside of a state body.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.CurrentFunction">
            <summary>
                The name of the function declaration <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> resides in.
                <c>null</c> if the parse to offset is outside of a function body.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.CurrentEvent">
            <summary>
                The name of the event handler declaration <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> offset resides in.
                <c>null</c> if the parse to offset is outside of an event body.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InStateScope">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of a state block, but outside of an event handler
                declaration.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InEventSourceRange">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in the source code range of an event handler.
                This includes being within the name or parameter definitions.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InString">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset"/> is inside of a string literal.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InComment">
            <summary>
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InLineComment"/> or <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InBlockComment"/>
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InLineComment">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset"/> is inside of a line style comment.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InvalidPrefix">
            <summary>
                <c>true</c> if auto complete could not take place because the character preceding the given <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset"/>
                was not a valid suggestion prefix.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InvalidKeywordPrefix">
            <summary>
                <c>true</c> if auto complete could not take place because the keyword preceding the given <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset"/>
                prevented a suggestion.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InBlockComment">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset"/> is inside of a multi line block style comment.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InEventCodeBody">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is  anywhere inside the code body of an event handler.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InFunctionCodeBody">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is  anywhere inside the code body of a function declaration.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InGlobalScope">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in the global scope.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.StateBlocks">
            <summary>
                Gets a list of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteStateBlock" /> objects representing user defined script state blocks.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.DefaultState">
            <summary>
                Gets a <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteStateBlock" /> object representing the scripts default state.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.GlobalVariables">
            <summary>
                Gets an enumerable of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalVariable" /> objects representing global variables
                that are accessible at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.LocalVariables">
            <summary>
                Gets an enumerable of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteLocalVariable" /> objects representing local variables
                that are accessible at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.GlobalFunctionsDictionary">
            <summary>
                Gets a read only hash map of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalFunction" /> objects representing global function
                declarations that are accessible at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.  The functions are keyed in the hash map by name.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.GlobalVariablesDictionary">
            <summary>
                Gets a read only hash map of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalVariable" /> objects representing global variable
                declarations that are accessible at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.  The declarations are keyed in the hash map by
                name.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.LocalParametersDictionary">
            <summary>
                Gets a read only hash map of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteLocalParameter" /> objects representing local parameter
                declarations that are accessible at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.  The declarations are keyed in the hash map by
                name.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.GlobalFunctions">
            <summary>
                Gets an enumerable of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalFunction" /> objects representing global functions
                that are accessible at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InCodeStatementArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in an area where a code statement can exist.
                (<see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InMultiCodeStatementArea" /> || <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InBracelessCodeStatementArea" />)
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InMultiCodeStatementArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in a multi statement area where a code statement can exist.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InBracelessCodeStatementArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in an area where a brace-less code scope (single statement) can
                exist.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.LocalParameters">
            <summary>
                Gets an enumerable of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalFunction" /> objects representing local parameters that are
                accessible at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InExpressionTree">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of a binary expression/prefix expression/postfix expression
                or parenthesized expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.RightOfDotAccessor">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is to the right of the dot in a dot member accessor expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InLocalVariableDeclarationExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of the expression used to declare a local variable.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InGlobalVariableDeclarationExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of the expression used to declare a global variable.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InFunctionDeclarationParameterList">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of a function declarations parameter declaration list.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InEventDeclarationParameterList">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of an event declarations parameter declaration list.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InIfConditionExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of an 'if' statements condition expression area.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InElseIfConditionExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of an 'else if' statements condition expression area.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InCodeBody">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is anywhere inside of a function declaration or event declaration code
                body.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InLocalExpressionArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in a local expression area, such as a condition area or function
                call arguments. etc..
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InGlobalExpressionArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in a global area. currently only when
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InGlobalVariableDeclarationExpression" /> is <c>true</c>.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InExpressionArea">
            <summary>
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InGlobalExpressionArea" /> || <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InLocalExpressionArea" />.
                If the offset is in a global variable declaration expression, or the start of one.  Or
                a local expression area such as an expression statement, loop condition, function call parameters, for loop clauses
                etc..
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InFunctionReturnExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in the expression area of a return statement inside of a function.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InModifyingVariableAssignmentExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in the expression area right of a compound operation/assignment to a
                variable, such as after var += (here).
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InModifyingComponentAssignmentExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in the expression area right of a compound operation/assignment to a
                member of a variable, such as after var.x += (here).
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InPlainVariableAssignmentExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in the expression area right of an assignment to a variable, such as
                after var = (here).
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InPlainComponentAssignmentExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in the expression area right of an assignment to a member of a
                variable, such as after var.x = (here).
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InVariableAssignmentExpression">
            <summary>
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InPlainVariableAssignmentExpression" /> || <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InModifyingVariableAssignmentExpression" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InComponentAssignmentExpression">
            <summary>
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InPlainComponentAssignmentExpression" /> || <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InModifyingComponentAssignmentExpression" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InStateChangeStatementStateNameArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in an area where you could start typing the name of the state in a
                state change statement.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InJumpStatementLabelNameArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in an area where you could start typing the name of the label in a
                jump statement.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InLabelDefinitionNameArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in an area where you could start typing the name of a label.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InForLoopClausesArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is anywhere in a for loops clauses area.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InDoWhileConditionExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in a do while statements condition area.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InWhileConditionExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in a while statements condition area.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InControlStatementSourceRange">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in the source code range of a control statement.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InFunctionCallParameterList">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of a function calls parameter expression list.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InListLiteralInitializer">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of a list literals initializer expression list.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InVectorLiteralInitializer">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of a vector literals initializer expression list.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InRotationLiteralInitializer">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of a rotation literals initializer expression list.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.CanSuggestLibraryConstant">
            <summary>
                <c>true</c> if a library constant can be suggested at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InExpressionArea" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.CanSuggestFunction">
            <summary>
                <c>true</c> if a function call can be suggested at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
                (<see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InLocalExpressionArea" /> || <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InCodeStatementArea" />)
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.CanSuggestLocalVariableOrParameter">
            <summary>
                <c>true</c> if a local variable or parameter name can be suggested at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
                (<see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InLocalExpressionArea" /> || <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InCodeStatementArea" />)
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.CanSuggestGlobalVariable">
            <summary>
                <c>true</c> if a global variable can be suggested at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
                (<see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InLocalExpressionArea" /> || <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InCodeStatementArea" />)
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.CanSuggestEventHandler">
            <summary>
                <c>true</c> if an event handler can be suggested at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InStateScope" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.CanSuggestStateName">
            <summary>
                <c>true</c> if a state name can be suggested at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InStateChangeStatementStateNameArea" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.CanSuggestLabelNameJumpTarget">
            <summary>
                <c>true</c> if a label name for a jump target can be suggested at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InJumpStatementLabelNameArea" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.CanSuggestLabelNameDefinition">
            <summary>
                <c>true</c> if a label definitions name can be suggested at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InLabelDefinitionNameArea" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.CanSuggestTypeName">
            <summary>
                <c>true</c> if an LSL type name can be suggested at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ScopeAddressAtOffset">
            <summary>
                Gets the computed scope address at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.CurrentCodeAreaRange">
            <summary>
                Gets the source code range of the code body <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> exists inside of.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.AfterIfOrElseIfStatement">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is after an 'if' or 'else if' statements code body.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.CanSuggestControlStatement">
            <summary>
                <c>true</c> if a control statement chain can be suggested at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InCodeStatementArea" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.CanSuggestStateChangeStatement">
            <summary>
                <c>true</c> if a state change statement can be suggested at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InCodeStatementArea" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.CanSuggestReturnStatement">
            <summary>
                <c>true</c> if a return statement can be suggested at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InCodeStatementArea" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.CanSuggestJumpStatement">
            <summary>
                <c>true</c> if a jump statement can be suggested at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InCodeStatementArea" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.CurrentFunctionReturnType">
            <summary>
                Gets the return type of the function declaration that <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is currently in the code body
                of.
            </summary>
        </member>
        <member name="T:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalFunction">
            <summary>
                Represents a global function declaration that was parsed by the auto complete parser
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalFunction.HasReturnType">
            <summary>
                Gets a value indicating whether the function declaration has a return type.
            </summary>
            <value>
                <c>true</c> if the declaration has a return type; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalFunction.SourceRangeName">
            <summary>
                Gets the <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> of the function name.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalFunction.SourceRangeReturnType">
            <summary>
                Gets the <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> of the functions return type if it exists, otherwise <c>null</c>.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalFunction.Name">
            <summary>
                Gets the name used in the function declaration.
            </summary>
            <value>
                The name of the function.
            </value>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalFunction.ReturnTypeName">
            <summary>
                Gets the string representing the return type used in the function declaration.
                If none exists (<see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalFunction.HasReturnType" /> if <c>false</c>), then it will be <c>null</c>.
            </summary>
            <value>
                The return type string if a return type is specified, otherwise <c>null</c>
            </value>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalFunction.FullSignature">
            <summary>
                The full signature of the global function declaration.
                Defined as: <c>ReturnTypeName+" "+Name+ParameterSignature</c> if there is a return type specified.
                If there is no return type then it's: <c>Name+ParameterSignature</c>
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalFunction.ParametersSignature">
            <summary>
                Returns a string representing the parameter signature used in the function declaration, this includes the
                parentheses.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalFunction.Parameters">
            <summary>
                Gets a read only array of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteLocalParameter" /> objects representing the parameters used in
                the function declaration.
            </summary>
            <value>
                The parameters used in the function declaration.
            </value>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalFunction.SourceRange">
            <summary>
                Gets the source code range that encompasses the entire function declaration.
            </summary>
            <value>
                The source code range of the entire function declaration.
            </value>
        </member>
        <member name="T:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalVariable">
            <summary>
                Represents a global variable parsed by the auto complete parser
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalVariable.Name">
            <summary>
                Gets the name of the global variable.
            </summary>
            <value>
                The name of the global variable.
            </value>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalVariable.TypeName">
            <summary>
                Gets a string representing the type that the global variable was defined as.
            </summary>
            <value>
                The type string representing the type the global variable was defined as.
            </value>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalVariable.SourceRange">
            <summary>
                Get the <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> that encompasses the entire variable declaration.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalVariable.SourceRangeName">
            <summary>
                Gets the <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> of the global variable name.
            </summary>
            <value>
                The <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> of the global variable name.
            </value>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalVariable.SourceRangeType">
            <summary>
                Gets the <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> of the global variable type specifier.
            </summary>
            <value>
                The <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> of the global variable type specifier.
            </value>
        </member>
        <member name="T:LibLSLCC.AutoComplete.LSLAutoCompleteLocalJump">
            <summary>
                Represents a local jump statement parsed by the auto complete parser.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteLocalJump.TargetName">
            <summary>
                Gets a string representing the name of the label this jump statement jumps to.
            </summary>
            <value>
                The string representing the name of the label this jump statement jumps to.
            </value>
        </member>
        <member name="T:LibLSLCC.AutoComplete.LSLAutoCompleteLocalLabel">
            <summary>
                Represents a local label statement parsed by the auto complete parser.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteLocalLabel.Name">
            <summary>
                Gets the name used in the label statement.
            </summary>
            <value>
                The name used in the label statement.
            </value>
        </member>
        <member name="T:LibLSLCC.AutoComplete.LSLAutoCompleteLocalParameter">
            <summary>
                Represents a local parameter parsed by the auto complete parser.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteLocalParameter.SourceRangeName">
            <summary>
                The <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> that encompasses the name of the local parameter.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteLocalParameter.SourceRangeType">
            <summary>
                The <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> that encompasses the type specifier of the local parameter.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteLocalParameter.ScopeAddress">
            <summary>
                Gets the scope address where the local parameter declaration began to be visible to child scopes.
            </summary>
            <value>
                The scope address where the local parameter declaration began to be visible to child scopes.
            </value>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteLocalParameter.Name">
            <summary>
                Gets the name of the local parameter.
            </summary>
            <value>
                The name of the local parameter.
            </value>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteLocalParameter.TypeName">
            <summary>
                Gets a string representing the type specifier used the declare the local parameter.
            </summary>
            <value>
                A string representing the type specifier used the declare the local parameter.
            </value>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteLocalParameter.SourceRange">
            <summary>
                Gets the <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> that encompasses the type specifier and name of the local parameter
                declaration.
            </summary>
            <value>
                The <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> that encompasses the type specifier and name of the local parameter
                declaration.
            </value>
        </member>
        <member name="T:LibLSLCC.AutoComplete.LSLAutoCompleteLocalVariable">
            <summary>
                Represents a local variable declaration parsed by the auto complete parser.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteLocalVariable.SourceRangeName">
            <summary>
                Gets the <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> that encompasses the local variable name.
            </summary>
            <value>
                The <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> that encompasses the local variable name.
            </value>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteLocalVariable.SourceRangeType">
            <summary>
                Gets the <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> that encompasses the local variable type specifier.
            </summary>
            <value>
                The <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> that encompasses the local variable type specifier.
            </value>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteLocalVariable.ScopeAddress">
            <summary>
                Gets the scope address where this local variable came in to existence.
            </summary>
            <value>
                The scope address where this local variable came in to existence.
            </value>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteLocalVariable.Name">
            <summary>
                Gets the name of the local variable.
            </summary>
            <value>
                The name of the local variable.
            </value>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteLocalVariable.TypeName">
            <summary>
                Gets a string representing the type specifier used when declaring the local variable.
            </summary>
            <value>
                A string representing the type specifier used when declaring the local variable.
            </value>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteLocalVariable.SourceRange">
            <summary>
                Gets the <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> that encompasses the local variable declaration statement.
            </summary>
            <value>
                The <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> that encompasses the local variable declaration statement.
            </value>
        </member>
        <member name="T:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase">
            <summary>
                An abstract base class with common functionality for auto complete parsers.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.ParserState">
            <summary>
                Sets the <see cref="T:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState" /> implementation.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.ParseToOffset">
            <summary>
                The offset the <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteParser" /> last parsed to.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.CurrentState">
            <summary>
                The name of the state block <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> resides in.
                <c>null</c> if the parse to offset is outside of a state body.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.CurrentFunction">
            <summary>
                The name of the function declaration <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> resides in.
                <c>null</c> if the parse to offset is outside of a function body.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.CurrentEvent">
            <summary>
                The name of the event handler declaration <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> offset resides
                in.
                <c>null</c> if the parse to offset is outside of an event body.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InStateScope">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of a state block, but outside of
                an
                event handler declaration.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InEventSourceRange">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in the source code range of an event
                handler.
                This includes being within the name or parameter definitions.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InString">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset"/> is inside of a string literal.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InComment">
            <summary>
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InLineComment"/> or <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InBlockComment"/>
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InLineComment">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset"/> is inside of a line style comment.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InvalidPrefix">
            <summary>
                <c>true</c> if auto complete could not take place because the character preceding the given <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset"/>
                was not a valid suggestion prefix.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InvalidKeywordPrefix">
            <summary>
                <c>true</c> if auto complete could not take place because the keyword preceding the given <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset"/>
                prevented a suggestion.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InBlockComment">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset"/> is inside of a multi line block style comment.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InEventCodeBody">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is anywhere inside the code body of an
                event handler.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InFunctionCodeBody">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is anywhere inside the code body of a
                function
                declaration.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InGlobalScope">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in the global scope.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.StateBlocks">
            <summary>
                Gets a list of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteStateBlock" /> objects representing user defined script state blocks.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.DefaultState">
            <summary>
                Gets a <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteStateBlock" /> object representing the scripts default state.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.GlobalVariables">
            <summary>
                Gets an enumerable of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalVariable" /> objects representing global variables
                that are accessible at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.LocalVariables">
            <summary>
                Gets an enumerable of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteLocalVariable" /> objects representing local variables
                that are accessible at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.GlobalFunctionsDictionary">
            <summary>
                Gets a read only hash map of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalFunction" /> objects representing global function
                declarations
                that are accessible at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.  The functions are keyed in the
                hash
                map by name.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.GlobalVariablesDictionary">
            <summary>
                Gets a read only hash map of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalVariable" /> objects representing global variable
                declarations
                that are accessible at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.  The declarations are keyed in the
                hash
                map by name.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.LocalParametersDictionary">
            <summary>
                Gets a read only hash map of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteLocalParameter" /> objects representing local parameter
                declarations
                that are accessible at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.  The declarations are keyed in the
                hash
                map by name.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.GlobalFunctions">
            <summary>
                Gets an enumerable of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalFunction" /> objects representing global functions
                that are accessible at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InCodeStatementArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in an area where a code statement can
                exist.
                (<see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InMultiCodeStatementArea" /> ||
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InBracelessCodeStatementArea" />)
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InMultiCodeStatementArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in a multi statement area where a code
                statement can exist.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InBracelessCodeStatementArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in an area where a brace-less code scope
                (single statement) can exist.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.LocalParameters">
            <summary>
                Gets an enumerable of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalFunction" /> objects representing local parameters
                that are accessible at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InExpressionTree">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of a binary expression/prefix
                expression/postfix expression or parenthesized expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.RightOfDotAccessor">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is to the right of the dot in a dot member
                accessor expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InLocalVariableDeclarationExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of the expression used to declare
                a
                local variable.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InGlobalVariableDeclarationExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of the expression used to declare
                a
                global variable.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InFunctionDeclarationParameterList">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of a function declarations
                parameter
                declaration list.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InEventDeclarationParameterList">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of an event declarations
                parameter
                declaration list.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InIfConditionExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of an 'if' statements condition
                expression area.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InElseIfConditionExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of an 'else if' statements
                condition
                expression area.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InCodeBody">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of a function declaration or
                event
                declaration code body.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InLocalExpressionArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in a local expression area, such as a
                condition area or function call arguments. etc..
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InGlobalExpressionArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in a global area. currently only when
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InGlobalVariableDeclarationExpression" /> is <c>true</c>.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InExpressionArea">
            <summary>
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InGlobalExpressionArea" /> ||
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InLocalExpressionArea" />.
                If the offset is in a global variable declaration expression, or the start of one.  Or
                a local expression area such as an expression statement, loop condition, function call parameters, for loop clauses
                etc..
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InFunctionReturnExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in the expression area of a return
                statement
                inside of a function.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InModifyingVariableAssignmentExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in the expression area right of a
                compound
                operation/assignment to a variable, such as after var += (here).
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InModifyingComponentAssignmentExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in the expression area right of a
                compound
                operation/assignment to a member of a variable, such as after var.x += (here).
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InPlainVariableAssignmentExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in the expression area right of an
                assignment
                to a variable, such as after var = (here).
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InPlainComponentAssignmentExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in the expression area right of an
                assignment
                to a member of a variable, such as after var.x = (here).
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InVariableAssignmentExpression">
            <summary>
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InPlainVariableAssignmentExpression" /> ||
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InModifyingVariableAssignmentExpression" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InComponentAssignmentExpression">
            <summary>
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InPlainComponentAssignmentExpression" /> ||
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InModifyingComponentAssignmentExpression" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InStateChangeStatementStateNameArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in an area where you could start typing
                the
                name of the state in a state change statement.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InJumpStatementLabelNameArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in an area where you could start typing
                the
                name of the label in a jump statement.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InLabelDefinitionNameArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in an area where you could start typing
                the
                name of a label.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InForLoopClausesArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is anywhere in a for loops clauses area.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InDoWhileConditionExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in a do while statements condition area.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InWhileConditionExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in a while statements condition area.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InControlStatementSourceRange">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is in the source code range of a control
                statement.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InFunctionCallParameterList">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of a function calls parameter
                expression list.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InListLiteralInitializer">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of a list literals initializer
                expression list.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InVectorLiteralInitializer">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of a vector literals initializer
                expression list.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.InRotationLiteralInitializer">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is inside of a rotation literals
                initializer
                expression list.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.CanSuggestLibraryConstant">
            <summary>
                <c>true</c> if a library constant can be suggested at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InExpressionArea" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.CanSuggestFunction">
            <summary>
                <c>true</c> if a function call can be suggested at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
                (<see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InLocalExpressionArea" /> ||
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InCodeStatementArea" />)
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.CanSuggestLocalVariableOrParameter">
            <summary>
                <c>true</c> if a local variable or parameter name can be suggested at
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
                (<see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InLocalExpressionArea" /> ||
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InCodeStatementArea" />)
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.CanSuggestGlobalVariable">
            <summary>
                <c>true</c> if a global variable can be suggested at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
                (<see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InLocalExpressionArea" /> ||
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InCodeStatementArea" />)
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.CanSuggestEventHandler">
            <summary>
                <c>true</c> if an event handler can be suggested at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InStateScope" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.CanSuggestStateName">
            <summary>
                <c>true</c> if a state name can be suggested at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InStateChangeStatementStateNameArea" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.CanSuggestLabelNameJumpTarget">
            <summary>
                <c>true</c> if a label name for a jump target can be suggested at
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InJumpStatementLabelNameArea" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.CanSuggestLabelNameDefinition">
            <summary>
                <c>true</c> if a label definitions name can be suggested at
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InLabelDefinitionNameArea" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.CanSuggestTypeName">
            <summary>
                <c>true</c> if an LSL type name can be suggested at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.ScopeAddressAtOffset">
            <summary>
                Gets the computed scope address at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.CurrentCodeAreaRange">
            <summary>
                Gets the source code range of the code body <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> exists inside
                of.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.AfterIfOrElseIfStatement">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is after an 'if' or 'else if' statements
                code
                body.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.CanSuggestControlStatement">
            <summary>
                <c>true</c> if a control statement chain can be suggested at
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InCodeStatementArea" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.CanSuggestStateChangeStatement">
            <summary>
                <c>true</c> if a state change statement can be suggested at
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InCodeStatementArea" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.CanSuggestReturnStatement">
            <summary>
                <c>true</c> if a return statement can be suggested at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InCodeStatementArea" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.CanSuggestJumpStatement">
            <summary>
                <c>true</c> if a jump statement can be suggested at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InCodeStatementArea" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.CurrentFunctionReturnType">
            <summary>
                Gets the return type of the function declaration that <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is
                currently in the code body of.
            </summary>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.GetLocalLabels(System.String)">
            <summary>
                Get an enumerable of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteLocalLabel" /> objects representing local labels
                that are accessible at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.
            </summary>
            <param name="sourceCode">The source code of the entire script.</param>
            <returns>An enumerable of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteLocalLabel" /> objects that are accessible at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.</returns>
            <exception cref="T:System.InvalidOperationException">If <see cref="M:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.Parse(System.String,System.Int32,LibLSLCC.AutoComplete.LSLAutoCompleteParseOptions)" /> has not been called first.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="sourceCode" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.GetLocalJumps(System.String)">
            <summary>
                Get an enumerable of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteLocalJump" /> objects representing local jump statements
                that are accessible at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />. 
            </summary>
            <param name="sourceCode">The source code of the entire script.</param>
            <returns>An enumerable of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteLocalJump" /> objects that are accessible at <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" />.</returns>
            <exception cref="T:System.InvalidOperationException">If <see cref="M:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.Parse(System.String,System.Int32,LibLSLCC.AutoComplete.LSLAutoCompleteParseOptions)" /> has not been called first.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="sourceCode" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.Parse(System.String,System.Int32,LibLSLCC.AutoComplete.LSLAutoCompleteParseOptions)">
            <summary>
                Preforms an auto-complete parse on the specified stream of LSL source code, up to an arbitrary offset.
            </summary>
            <param name="code">The input source code.</param>
            <param name="toOffset">To offset to parse up to (the cursor offset).</param>
            <param name="options">Parse options.</param>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.IsInvalidSuggestionKeywordPrefix(System.String)">
            <summary>
            Determine if autocomplete should be blocked if the only thing separating a given keyword from <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is whitespace. <para/>
            In other words, autocomplete cannot continue if <paramref name="keyword"/> comes before the cursor with only whitespace inbetween.
            </summary>
            <param name="keyword">The keyword or character sequence to test.</param>
            <returns><c>true</c> if the keyword/sequence blocks autocomplete.</returns>
            <seealso cref="F:LibLSLCC.AutoComplete.LSLAutoCompleteParseOptions.BlockOnInvalidKeywordPrefix"/>
            <seealso cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InvalidKeywordPrefix"/>
            <exception cref="T:System.ArgumentNullException"><paramref name="keyword"/> is <see langword="null" />.</exception>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.IsValidSuggestionPrefix(System.String)">
            <summary>
            Determine if a given character can come immediately before an autocomplete suggestion.  An empty string represents the begining of the source code.
            </summary>
            <param name="character">The character to test, or an empty string.</param>
            <returns><c>true</c> if the given character can appear before a suggestion.</returns>
            <seealso cref="F:LibLSLCC.AutoComplete.LSLAutoCompleteParseOptions.BlockOnInvalidPrefix"/>
            <seealso cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InvalidPrefix"/>
            <exception cref="T:System.ArgumentNullException"><paramref name="character"/> is <see langword="null" />.</exception>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLAutoCompleteParserBase.IsValidSuggestionSuffix(System.String)">
            <summary>
            Determine if a given character can come immediately after an autocomplete suggestion.  An empty string represents the end of the source code.
            </summary>
            <param name="character">The character to test, or an empty string.</param>
            <returns><c>true</c> if the given character can appear after a suggestion.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="character"/> is <see langword="null" />.</exception>
        </member>
        <member name="T:LibLSLCC.AutoComplete.LSLAutoCompleteStateBlock">
            <summary>
                Represents a state block parsed by the auto complete parser.
            </summary>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLAutoCompleteStateBlock.#ctor(System.String,LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Construct an auto complete state block given a state name and source code range.
            </summary>
            <param name="name">The name of the state.</param>
            <param name="range">The source code range the state block occupies.</param>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteStateBlock.Name">
            <summary>
                The name of the state.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteStateBlock.SourceRange">
            <summary>
                The source code range the state block occupies.
            </summary>
        </member>
        <member name="T:LibLSLCC.AutoComplete.LSLAutoCompleteScopeAddress">
            <summary>
                Represents a scope address within the auto complete parser.
            </summary>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLAutoCompleteScopeAddress.Equals(LibLSLCC.AutoComplete.LSLAutoCompleteScopeAddress)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLAutoCompleteScopeAddress.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            true if <paramref name="obj"/> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
            <param name="obj">Another object to compare to. </param>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLAutoCompleteScopeAddress.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLAutoCompleteScopeAddress.op_Equality(LibLSLCC.AutoComplete.LSLAutoCompleteScopeAddress,LibLSLCC.AutoComplete.LSLAutoCompleteScopeAddress)">
            <summary>
            Test two <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteScopeAddress"/> for equality, uses: <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteScopeAddress.CodeAreaId"/>, <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteScopeAddress.ScopeId"/> and <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteScopeAddress.ScopeLevel"/>.
            </summary>
            <param name="left">The left scope address.</param>
            <param name="right">The right scope address.</param>
            <returns><c>true</c> if both objects have equal properties; otherwise <c>false</c></returns>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLAutoCompleteScopeAddress.op_Inequality(LibLSLCC.AutoComplete.LSLAutoCompleteScopeAddress,LibLSLCC.AutoComplete.LSLAutoCompleteScopeAddress)">
            <summary>
            Test two <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteScopeAddress"/> for inequality, uses: <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteScopeAddress.CodeAreaId"/>, <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteScopeAddress.ScopeId"/> and <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteScopeAddress.ScopeLevel"/>.
            </summary>
            <param name="left">The left scope address.</param>
            <param name="right">The right scope address.</param>
            <returns><c>true</c> if both objects have inequal properties; otherwise <c>false</c></returns>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLAutoCompleteScopeAddress.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
                Construct a new scope address given a code area ID, scope ID and scope level.
            </summary>
            <param name="codeAreaId">The code area ID of the address.</param>
            <param name="scopeId">The scope ID of the address.</param>
            <param name="scopeLevel">The cope level of the address.</param>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteScopeAddress.CodeAreaId">
            <summary>
                Effectively the index of the code able script area.
                Each time a function declaration body or event handler body is encountered, this address value increases by one.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteScopeAddress.ScopeLevel">
            <summary>
                The overall scope level, every time an opening brace is encountered this increments, and when a closing brace is
                encountered it decrements.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteScopeAddress.ScopeId">
            <summary>
                Gets the scope ID,  the top level of a function declaration scope or event handler scope is considered to be
                ScopeId=1.
                Subsequent scopes within the function declaration or event handler declaration cause the ID value to increment, it
                is never decremented.
                It resets to 1 at the top level of every function declaration or event handler.
            </summary>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLAutoCompleteScopeAddress.ToString">
            <summary>
                Returns a string that represents the scope address.
                The format is: "(CodeAreaID: 0, ScopeID: 0, ScopeLevel: 0)"
            </summary>
            <returns>A string in the format: "(CodeAreaID: 0, ScopeID: 0, ScopeLevel: 0)".</returns>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.#ctor(System.Int32)">
            <exception cref="T:System.ArgumentOutOfRangeException">parseToOffset less than zero.</exception>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset">
            <summary>
                The offset the <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteParser" /> last parsed to.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.CurrentState">
            <summary>
                The name of the state block <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> resides in.
                <c>null</c> if the parse to offset is outside of a state body.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.CurrentFunction">
            <summary>
                The name of the function declaration <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> resides in.
                <c>null</c> if the parse to offset is outside of a function body.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.CurrentEvent">
            <summary>
                The name of the event handler declaration <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> offset resides in.
                <c>null</c> if the parse to offset is outside of an event body.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InStateScope">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is inside of a state block, but outside of an event handler
                declaration.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InEventSourceRange">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is in the source code range of an event handler.
                This includes being within the name or parameter definitions.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InString">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset"/> is inside of a string literal.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InEventCodeBody">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is anywhere inside the code body of an event handler.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InFunctionCodeBody">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is inside anywhere the code body of a function declaration.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InGlobalScope">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is in the global scope.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.StateBlocks">
            <summary>
                Gets a list of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteStateBlock" /> objects representing user defined script state blocks.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.DefaultState">
            <summary>
                Gets a <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteStateBlock" /> object representing the scripts default state.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.GlobalVariables">
            <summary>
                Gets an enumerable of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalVariable" /> objects representing global variables
                that are accessible at <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.LocalVariables">
            <summary>
                Gets an enumerable of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteLocalVariable" /> objects representing local variables
                that are accessible at <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.GlobalFunctionsDictionary">
            <summary>
                Gets a read only hash map of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalFunction" /> objects representing global function
                declarations
                that are accessible at <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" />.  The functions are keyed in the hash map by name.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.GlobalVariablesDictionary">
            <summary>
                Gets a read only hash map of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalVariable" /> objects representing global variable
                declarations
                that are accessible at <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" />.  The declarations are keyed in the hash map by name.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.LocalParametersDictionary">
            <summary>
                Gets a read only hash map of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteLocalParameter" /> objects representing local parameter
                declarations
                that are accessible at <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" />.  The declarations are keyed in the hash map by name.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.GlobalFunctions">
            <summary>
                Gets an enumerable of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalFunction" /> objects representing global functions
                that are accessible at <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InCodeStatementArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is in an area where a code statement can exist.
                (<see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InMultiCodeStatementArea" /> || <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InBracelessCodeStatementArea" />)
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InMultiCodeStatementArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is in a multi statement area where a code statement can exist.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InBracelessCodeStatementArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is in an area where a brace-less code scope (single statement) can
                exist.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.LocalParameters">
            <summary>
                Gets an enumerable of <see cref="T:LibLSLCC.AutoComplete.LSLAutoCompleteGlobalFunction" /> objects representing local parameters
                that are accessible at <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InExpressionTree">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is inside of a binary expression/prefix expression/postfix expression
                or parenthesized expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.RightOfDotAccessor">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is to the right of the dot in a dot member accessor expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InLocalVariableDeclarationExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is inside of the expression used to declare a local variable.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InGlobalVariableDeclarationExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is inside of the expression used to declare a global variable.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InFunctionDeclarationParameterList">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is inside of a function declarations parameter declaration list.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InEventDeclarationParameterList">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is inside of an event declarations parameter declaration list.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InIfConditionExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is inside of an 'if' statements condition expression area.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InElseIfConditionExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is inside of an 'else if' statements condition expression area.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InCodeBody">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is anywhere inside of a function declaration or event declaration code
                body.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InLocalExpressionArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is in a local expression area, such as a condition area or function
                call arguments. etc..
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InGlobalExpressionArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is in a global area. currently only when
                <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InGlobalVariableDeclarationExpression" /> is <c>true</c>.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InExpressionArea">
            <summary>
                <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InGlobalExpressionArea" /> || <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InLocalExpressionArea" />.
                If the offset is in a global variable declaration expression, or the start of one.  Or
                a local expression area such as an expression statement, loop condition, function call parameters, for loop clauses
                etc..
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InFunctionReturnExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is in the expression area of a return statement inside of a function.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InModifyingVariableAssignmentExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is in the expression area right of a compound operation/assignment to a
                variable, such as after var += (here).
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InModifyingComponentAssignmentExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is in the expression area right of a compound operation/assignment to a
                member of a variable, such as after var.x += (here).
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InPlainVariableAssignmentExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is in the expression area right of an assignment to a variable, such as
                after var = (here).
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InPlainComponentAssignmentExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is in the expression area right of an assignment to a member of a
                variable, such as after var.x = (here).
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InVariableAssignmentExpression">
            <summary>
                <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InPlainVariableAssignmentExpression" /> || <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InModifyingVariableAssignmentExpression" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InComponentAssignmentExpression">
            <summary>
                <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InPlainComponentAssignmentExpression" /> || <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InModifyingComponentAssignmentExpression" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InStateChangeStatementStateNameArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is in an area where you could start typing the name of the state in a
                state change statement.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InJumpStatementLabelNameArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is in an area where you could start typing the name of the label in a
                jump statement.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InLabelDefinitionNameArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is in an area where you could start typing the name of a label.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InForLoopClausesArea">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is anywhere in a for loops clauses area.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InDoWhileConditionExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is in a do while statements condition area.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InWhileConditionExpression">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is in a while statements condition area.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InControlStatementSourceRange">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is in the source code range of a control statement.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InFunctionCallParameterList">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is inside of a function calls parameter expression list.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InListLiteralInitializer">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is inside of a list literals initializer expression list.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InVectorLiteralInitializer">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is inside of a vector literals initializer expression list.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InRotationLiteralInitializer">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is inside of a rotation literals initializer expression list.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.CanSuggestLibraryConstant">
            <summary>
                <c>true</c> if a library constant can be suggested at <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InExpressionArea" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.CanSuggestFunction">
            <summary>
                <c>true</c> if a function call can be suggested at <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" />.
                (<see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InLocalExpressionArea" /> || <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InCodeStatementArea" />)
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.CanSuggestLocalVariableOrParameter">
            <summary>
                <c>true</c> if a local variable or parameter name can be suggested at <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" />.
                (<see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InLocalExpressionArea" /> || <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InCodeStatementArea" />)
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.CanSuggestGlobalVariable">
            <summary>
                <c>true</c> if a global variable can be suggested at <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" />.
                (<see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InLocalExpressionArea" /> || <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InCodeStatementArea" />)
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.CanSuggestEventHandler">
            <summary>
                <c>true</c> if an event handler can be suggested at <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InStateScope" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.CanSuggestStateName">
            <summary>
                <c>true</c> if a state name can be suggested at <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InStateChangeStatementStateNameArea" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.CanSuggestLabelNameJumpTarget">
            <summary>
                <c>true</c> if a label name for a jump target can be suggested at <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InJumpStatementLabelNameArea" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.CanSuggestLabelNameDefinition">
            <summary>
                <c>true</c> if a label definitions name can be suggested at <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InLabelDefinitionNameArea" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.CanSuggestTypeName">
            <summary>
                <c>true</c> if an LSL type name can be suggested at <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ScopeAddressAtOffset">
            <summary>
                Gets the computed scope address at <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.CurrentCodeAreaRange">
            <summary>
                Gets the source code range of the code body <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> exists inside of.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.AfterIfOrElseIfStatement">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is after an 'if' or 'else if' statements code body.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.CanSuggestControlStatement">
            <summary>
                <c>true</c> if a control statement chain can be suggested at <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InCodeStatementArea" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.CanSuggestStateChangeStatement">
            <summary>
                <c>true</c> if a state change statement can be suggested at <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InCodeStatementArea" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.CanSuggestReturnStatement">
            <summary>
                <c>true</c> if a return statement can be suggested at <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InCodeStatementArea" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.CanSuggestJumpStatement">
            <summary>
                <c>true</c> if a jump statement can be suggested at <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" />.
                <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InCodeStatementArea" />
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.CurrentFunctionReturnType">
            <summary>
                Gets the return type of the function declaration that <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset" /> is currently in the code body
                of.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InComment">
            <summary>
                <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InLineComment"/> or <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InBlockComment"/>
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InLineComment">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset"/> is inside of a line style comment.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InBlockComment">
            <summary>
                <c>true</c> if <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset"/> is inside of a multi line block style comment.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InvalidPrefix">
            <summary>
                <c>true</c> if auto complete could not take place because the character preceding the given <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset"/>
                was not a valid suggestion prefix.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.InvalidKeywordPrefix">
            <summary>
                <c>true</c> if auto complete could not take place because the keyword preceding the given <see cref="P:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.ParseToOffset"/>
                prevented a suggestion.
            </summary>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLAutoCompleteVisitor.Parse(LibLSLCC.AntlrParser.LSLParser.CompilationUnitContext)">
            <exception cref="T:System.ArgumentNullException"><paramref name="context" /> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.AutoComplete.LSLCommentAndStringDetector">
            <summary>
                A class to help determine if an offset into LSL source code is inside of a comment or string literal.
            </summary>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLCommentAndStringDetector.#ctor">
            <summary>
                Construct an LSLCommentStringSkipper that will be ready to parse upon construction.
            </summary>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLCommentAndStringDetector.#ctor(System.String,System.Int32)">
            <summary>
                Construct an LSLCommentStringSkipper and automatically parse the provided text up to a given offset.
            </summary>
            <param name="text">The text to be parsed.</param>
            <param name="parseUpTo">The offset to be parsed up to.</param>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLCommentAndStringDetector.ScopeLevel">
            <summary>
                A rough estimation of scope level at the current offset.  This counter is incremented every
                time an opening brace is found and decremented whenever a closing brace is found.
                If there are missing/mismatched braces then its value will not be accurate.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLCommentAndStringDetector.InBlockComment">
            <summary>
                True if the offset that was parsed up to is inside a block style comment.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLCommentAndStringDetector.InLineComment">
            <summary>
                True if the offset that was parsed up to is inside a line style comment.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLCommentAndStringDetector.InString">
            <summary>
                True if the offset that was parsed up to is inside a string literal.
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLCommentAndStringDetector.InComment">
            <summary>
                True if the offset that was parsed up to is inside any sort of comment.
                Effectively equal to: (InLineComment || InBlockComment)
            </summary>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLCommentAndStringDetector.Reset">
            <summary>
                Reset the LSLCommentStringSkipper so it can parse again.
            </summary>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLCommentAndStringDetector.ParseUpTo(System.String,System.Int32)">
            <summary>
                Parse the given text up to a given offset.
            </summary>
            <param name="text">The text to parse.</param>
            <param name="offset">The offset into the text to parse up to.</param>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLCommentAndStringDetector.FeedChar(System.String,System.Int32,System.Int32)">
            <summary>
                Feeds a single character from the given text at a certain index into the parser.
            </summary>
            <param name="text">The text the character is to be pulled from.</param>
            <param name="i">The index of the character in the text to feed to the parser.</param>
            <param name="offset">The offset at which the parser is set to parse up to.</param>
        </member>
        <member name="T:LibLSLCC.AutoComplete.LSLAutoCompleteParser">
            <summary>
                An LSL parser that can help with implementing context aware auto-complete inside of code editors.
            </summary>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLAutoCompleteParser.Parse(System.String,System.Int32,LibLSLCC.AutoComplete.LSLAutoCompleteParseOptions)">
            <summary>
                Preforms an auto-complete parse on the specified stream of LSL source code, up to an arbitrary offset.
            </summary>
            <param name="code">The input source code.</param>
            <param name="toOffset">To offset to parse up to (the cursor offset).</param>
            <param name="options">Parse options.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">if <paramref name="toOffset" /> is not greater than zero.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="code" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLAutoCompleteParser.IsInvalidSuggestionKeywordPrefix(System.String)">
            <summary>
            Determine if autocomplete should be blocked if the only thing separating a given keyword from <see cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.ParseToOffset" /> is whitespace. <para/>
            In other words, autocomplete cannot continue if <paramref name="keyword"/> comes before the cursor with only whitespace inbetween.
            </summary>
            <param name="keyword">The keyword or character sequence to test.</param>
            <returns><c>true</c> if the keyword/sequence blocks autocomplete.</returns>
            <seealso cref="F:LibLSLCC.AutoComplete.LSLAutoCompleteParseOptions.BlockOnInvalidKeywordPrefix"/>
            <seealso cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InvalidKeywordPrefix"/>
            <exception cref="T:System.ArgumentNullException"><paramref name="keyword"/> is <see langword="null" />.</exception>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLAutoCompleteParser.IsValidSuggestionPrefix(System.String)">
            <summary>
            Determine if a given character can come immediately before an autocomplete suggestion.  An empty string represents the begining of the source code.
            </summary>
            <param name="character">The character to test, or an empty string.</param>
            <returns><c>true</c> if the given character can appear before a suggestion.</returns>
            <seealso cref="F:LibLSLCC.AutoComplete.LSLAutoCompleteParseOptions.BlockOnInvalidPrefix"/>
            <seealso cref="P:LibLSLCC.AutoComplete.ILSLAutoCompleteParserState.InvalidPrefix"/>
            <exception cref="T:System.ArgumentNullException"><paramref name="character"/> is <see langword="null" />.</exception>
        </member>
        <member name="M:LibLSLCC.AutoComplete.LSLAutoCompleteParser.IsValidSuggestionSuffix(System.String)">
            <summary>
            Determine if a given character can come immediately after an autocomplete suggestion.  An empty string represents the end of the source code.
            </summary>
            <param name="character">The character to test, or an empty string.</param>
            <returns><c>true</c> if the given character can appear after a suggestion.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="character"/> is <see langword="null" />.</exception>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParser.ValidSuggestionSuffixes">
            <summary>
            Returns a hashset copy of all valid suggestion suffixes.  see: <see cref="M:LibLSLCC.AutoComplete.LSLAutoCompleteParser.IsValidSuggestionSuffix(System.String)"/>
            </summary>
        </member>
        <member name="P:LibLSLCC.AutoComplete.LSLAutoCompleteParser.ValidSuggestionPrefixes">
            <summary>
            Returns a hashset copy of all valid suggestion prefixes.  see: <see cref="M:LibLSLCC.AutoComplete.LSLAutoCompleteParser.IsValidSuggestionPrefix(System.String)"/>
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor.#ctor(LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies)">
            <exception cref="T:System.ArgumentException">An <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies" /> property was null</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="validatorStrategies" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor.HasSyntaxWarnings">
            <summary>
                Gets a value indicating if syntax warnings were present after a visit.
            </summary>
            <value>
                <c>true</c> if syntax warnings are present; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor.HasSyntaxErrors">
            <summary>
                Gets a value indicating if syntax errors were present after a visit.
            </summary>
            <value>
                <c>true</c> if syntax errors are present; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor.SyntaxWarningListener">
            <summary>
                Gets the syntax warning listener.  this property should NOT be used to generate warning events,
                use <see cref="M:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor.GenSyntaxWarning" /> for that instead.
            </summary>
            <value>
                The syntax warning listener.
            </value>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor.SyntaxErrorListener">
            <summary>
                Gets the syntax error listener.  this property should NOT be used to generate error events,
                use <see cref="M:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor.GenSyntaxError" /> for that instead.
            </summary>
            <value>
                The syntax error listener.
            </value>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor.GenSyntaxWarning">
            <summary>
                Returns a reference to <see cref="P:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor.SyntaxWarningListener" /> and sets <see cref="P:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor.HasSyntaxWarnings" /> to
                <c>true</c>.
            </summary>
            <returns>
                <see cref="P:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor.SyntaxWarningListener" />
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor.GenSyntaxError">
            <summary>
                Returns a reference to <see cref="P:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor.SyntaxErrorListener" /> and sets <see cref="P:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor.HasSyntaxErrors" /> to <c>true</c>.
            </summary>
            <returns>
                <see cref="P:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor.SyntaxErrorListener" />
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor.AddReferenceToFunctionDefinition(LibLSLCC.CodeValidator.LSLPreDefinedFunctionSignature,LibLSLCC.CodeValidator.LSLFunctionCallNode)">
            <summary>
                Calls .AddReference(result) on functionSignature.DefinitionNode if it is not null (the function was defined before
                the call was encountered)
                Otherwise, appends the function call node to the dictionary of list _referencesToNotYetDefinedFunctions
                The key is the function name, the list associated with the key is all the references to it before it was defined.
                Function signatures are defined in a pre-pass, and later there body's are added;
                If the function is undefined anywhere, this function is never utilized
            </summary>
            <param name="functionSignature">
                The function signature that was pre-defined in the pre-pass for the function we are
                referencing
            </param>
            <param name="node">The function call node that was constructed for this function reference</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor.AddReferencesWhereFunctionNotYetDefined(LibLSLCC.CodeValidator.LSLFunctionDeclarationNode)">
            <summary>
                Called when a function is finally defined, if there are any references to it that were made before
                its node was constructed (before it was defined in source) we add them here from the
                _referencesToNotYetDefinedFunctions
                dictionary.  Its looked up by name and all the references in the associated list (if its an entry in the
                dictionary) are
                added to the definition via node.AddReference
            </summary>
            <param name="node">The function declaration node to add possible pre-definition references to</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor.ValidateFunctionCallSignatureMatch(LibLSLCC.AntlrParser.LSLParser.Expr_FunctionCallContext,LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.Collections.IReadOnlyGenericArray{LibLSLCC.CodeValidator.ILSLReadOnlyExprNode})">
            <summary>
                Validate that a <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" /> matches up with the parameters that are attempting to be passed
                into it.
                This function generates <see cref="P:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor.SyntaxErrorListener" /> events
            </summary>
            <param name="context">The ANTLR context for the parsed function call.</param>
            <param name="functionSignature">The function signature of the function call being tested.</param>
            <param name="expressions">The expressions that are proposed to be passed into the function with the given signature.</param>
            <returns>True if the function call signature matches the provided arguments,  False if it does not.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor.ValidateLibraryFunctionCallSignatureMatch(LibLSLCC.AntlrParser.LSLParser.Expr_FunctionCallContext,LibLSLCC.Collections.IReadOnlyGenericArray{LibLSLCC.LibraryData.LSLLibraryFunctionSignature},LibLSLCC.Collections.IReadOnlyGenericArray{LibLSLCC.CodeValidator.ILSLReadOnlyExprNode})">
            <summary>
                Find a matching overload from a list of function signatures, generate SyntaxErrors using the
                <see cref="P:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor.SyntaxErrorListener" /> if none is found.
                Returns null if no overload is found.
            </summary>
            <param name="context">The ANTLR context for the function call expression.</param>
            <param name="functionSignatures">Function signatures to check for overload matches in.</param>
            <param name="expressions">The expressions that are proposed to be passed into the function with the given signature.</param>
            <returns>A matching LSLLibraryFunctionSignature overload or null</returns>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor._lastContextWithListAssign">
            <summary>
                Only used by CheckForMultipleListAssignment
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor._lastContextWithStringAssign">
            <summary>
                Only used by CheckForMultipleStringExpression
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor.ResetMultipleAssignmentWarningMemory">
            <summary>
                Resets data used to prevent multiple assignment warnings for lists and strings from appearing twice
                for the same expression node
                This data is currently reset at the end of code scope nodes (event handler and function body's)
                which can contain multiple expression statements, instead of after every top level expression node visit,
                this is for simplicity
                the data is also reset after visits to global variable declarations, since there can be an expression on
                the right side of the assignment
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor.BinaryExpressionContext">
            <summary>
                Represents a generic binary expression operation.
                I made alternative grammar label names for each different type of expression operation so that I could
                differentiate between postfix, casts etc.. unfortunately each type of binary operation must be named
                uniquely or ANTLR will complain, so the different binary expression visitor functions build this object
                and pass it to VisitBinaryExpression.  All binary expression contexts have the same properties,
                but they cannot be made to derive from one type as ANTLR generates them and it does not have a feature to
                allow it
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLCodeValidatorVisitor.AssignmentExpressionContext">
            <summary>
                Represents a generic assignment expression operation.
                Similar use to the struct above, except for assignment and modifying assignment operators.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionAndStateDefinitionPrePass.SyntaxWarningListener">
            <summary>
                Gets the syntax warning listener.  this property should NOT be used to generate warning events,
                use <see cref="M:LibLSLCC.CodeValidator.LSLFunctionAndStateDefinitionPrePass.GenSyntaxWarning" /> for that instead.
            </summary>
            <value>
                The syntax warning listener.
            </value>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionAndStateDefinitionPrePass.SyntaxErrorListener">
            <summary>
                Gets the syntax error listener.  this property should NOT be used to generate error events,
                use <see cref="M:LibLSLCC.CodeValidator.LSLFunctionAndStateDefinitionPrePass.GenSyntaxError" /> for that instead.
            </summary>
            <value>
                The syntax error listener.
            </value>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionAndStateDefinitionPrePass.GenSyntaxWarning">
            <summary>
                Returns a reference to <see cref="P:LibLSLCC.CodeValidator.LSLFunctionAndStateDefinitionPrePass.SyntaxWarningListener" /> and sets <see cref="P:LibLSLCC.CodeValidator.LSLFunctionAndStateDefinitionPrePass.HasSyntaxWarnings" /> to
                <c>true</c>.
            </summary>
            <returns>
                <see cref="P:LibLSLCC.CodeValidator.LSLFunctionAndStateDefinitionPrePass.SyntaxWarningListener" />
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionAndStateDefinitionPrePass.GenSyntaxError">
            <summary>
                Returns a reference to <see cref="P:LibLSLCC.CodeValidator.LSLFunctionAndStateDefinitionPrePass.SyntaxErrorListener" /> and sets <see cref="P:LibLSLCC.CodeValidator.LSLFunctionAndStateDefinitionPrePass.HasSyntaxErrors" /> to <c>true</c>.
            </summary>
            <returns>
                <see cref="P:LibLSLCC.CodeValidator.LSLFunctionAndStateDefinitionPrePass.SyntaxErrorListener" />
            </returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLLabelCollectorPrePass.SyntaxWarningListener">
            <summary>
                Gets the syntax warning listener.  this property should NOT be used to generate warning events,
                use <see cref="M:LibLSLCC.CodeValidator.LSLLabelCollectorPrePass.GenSyntaxWarning" /> for that instead.
            </summary>
            <value>
                The syntax warning listener.
            </value>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLLabelCollectorPrePass.SyntaxErrorListener">
            <summary>
                Gets the syntax error listener.  this property should NOT be used to generate error events,
                use <see cref="M:LibLSLCC.CodeValidator.LSLLabelCollectorPrePass.GenSyntaxError" /> for that instead.
            </summary>
            <value>
                The syntax error listener.
            </value>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLLabelCollectorPrePass.GenSyntaxWarning">
            <summary>
                Returns a reference to <see cref="P:LibLSLCC.CodeValidator.LSLLabelCollectorPrePass.SyntaxWarningListener" /> and sets <see cref="P:LibLSLCC.CodeValidator.LSLLabelCollectorPrePass.HasSyntaxWarnings" /> to
                <c>true</c>.
            </summary>
            <returns>
                <see cref="P:LibLSLCC.CodeValidator.LSLLabelCollectorPrePass.SyntaxWarningListener" />
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLLabelCollectorPrePass.GenSyntaxError">
            <summary>
                Returns a reference to <see cref="P:LibLSLCC.CodeValidator.LSLLabelCollectorPrePass.SyntaxErrorListener" /> and sets <see cref="P:LibLSLCC.CodeValidator.LSLLabelCollectorPrePass.HasSyntaxErrors" /> to <c>true</c>.
            </summary>
            <returns>
                <see cref="P:LibLSLCC.CodeValidator.LSLLabelCollectorPrePass.SyntaxErrorListener" />
            </returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeValidatorVisitorScopeTracker.CurrentCodeScopeType">
            <exception cref="T:LibLSLCC.CodeValidator.LSLCodeValidatorInternalException" accessor="get">if not inside a scope.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeValidatorVisitorScopeTracker.CurrentCodeScopeContext">
            <exception cref="T:LibLSLCC.CodeValidator.LSLCodeValidatorInternalException" accessor="get">if not inside a scope.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeValidatorVisitorScopeTracker.AllLocalVariablesInScope">
            <summary>
                All local variables in the current scope, excluding parameters
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeValidatorVisitorScopeTracker.AllParametersInScope">
            <summary>
                All parameters defined in the current scope
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidatorVisitorScopeTracker.CanVariableBeDefined(System.String,LibLSLCC.CodeValidator.LSLVariableScope)">
            <summary>
                Determines if given the current scoping state, can a variable be defined without causing a conflict
            </summary>
            <param name="name">name of the variable</param>
            <param name="scope">the scope level of the variable to be defined</param>
            <returns>whether or not the variable can be defined without conflict</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLCreateSignatureNodeExtensions">
            <summary>
            Extensions for creating LSL signature primitives from related syntax tree nodes.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCreateSignatureNodeExtensions.CreateSignature(LibLSLCC.CodeValidator.ILSLFunctionDeclarationNode)">
            <summary>
                Build a <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" /> object based off the signature of this function declaration node.
            </summary>
            <param name="functionDeclarationNode">The <see cref="T:LibLSLCC.CodeValidator.ILSLFunctionDeclarationNode"/>.</param>
            <returns>The created <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="functionDeclarationNode"/> is <see langword="null" />.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCreateSignatureNodeExtensions.CreateSignature(LibLSLCC.CodeValidator.ILSLParameterNode)">
            <summary>
                Build a <see cref="T:LibLSLCC.CodeValidator.LSLParameterSignature" /> object based off the signature of this parameter declaration node.
            </summary>
            <param name="parameterNode">The <see cref="T:LibLSLCC.CodeValidator.ILSLParameterNode"/>.</param>
            <returns>The created <see cref="T:LibLSLCC.CodeValidator.LSLParameterSignature" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="parameterNode"/> is <see langword="null" />.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCreateSignatureNodeExtensions.CreateSignature(LibLSLCC.CodeValidator.ILSLParameterNode,System.Int32)">
            <summary>
                Build a <see cref="T:LibLSLCC.CodeValidator.LSLParameterSignature" /> object based off the signature of this parameter declaration node, with the given parameter index.
            </summary>
            <param name="parameterNode">The <see cref="T:LibLSLCC.CodeValidator.ILSLParameterNode"/>.</param>
            <param name="parameterIndex">The parameter index to use for the created paramter signature.</param>
            <returns>The created <see cref="T:LibLSLCC.CodeValidator.LSLParameterSignature" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="parameterNode"/> is <see langword="null" />.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCreateSignatureNodeExtensions.CreateSignature(LibLSLCC.CodeValidator.ILSLEventHandlerNode)">
            <summary>
                Build a <see cref="T:LibLSLCC.CodeValidator.LSLEventSignature" /> object based off the signature of this function declaration node.
            </summary>
            <param name="eventHandlerNode">The <see cref="T:LibLSLCC.CodeValidator.ILSLEventHandlerNode"/>.</param>
            <returns>The created <see cref="T:LibLSLCC.CodeValidator.LSLEventSignature" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="eventHandlerNode"/> is <see langword="null" />.</exception>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLCodeSegment">
            <summary>
            Read only interface for code segments.  <para/>
            Code segments are used to describe a sequential set of code statement nodes that exist in the same scope.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCodeSegment.EndNode">
            <summary>
                The <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement" /> at the end of the code segment.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCodeSegment.SourceRange">
            <summary>
                The source code range that encompasses all <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement" /> objects in the <see cref="T:LibLSLCC.CodeValidator.LSLCodeSegment"/>.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> for any added statements, this property will be <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCodeSegment.SourceRangeAvailable">
            <summary>
            <c>true</c> if <see cref="P:LibLSLCC.CodeValidator.ILSLCodeSegment.SourceRange"/> could be calculated for this segment and is non <c>null</c>.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCodeSegment.StartNode">
            <summary>
                The <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement" /> at the start of the code segment.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCodeSegment.StatementNodes">
            <summary>
                All <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement" /> in the code segment, in order of definition.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLEventSignature">
            <summary>
                A read only interface for <see cref="T:LibLSLCC.CodeValidator.LSLEventSignature" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLEventSignature.ParameterCount">
            <summary>
                The number of parameters the event handler signature has
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLEventSignature.Name">
            <summary>
                The event handlers name, must follow LSL symbol naming conventions
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLEventSignature.Parameters">
            <summary>
                Indexable list of objects describing the event handlers parameters
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLEventSignature.SignatureString">
            <summary>
                Returns a formated signature string for the <see cref="T:LibLSLCC.CodeValidator.ILSLEventSignature" />.  This does not include a trailing
                semi-colon.
                An example would be: listen(integer channel, string name, key id, string message)
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLEventSignature.ToString">
            <summary>
                Delegates to <see cref="P:LibLSLCC.CodeValidator.ILSLEventSignature.SignatureString" />
            </summary>
            <returns>
                <see cref="P:LibLSLCC.CodeValidator.ILSLEventSignature.SignatureString" />
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLEventSignature.SignatureMatches(LibLSLCC.CodeValidator.ILSLEventSignature)">
            <summary>
                Determines if two event handler signatures match exactly, parameter names do not matter but parameter
                types do.
            </summary>
            <param name="otherSignature">The other event handler signature to compare to.</param>
            <returns>True if the two signatures are identical.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherSignature" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLEventSignature.GetHashCode">
            <summary>
                <see cref="M:LibLSLCC.CodeValidator.ILSLEventSignature.GetHashCode" /> uses the name of the <see cref="T:LibLSLCC.CodeValidator.ILSLEventSignature" /> and the LSL Types of the
                parameters.
                <para />
                This means the Hash Code is determined by the event name, and the Types of all its parameters.
                <para />
                Inherently, uniqueness is also determined by the number of parameters.
            </summary>
            <returns>Hash code for this <see cref="T:LibLSLCC.CodeValidator.ILSLEventSignature" /></returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLEventSignature.Equals(System.Object)">
            <summary>
                <see cref="M:LibLSLCC.CodeValidator.ILSLEventSignature.Equals(System.Object)" /> delegates to <see cref="M:LibLSLCC.CodeValidator.ILSLEventSignature.SignatureMatches(LibLSLCC.CodeValidator.ILSLEventSignature)" />
            </summary>
            <param name="obj">The other event signature</param>
            <returns>Equality</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLFunctionSignature">
            <summary>
            A read only interface for <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature"/>.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionSignature.ParameterCount">
            <summary>
                Returns the number of parameters the function signature has including variadic parameters.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionSignature.ConcreteParameterCount">
            <summary>
                Returns the number of non variadic parameters the function signature has.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionSignature.ReturnType">
            <summary>
                The functions LSL return type.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionSignature.Name">
            <summary>
                The functions name, must follow LSL symbol naming conventions.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionSignature.Parameters">
            <summary>
                Indexable list of objects describing the functions parameters.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionSignature.ConcreteParameters">
            <summary>
                An enumerable of all non-variadic parameters in the function signature.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionSignature.SignatureString">
            <summary>
                Returns a formated signature string for the function signature without a trailing semi-colon. <para/>
                Such as:  float llAbs(float value) Or: modInvokeN(string fname, params any[] parms) <para/>
                The later being a function from OpenSim's modInvoke API to demonstrate variadic parameter formating. <para/>
                If a parameter is variadic and has a type that is not void, the 'any' keyword will be replaced with the corresponding name for the type.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionSignature.HasVariadicParameter">
            <summary>
                Whether or not a variadic parameter has been added to this function signature. <para/>
                There can only be one variadic parameter.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionSignature.VariadicParameterIndex">
            <summary>
                The index of the variadic parameter in the Parameters list, or -1 if none exists.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLFunctionSignature.ToString">
            <summary>
                Delegates to <see cref="P:LibLSLCC.CodeValidator.ILSLFunctionSignature.SignatureString"/>.
            </summary>
            <returns>
                <see cref="P:LibLSLCC.CodeValidator.ILSLFunctionSignature.SignatureString"/>
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLFunctionSignature.SignatureEquivalent(LibLSLCC.CodeValidator.ILSLFunctionSignature)">
            <summary>
                Determines if two function signatures match exactly (including return type), parameter names do not matter but
                parameter types do.
            </summary>
            <param name="otherSignature">The other function signature to compare to</param>
            <returns>True if the two signatures are identical</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherSignature"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLFunctionSignature.DefinitionIsDuplicate(LibLSLCC.CodeValidator.ILSLFunctionSignature)">
            <summary>
                Determines if a given <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" /> is a duplicate definition of this function signature. <para/>
                The logic behind this is a bit different than SignatureMatches(). <para/>
                If the given function signature has the same name, a differing return type and both functions have no parameters;
                than this function will return true
                and <see cref="M:LibLSLCC.CodeValidator.ILSLFunctionSignature.SignatureEquivalent(LibLSLCC.CodeValidator.ILSLFunctionSignature)" /> will not. <para/>
                If the other signature is an overload that is ambiguous in all cases due to variadic parameters, this function
                returns true.
            </summary>
            <remarks>
            </remarks>
            <param name="otherSignature">The other function signature to compare to</param>
            <returns>
                True if the two signatures are duplicate definitions of each other, taking static overloading ambiguities into
                account.
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLFunctionSignature.GetHashCode">
            <summary>
                <see cref="M:LibLSLCC.CodeValidator.ILSLFunctionSignature.GetHashCode"/> uses <see cref="P:LibLSLCC.CodeValidator.ILSLFunctionSignature.Name" />, <see cref="P:LibLSLCC.CodeValidator.LSLFunctionSignature.ReturnType" /> and the 
                <see cref="P:LibLSLCC.CodeValidator.LSLParameterSignature.Type" />/<see cref="P:LibLSLCC.CodeValidator.LSLParameterSignature.Variadic" /> status of the parameters. <para/>
                this means the Hash Code is linked the Function name, return Type and the Types/Variadic'ness of all its parameters. <para/>
                Inherently, uniqueness is also determined by the number of parameters.
            </summary>
            <returns>Hash code for this <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" /></returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLFunctionSignature.Equals(System.Object)">
            <summary>
                Equals(object obj) delegates to <see cref="M:LibLSLCC.CodeValidator.LSLFunctionSignature.SignatureEquivalent(LibLSLCC.CodeValidator.ILSLFunctionSignature)" />
            </summary>
            <param name="obj">The other function signature</param>
            <returns>Equality</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategiesExtensions">
            <summary>
                Extensions for <see cref="T:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategiesExtensions.IsComplete(LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies)">
            <summary>
                Returns true if all strategy properties are non null.
            </summary>
            <param name="strategies">The <see cref="T:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies" /> to check.</param>
            <returns>True if all properties are initialized.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="strategies" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategiesExtensions.IsComplete(LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies,System.String@)">
            <summary>
                Returns true if all strategy properties are non null.
            </summary>
            <param name="strategies">The <see cref="T:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies" /> to check.</param>
            <param name="describeNulls">
                A string describing which properties are null if
                <see cref="M:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategiesExtensions.IsComplete(LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies,System.String@)" /> returns <c>false</c>
            </param>
            <returns>True if all properties are initialized.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="strategies" /> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies">
            <summary>
                A basic <see cref="T:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies" /> implementation that allows you to assign values to its properties.
                <see cref="M:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies.Default" /> will return a copy of this object with all the default strategy implementations assigned.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies.ExpressionValidator">
            <summary>
                The expression validator is in charge of determining if two types are valid
                in a binary expression.  Among other things, like checking if an expression
                of some type can be passed into a function parameter.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies.LibraryDataProvider">
            <summary>
                The library data provider gives the code validator information about standard library functions,
                constants and events that exist in the LSL namespace.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies.StringLiteralPreProcessor">
            <summary>
                The string literal pre-processor is in charge of pre-processing string literals
                from source code before the value is assigned to a <see cref="T:LibLSLCC.CodeValidator.LSLStringLiteralNode" /> object
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies.SyntaxErrorListener">
            <summary>
                The syntax error listener is an interface that listens for syntax
                errors from the code validator
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies.SyntaxWarningListener">
            <summary>
                The syntax error listener is an interface that listens for syntax
                warnings from the code validator
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies.Default">
            <summary>
                Returns LibLSLCC's default <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies" /> setup.
            </summary>
            <returns>LibLSLCC's default <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies" /> setup</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies.Default(LibLSLCC.CodeValidator.ILSLSyntaxErrorListener,LibLSLCC.CodeValidator.ILSLSyntaxWarningListener)">
            <summary>
                Returns LibLSLCC's default <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies" /> setup.
                Allows the use of custom <see cref="T:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener"/> and <see cref="T:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener"/>.
            </summary>
            <param name="errorListener">The syntax error listener to use.</param>
            <param name="warningListener">The syntax warning listener to use.</param>
            <returns>LibLSLCC's default <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies" /> setup</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies.Default(LibLSLCC.CodeValidator.ILSLBasicLibraryDataProvider,LibLSLCC.CodeValidator.ILSLSyntaxErrorListener,LibLSLCC.CodeValidator.ILSLSyntaxWarningListener)">
            <summary>
                Returns LibLSLCC's default <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies" /> setup.
                Allows the use of custom <see cref="T:LibLSLCC.CodeValidator.ILSLBasicLibraryDataProvider"/>, <see cref="T:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener"/> and <see cref="T:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener"/>.
            </summary>
            <param name="libraryDataProvider">The library data provider to use.</param>
            <param name="errorListener">The syntax error listener to use.</param>
            <param name="warningListener">The syntax warning listener to use.</param>
            <returns>LibLSLCC's default <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies" /> setup</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies.Default(LibLSLCC.CodeValidator.ILSLBasicLibraryDataProvider)">
            <summary>
                Returns LibLSLCC's default <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies" /> setup.
                Allows the use of custom <see cref="T:LibLSLCC.CodeValidator.ILSLBasicLibraryDataProvider"/>.
            </summary>
            <param name="libraryDataProvider">The library data provider to use.</param>
            <returns>LibLSLCC's default <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies" /> setup</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLDefaultExpressionValidator">
            <summary>
                The default expression validator can validate and return results for all possible binary operations, unary
                operations
                etc.. in standard LSL
                validations for expression types in lists/vectors/rotations and function call parameters match that of standard LSL
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultExpressionValidator.#ctor">
            <summary>
                Constructs the expression validator
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultExpressionValidator.ValidateReturnTypeMatch(LibLSLCC.CodeValidator.LSLType,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Validates that an expression of some type can be returned from a function given the
                functions return type.
            </summary>
            <param name="returnType">The return type of the function the expression is being returned from.</param>
            <param name="returnedExpression">The expression attempting to be returned.</param>
            <returns>True if the expression is allowed to be returned from the function given the expression type and return type.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultExpressionValidator.ValidateVectorContent(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Determines if an expression can be used to initialize a vector literal
            </summary>
            <param name="type">The type of expression that is attempting to be used.</param>
            <returns>True if the expression can be inside of a vector literal.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultExpressionValidator.ValidateRotationContent(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Determines if an expression can be used to initialize a rotation literal
            </summary>
            <param name="type">The type of expression that is attempting to be used.</param>
            <returns>True if the expression can be inside of a rotation literal.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultExpressionValidator.ValidateListContent(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Determines if an expression can be used to initialize a list literal
            </summary>
            <param name="type">The type of expression that is attempting to be used.</param>
            <returns>True if the expression can be inside of a list literal.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultExpressionValidator.ValidBooleanConditional(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Determines if an expression is valid inside of a boolean condition area, such as an if statement
                or other control statement including loops.
            </summary>
            <param name="type">The type of expression that is attempting to be used.</param>
            <returns>True if the expression can be used inside of boolean condition area.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultExpressionValidator.ValidateFunctionParameter(LibLSLCC.CodeValidator.LSLParameterSignature,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Validates that an expression can be passed into the parameter slot of a function.
                IE: That the passed expression matches up with or can be converted to the parameter type.
            </summary>
            <param name="parameterSignature">The parameter definition.</param>
            <param name="parameterExpressionPassed">The expression the user has attempting to pass into the parameter.</param>
            <returns><c>true</c> if <paramref name="parameterExpressionPassed"/> can be passed to the given parameter signature.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="parameterSignature"/> or <paramref name="parameterExpressionPassed"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultExpressionValidator.ValidatePostfixOperation(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode,LibLSLCC.CodeValidator.LSLPostfixOperationType)">
            <summary>
                Validates and returns the type resulting from a postfix operation.
            </summary>
            <param name="left">The expression to preform the postfix operation on.</param>
            <param name="operation">The postfix operation preformed.</param>
            <returns>An <see cref="T:LibLSLCC.CodeValidator.LSLExpressionValidatorResult" /> object</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="left"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultExpressionValidator.ValidatePrefixOperation(LibLSLCC.CodeValidator.LSLPrefixOperationType,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Validates and returns the type resulting from a prefix operation.
            </summary>
            <param name="right">The expression to preform the prefix operation on.</param>
            <param name="operation">The prefix operation preformed.</param>
            <returns>An <see cref="T:LibLSLCC.CodeValidator.LSLExpressionValidatorResult" /> object</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="right"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultExpressionValidator.ValidateCastOperation(LibLSLCC.CodeValidator.LSLType,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Validates and returns the type resulting from a cast operation.
            </summary>
            <param name="castedExpression">The expression to preform the cast on.</param>
            <param name="castTo">The type that is being casted to.</param>
            <returns>An <see cref="T:LibLSLCC.CodeValidator.LSLExpressionValidatorResult" /> object</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="castedExpression"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultExpressionValidator.ValidateBinaryOperation(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode,LibLSLCC.CodeValidator.LSLBinaryOperationType,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Validates and returns the type resulting from a binary operation.
            </summary>
            <param name="left">The expression to on the left of the binary operation.</param>
            <param name="operation">The binary operation to preform.</param>
            <param name="right">The expression to on the right of the binary operation.</param>
            <returns>An <see cref="T:LibLSLCC.CodeValidator.LSLExpressionValidatorResult" /> object</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="left"/> or <paramref name="right"/> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLLiteralOverflowType">
            <summary>
            Represents the type of overflow/underflow that can occur when defining a integer/hex literal.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLLiteralOverflowType.None">
            <summary>
            No overflow/underflow.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLLiteralOverflowType.Overflow">
            <summary>
            Overflow.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLLiteralOverflowType.Underflow">
            <summary>
            Underflow.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLLiteralNodeExtensions">
            <summary>
                Extensions for LSL literal nodes.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLLiteralNodeExtensions.CheckForOverflow(LibLSLCC.CodeValidator.ILSLIntegerLiteralNode)">
            <summary>
                Determines whether the integer literal node is a literal value that overflows/underflows a 32 bit integer. <para/>
                Whether or not the node is negated is determined with <see cref="M:LibLSLCC.CodeValidator.LSLExprNodeExtensions.IsNegated(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)"/>.
            </summary>
            <param name="node">The integer literal node to test.</param>
            <returns><see cref="T:LibLSLCC.CodeValidator.LSLLiteralOverflowType"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="node"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLLiteralNodeExtensions.CheckForOverflow(LibLSLCC.CodeValidator.ILSLFloatLiteralNode)">
            <summary>
                Determines whether the float literal node is a literal value that overflows/underflows a 32 bit float.
            </summary>
            <param name="node">The float literal node to test.</param>
            <returns><see cref="T:LibLSLCC.CodeValidator.LSLLiteralOverflowType"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="node"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLLiteralNodeExtensions.CheckForOverflow(LibLSLCC.CodeValidator.ILSLIntegerLiteralNode,System.Boolean)">
            <summary>
                Determines whether the integer literal node is a literal value that overflows/underflows a 32 bit integer.
            </summary>
            <param name="node">The integer literal node to test.</param>
            <param name="negated">Whether or not the node is negated.</param>
            <returns><see cref="T:LibLSLCC.CodeValidator.LSLLiteralOverflowType"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="node"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLLiteralNodeExtensions.CheckForOverflow(LibLSLCC.CodeValidator.ILSLHexLiteralNode)">
            <summary>
                Determines whether the hex literal node is a literal value that overflows/underflows a 32 bit integer.
            </summary>
            <param name="node">The integer hex node to test.</param>
            <returns><see cref="T:LibLSLCC.CodeValidator.LSLLiteralOverflowType"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="node"/> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLExpressionListType">
            <summary>
                Represents the different types of expression lists that an <see cref="T:LibLSLCC.CodeValidator.ILSLExpressionListNode" /> can represent.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionListType.ListInitializer">
            <summary>
                The expression list is a list literal initializer.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionListType.UserFunctionCallParameters">
            <summary>
                The expression list represents the parameters used to call a user defined function.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionListType.LibraryFunctionCallParameters">
            <summary>
                The expression list represents the parameters used to call a library defined function.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionListType.ForLoopAfterthoughts">
            <summary>
                The expression list represents the expression list used in a for-loops afterthoughts clause.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionListType.ForLoopInitExpressions">
            <summary>
                The expression list represents the expression list used in a for-loops initialization clause.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLParameterListType">
            <summary>
                Represents a parameter list type of a <see cref="T:LibLSLCC.CodeValidator.ILSLParameterListNode" />
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLParameterListType.FunctionParameters">
            <summary>
                Parameter list belongs to a function declaration.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLParameterListType.EventParameters">
            <summary>
                Parameter list belongs to an event handler.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLBasicLibraryDataProvider">
            <summary>
                A minimal interface for providing data about what exists in the standard LSL library.
                Used primarily by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />.
            </summary>
            <seealso cref="T:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies" />
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLBasicLibraryDataProvider.EventHandlerExist(System.String)">
            <summary>
                Return true if an event handler with the given name exists in the default library.
            </summary>
            <param name="name">Name of the event handler.</param>
            <returns>True if the event handler with given name exists.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLBasicLibraryDataProvider.GetEventHandlerSignature(System.String)">
            <summary>
                Return an <see cref="T:LibLSLCC.LibraryData.LSLLibraryEventSignature" /> object describing an event handler signature;
                if the event handler with the given name exists, otherwise null.
            </summary>
            <param name="name">Name of the event handler</param>
            <returns>
                An <see cref="T:LibLSLCC.LibraryData.LSLLibraryEventSignature" /> object describing the given event handlers signature,
                or null if the event handler does not exist.
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLBasicLibraryDataProvider.LibraryFunctionExist(System.String)">
            <summary>
                Return true if a library function with the given name exists.
            </summary>
            <param name="name">Name of the library function.</param>
            <returns>True if the library function with given name exists.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLBasicLibraryDataProvider.GetLibraryFunctionSignatures(System.String)">
            <summary>
                Return an <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" /> list with the overload signatures of a function with the given name.
                If the function does not exist, null is returned.  If the function exist but is not overloaded only a single item
                will be returned.
            </summary>
            <param name="name">Name of the library function.</param>
            <returns>
                An <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" /> list object describing the given library functions signatures,
                or null if the library function does not exist.
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLBasicLibraryDataProvider.GetLibraryFunctionSignature(LibLSLCC.CodeValidator.ILSLFunctionSignature)">
            <summary>
                Return a <see cref="T:LibLSLCC.LibraryData.LSLLibraryFunctionSignature" /> from this object where
                <see cref="M:LibLSLCC.CodeValidator.ILSLFunctionSignature.SignatureEquivalent(LibLSLCC.CodeValidator.ILSLFunctionSignature)" /> is true for the given <see cref="T:LibLSLCC.CodeValidator.ILSLFunctionSignature" />,
                or null if no such <see cref="T:LibLSLCC.LibraryData.LSLLibraryFunctionSignature" /> exists in this provider.
            </summary>
            <remarks>
                see: <see cref="M:LibLSLCC.CodeValidator.LSLFunctionSignature.SignatureEquivalent(LibLSLCC.CodeValidator.ILSLFunctionSignature)" />
            </remarks>
            <param name="signatureToTest">The signature to use as search criteria.</param>
            <returns>
                An <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" /> which has the same signature of signatureToTest, or null if none exist.
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLBasicLibraryDataProvider.LibraryConstantExist(System.String)">
            <summary>
                Return true if a library constant with the given name exists.
            </summary>
            <param name="name">Name of the library constant.</param>
            <returns>True if a library constant with the given name exists.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLBasicLibraryDataProvider.GetLibraryConstantSignature(System.String)">
            <summary>
                Return an <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" /> object describing the signature of a library constant
            </summary>
            <param name="name">Name of the library constant</param>
            <returns>
                An <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" /> object describing the given constants signature,
                or null if the constant is not defined
            </returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLConstantSignature">
            <summary>
            Read only interface for <see cref="T:LibLSLCC.CodeValidator.LSLConstantSignature"/>.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLConstantSignature.SignatureString">
            <summary>
                Returns a formated signature string for the constant, in the form:  <see cref="P:LibLSLCC.CodeValidator.ILSLConstantSignature.Name"/> = <see cref="P:LibLSLCC.CodeValidator.ILSLConstantSignature.ValueStringAsCodeLiteral"/>
                Without a trailing semi-colon character.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLConstantSignature.Type">
            <summary>
                The <see cref="T:LibLSLCC.CodeValidator.LSLType" /> that the library constant is defined with.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLConstantSignature.Name">
            <summary>
                The name of the library constant, must abide by LSL symbol naming rules or an exception will be thrown.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLConstantSignature.ValueString">
            <summary>
                The value string for the library constant.
            </summary>
            <value>
                The value string.
            </value>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLConstantSignature.ValueStringAsCodeLiteral">
            <summary>
                Returns a string which represents what this Constant would look like
                if it were expanded into an LSL code literal.  This takes the Type and contents
                of <see cref="P:LibLSLCC.CodeValidator.ILSLConstantSignature.ValueString"/> into account.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLConstantSignature.ToString">
            <summary>
                Delegates to the <see cref="P:LibLSLCC.CodeValidator.ILSLConstantSignature.SignatureString"/> Property.
            </summary>
            <returns>
                The <see cref="P:LibLSLCC.CodeValidator.ILSLConstantSignature.SignatureString"/> Property.
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLConstantSignature.GetHashCode">
            <summary>
                Returns the hash code of the <see cref="T:LibLSLCC.CodeValidator.ILSLConstantSignature"/> object.  <para/>
                The <see cref="P:LibLSLCC.CodeValidator.ILSLConstantSignature.Type"/> and <see cref="P:LibLSLCC.CodeValidator.ILSLConstantSignature.Name"/> properties are used to generate the hash code.
            </summary>
            <returns>The generated hash code.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLConstantSignature.Equals(System.Object)">
            <summary>
                Determines whether the Type and Name properties of another <see cref="T:LibLSLCC.CodeValidator.ILSLConstantSignature"/> equal the Type and Name
                properties of this object. <para/>
                If the passed object is not an <see cref="T:LibLSLCC.CodeValidator.ILSLConstantSignature"/> object then the result will always be false.
            </summary>
            <param name="obj">The object to compare this object with.</param>
            <returns>
                True if the object is an <see cref="T:LibLSLCC.CodeValidator.ILSLConstantSignature"/> object and the Name and Type properties of both objects
                are equal to each other.
            </returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLConstantSignature">
            <summary>
                Represents the basic signature of an LSL constant.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantSignature.#ctor">
            <summary>
                construct a completely empty signature, without a name, type or valuestring.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantSignature.#ctor(LibLSLCC.CodeValidator.ILSLConstantSignature)">
            <summary>
                Construct the <see cref="T:LibLSLCC.CodeValidator.ILSLConstantSignature" /> by cloning another one.
            </summary>
            <param name="other">The other <see cref="T:LibLSLCC.CodeValidator.ILSLConstantSignature" />.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantSignature.#ctor(LibLSLCC.CodeValidator.LSLType,System.String)">
            <summary>
                Construct the LSLLibraryConstantSignature from a given <see cref="T:LibLSLCC.CodeValidator.LSLType" /> and constant name.
                <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" /> is given the default
                value for the given <see cref="T:LibLSLCC.CodeValidator.LSLType" /> passed in <paramref name="type" />
            </summary>
            <param name="type">The constant type.</param>
            <param name="name">The constant name.</param>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException">If <paramref name="name" /> is an invalid LSL ID token.</exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidConstantTypeException">
                if <paramref name="type" /> is
                <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" />.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantSignature.#ctor(LibLSLCC.CodeValidator.LSLType,System.String,System.String)">
            <summary>
                Construct the LSLLibraryConstantSignature from a given <see cref="T:LibLSLCC.CodeValidator.LSLType" />, constant name, and Value string.
            </summary>
            <param name="type">The constant type.</param>
            <param name="name">The constant name.</param>
            <param name="valueString">
                The string value that represents the constant.  Must be appropriate for
                <paramref name="type" />.
            </param>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException">If <paramref name="name" /> is an invalid LSL ID token.</exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidConstantTypeException">
                if <paramref name="type" /> is
                <see cref="T:LibLSLCC.CodeValidator.LSLType" />.
            </exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidConstantValueStringException">
                If <paramref name="valueString" /> is an invalid value for a float and <paramref name="type" /> is set to
                <see cref="T:LibLSLCC.CodeValidator.LSLType" />
                or
                If <paramref name="valueString" /> is an invalid value for an integer and <paramref name="type" /> is set to
                <see cref="T:LibLSLCC.CodeValidator.LSLType" />
                or
                If <paramref name="valueString" /> is an invalid value for a vector and <paramref name="type" /> is set to
                <see cref="T:LibLSLCC.CodeValidator.LSLType" />
                or
                If <paramref name="valueString" /> is an invalid value for a rotation and <paramref name="type" /> is set to
                <see cref="T:LibLSLCC.CodeValidator.LSLType" />
            </exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLConstantSignature.SignatureString">
            <summary>
                Returns a formated signature string for the constant, in the form:  NAME = ValueStringAsCodeLiteral
                Without a trailing semi-colon character.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type">
            <summary>
                The <see cref="T:LibLSLCC.CodeValidator.LSLType" /> that the library constant is defined with.
            </summary>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidConstantTypeException" accessor="set">
                if <paramref name="value" /> is
                <see cref="T:LibLSLCC.CodeValidator.LSLType" />.
            </exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLConstantSignature.Name">
            <summary>
                The name of the library constant, must abide by LSL symbol naming rules or an exception will be thrown.
            </summary>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException" accessor="set">If <paramref name="value" /> is an invalid LSL ID token.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString">
            <summary>
                The value string of the library constant, you must set <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" /> first to a value that is not
                <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" /> or an exception will be thrown.
            </summary>
            <value>
                The value string.
            </value>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidConstantValueStringException" accessor="set">
                If the Value is an invalid value for a float and <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" /> is set to <see cref="F:LibLSLCC.CodeValidator.LSLType.Float" />
                or
                If the Value is an invalid value for an integer and <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" /> is set to <see cref="F:LibLSLCC.CodeValidator.LSLType.Integer" />
                or
                If the Value is an invalid value for a vector and <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" /> is set to <see cref="F:LibLSLCC.CodeValidator.LSLType.Vector" />
                or
                If the Value is an invalid value for a rotation and <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" /> is set to <see cref="F:LibLSLCC.CodeValidator.LSLType.Rotation" />
            </exception>
            <exception cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" accessor="set">
                If you try to set this value and
                <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" /> is equal to <see cref="T:LibLSLCC.CodeValidator.LSLType" />.
            </exception>
            <remarks>
                Only integral or hexadecimal values are allowed when <see cref="F:LibLSLCC.CodeValidator.LSLType.Integer" /> is set to
                <see cref="T:LibLSLCC.CodeValidator.LSLType" />
                Only floating point or hexadecimal values are allowed when <see cref="F:LibLSLCC.CodeValidator.LSLType.Float" /> is set to
                <see cref="T:LibLSLCC.CodeValidator.LSLType" />
                The enclosing less than and greater than symbols will be removed when <see cref="F:LibLSLCC.CodeValidator.LSLType.Vector" /> is set to
                <see cref="T:LibLSLCC.CodeValidator.LSLType" /> or <see cref="T:LibLSLCC.CodeValidator.LSLType" />.
            </remarks>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueStringAsCodeLiteral">
            <summary>
                Returns a string which represents what this Constant would look like
                if it were expanded into an LSL code literal.  This takes the Type and contents
                of ValueString into account.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantSignature.ToString">
            <summary>
                Delegates to the SignatureString Property.
            </summary>
            <returns>
                The SignatureString Property.
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantSignature.GetHashCode">
            <summary>
                Returns the hash code of the <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" /> object.
                <para />
                The <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" /> and <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Name" /> properties are used to generate the hash code.
            </summary>
            <returns>The generated hash code.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantSignature.Equals(System.Object)">
            <summary>
                Determines whether the Type and Name properties of another <see cref="T:LibLSLCC.CodeValidator.ILSLConstantSignature" /> equal the Type and
                Name
                properties of this object.
                <para />
                If the passed object is not an <see cref="T:LibLSLCC.CodeValidator.ILSLConstantSignature" /> object then the result will always be false.
            </summary>
            <param name="obj">The object to compare this object with.</param>
            <returns>
                True if the object is an <see cref="T:LibLSLCC.CodeValidator.ILSLConstantSignature" /> object and the Name and Type properties of both
                objects
                are equal to each other.
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantSignature.ValidateValueString(LibLSLCC.CodeValidator.LSLType,System.String)">
            <summary>
                Validates the format of a string is acceptable for assigning to <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" /> when <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" />
                is equal to the <see cref="T:LibLSLCC.CodeValidator.LSLType" /> passed in <paramref name="type" />.
            </summary>
            <param name="type">The <see cref="T:LibLSLCC.CodeValidator.LSLType" /> <paramref name="valueString" /> must be valid for.</param>
            <param name="valueString">The value string to validate.</param>
            <returns>
                <c>true</c> if <paramref name="valueString" /> can successfully be parsed for the given <see cref="T:LibLSLCC.CodeValidator.LSLType" />
                .
            </returns>
            <exception cref="T:System.ArgumentException">if <paramref name="type" /> is <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" />.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantSignature.TryParseValueString(LibLSLCC.CodeValidator.LSLType,System.String,System.String@)">
            <summary>
                Validates the format of a string is acceptable for assigning to <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" /> when <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" />
                is equal to the <see cref="T:LibLSLCC.CodeValidator.LSLType" /> passed in <paramref name="type" />.
            </summary>
            <param name="type">The <see cref="T:LibLSLCC.CodeValidator.LSLType" /> <paramref name="valueString" /> must be valid for.</param>
            <param name="valueString">The value string to validate.</param>
            <param name="formated">The re-formated version of <paramref name="valueString" /> if the parse was successful.</param>
            <returns>
                <c>true</c> if <paramref name="valueString" /> can successfully be parsed for the given <see cref="T:LibLSLCC.CodeValidator.LSLType" />
                .
            </returns>
            <exception cref="T:System.ArgumentException">if <paramref name="type" /> is <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" />.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantSignature.TryParseFloatValueString(System.String,System.String@,System.String@)">
            <summary>
                Validates the format of a string is acceptable for assigning to <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" /> when <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" />
                is equal to <see cref="F:LibLSLCC.CodeValidator.LSLType.Float" />.
            </summary>
            <param name="value">The value string to validate.</param>
            <param name="valueString">The re-formated version of <paramref name="valueString" /> if the parse was successful.</param>
            <param name="errMessage">An error message describing why the parse failed if this function returns <c>false</c>.</param>
            <returns><c>true</c> if <paramref name="valueString" /> can successfully be parsed for <see cref="F:LibLSLCC.CodeValidator.LSLType.Float" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantSignature.TryParseFloatValueString(System.String,System.String@)">
            <summary>
                Validates the format of a string is acceptable for assigning to <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" /> when <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" />
                is equal to <see cref="F:LibLSLCC.CodeValidator.LSLType.Float" />.
            </summary>
            <param name="value">The value string to validate.</param>
            <param name="valueString">The re-formated version of <paramref name="valueString" /> if the parse was successful.</param>
            <returns><c>true</c> if <paramref name="valueString" /> can successfully be parsed for <see cref="F:LibLSLCC.CodeValidator.LSLType.Float" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantSignature.TryParseIntegerValueString(System.String,System.String@,System.String@)">
            <summary>
                Validates the format of a string is acceptable for assigning to <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" /> when <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" />
                is equal to <see cref="F:LibLSLCC.CodeValidator.LSLType.String" />.
            </summary>
            <param name="value">The value string to validate.</param>
            <param name="valueString">The re-formated version of <paramref name="valueString" /> if the parse was successful.</param>
            <param name="errMessage">An error message describing why the parse failed if this function returns <c>false</c>.</param>
            <returns><c>true</c> if <paramref name="valueString" /> can successfully be parsed for <see cref="F:LibLSLCC.CodeValidator.LSLType.String" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantSignature.TryParseIntegerValueString(System.String,System.String@)">
            <summary>
                Validates the format of a string is acceptable for assigning to <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" /> when <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" />
                is equal to <see cref="F:LibLSLCC.CodeValidator.LSLType.String" />.
            </summary>
            <param name="value">The value string to validate.</param>
            <param name="valueString">The re-formated version of <paramref name="valueString" /> if the parse was successful.</param>
            <returns><c>true</c> if <paramref name="valueString" /> can successfully be parsed for <see cref="F:LibLSLCC.CodeValidator.LSLType.String" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantSignature.TryParseListValueString(System.String,System.String@,System.String@)">
            <summary>
                Validates the format of a string is acceptable for assigning to <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" /> when <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" />
                is equal to <see cref="F:LibLSLCC.CodeValidator.LSLType.List" />.
            </summary>
            <param name="value">The value string to validate.</param>
            <param name="valueString">The re-formated version of <paramref name="valueString" /> if the parse was successful.</param>
            <param name="errMessage">An error message describing why the parse failed if this function returns <c>false</c>.</param>
            <returns><c>true</c> if <paramref name="valueString" /> can successfully be parsed for <see cref="F:LibLSLCC.CodeValidator.LSLType.List" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantSignature.TryParseListValueString(System.String,System.String@)">
            <summary>
                Validates the format of a string is acceptable for assigning to <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" /> when <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" />
                is equal to <see cref="F:LibLSLCC.CodeValidator.LSLType.List" />.
            </summary>
            <param name="value">The value string to validate.</param>
            <param name="valueString">The re-formated version of <paramref name="valueString" /> if the parse was successful.</param>
            <returns><c>true</c> if <paramref name="valueString" /> can successfully be parsed for <see cref="F:LibLSLCC.CodeValidator.LSLType.List" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantSignature.TryParseRotationValueString(System.String,System.String@,System.String@)">
            <summary>
                Validates the format of a string is acceptable for assigning to <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" /> when <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" />
                is equal to <see cref="F:LibLSLCC.CodeValidator.LSLType.Rotation" />.
            </summary>
            <param name="value">The value string to validate.</param>
            <param name="valueString">The re-formated version of <paramref name="valueString" /> if the parse was successful.</param>
            <param name="errMessage">An error message describing why the parse failed if this function returns <c>false</c>.</param>
            <returns><c>true</c> if <paramref name="valueString" /> can successfully be parsed for <see cref="F:LibLSLCC.CodeValidator.LSLType.Rotation" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantSignature.TryParseRotationValueString(System.String,System.String@)">
            <summary>
                Validates the format of a string is acceptable for assigning to <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" /> when <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" />
                is equal to <see cref="F:LibLSLCC.CodeValidator.LSLType.Rotation" />.
            </summary>
            <param name="value">The value string to validate.</param>
            <param name="valueString">The re-formated version of <paramref name="valueString" /> if the parse was successful.</param>
            <returns><c>true</c> if <paramref name="valueString" /> can successfully be parsed for <see cref="F:LibLSLCC.CodeValidator.LSLType.Rotation" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantSignature.TryParseVectorValueString(System.String,System.String@,System.String@)">
            <summary>
                Validates the format of a string is acceptable for assigning to <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" /> when <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" />
                is equal to <see cref="F:LibLSLCC.CodeValidator.LSLType.Vector" />.
            </summary>
            <param name="value">The value string to validate.</param>
            <param name="valueString">The re-formated version of <paramref name="valueString" /> if the parse was successful.</param>
            <param name="errMessage">An error message describing why the parse failed if this function returns <c>false</c>.</param>
            <returns><c>true</c> if <paramref name="valueString" /> can successfully be parsed for <see cref="F:LibLSLCC.CodeValidator.LSLType.Vector" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantSignature.TryParseVectorValueString(System.String,System.String@)">
            <summary>
                Validates the format of a string is acceptable for assigning to <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" /> when <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" />
                is equal to <see cref="F:LibLSLCC.CodeValidator.LSLType.Vector" />.
            </summary>
            <param name="value">The value string to validate.</param>
            <param name="valueString">The re-formated version of <paramref name="valueString" /> if the parse was successful.</param>
            <returns><c>true</c> if <paramref name="valueString" /> can successfully be parsed for <see cref="F:LibLSLCC.CodeValidator.LSLType.Vector" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLInvalidConstantValueStringException">
            <summary>
                Thrown by functions that deal with subset names, when an invalid format for a subset name is encountered
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLInvalidConstantValueStringException.#ctor">
            <summary>
                Default constructor.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLInvalidConstantValueStringException.#ctor(System.String)">
            <summary>
                Construct with message.
            </summary>
            <param name="message">Exception message.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLInvalidConstantValueStringException.#ctor(System.String,System.Exception)">
            <summary>
                Construct with message and inner exception.
            </summary>
            <param name="message">Exception message.</param>
            <param name="inner">Inner exception.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLInvalidConstantValueStringException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Serializable constructor.
            </summary>
            <param name="info">SerializationInfo.</param>
            <param name="context">StreamingContext.</param>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLInvalidConstantTypeException">
            <summary>
                An exception thrown by <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" /> when it is set to
                <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" />.
                It is also thrown by <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" /> if you try to set the property when
                <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" /> is set to <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" />.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLInvalidConstantTypeException.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.CodeValidator.LSLInvalidConstantTypeException" /> class.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLInvalidConstantTypeException.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.CodeValidator.LSLInvalidConstantTypeException" /> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLInvalidConstantTypeException.#ctor(System.String,System.Exception)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.CodeValidator.LSLInvalidConstantTypeException" /> class.
            </summary>
            <param name="message">The message.</param>
            <param name="inner">The inner.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLInvalidConstantTypeException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.CodeValidator.LSLInvalidConstantTypeException" /> class.
            </summary>
            <param name="info">
                The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object
                data about the exception being thrown.
            </param>
            <param name="context">
                The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual
                information about the source or destination.
            </param>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLSyntaxListenerPriorityQueue">
            <summary>
                A proxy object for <see cref="T:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener" /> and <see cref="T:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener" /> that
                queue's/sorts syntax warnings/errors by their starting index in source code.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLSyntaxListenerPriorityQueue.#ctor(LibLSLCC.CodeValidator.ILSLSyntaxErrorListener,LibLSLCC.CodeValidator.ILSLSyntaxWarningListener)">
            <summary>
                Construct a <see cref="T:LibLSLCC.CodeValidator.LSLSyntaxListenerPriorityQueue" /> by wrapping another
                <see cref="T:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener" /> and <see cref="T:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener" />
            </summary>
            <param name="invokeErrorsOn">
                Syntax errors will be priority queued by their index in the source code and invoked on
                this object.
            </param>
            <param name="invokeWarningsOn">
                Syntax warnings will be priority queued by their index in the source code and invoked on
                this object.
            </param>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSyntaxListenerPriorityQueue.NumberOfSyntaxWarnings">
            <summary>
                Gets the number of syntax warnings that have been queued.
            </summary>
            <value>
                The number of syntax warnings queued.
            </value>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSyntaxListenerPriorityQueue.NumberOfSyntaxErrors">
            <summary>
                Gets the number of syntax errors that have been queued.
            </summary>
            <value>
                The number of syntax errors queued.
            </value>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSyntaxListenerPriorityQueue.SyntaxErrorListener">
            <summary>
                The syntax error listener that this object delegates to.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSyntaxListenerPriorityQueue.SyntaxWarningListener">
            <summary>
                The syntax warning listener that this object delegates to.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLSyntaxListenerPriorityQueue.InvokeQueuedErrors">
            <summary>
                Invoke all the queued errors on <see cref="P:LibLSLCC.CodeValidator.LSLSyntaxListenerPriorityQueue.SyntaxErrorListener" />
                so that the syntax errors are reported in order by their position in source code.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLSyntaxListenerPriorityQueue.InvokeQueuedWarnings">
            <summary>
                Invoke all the queued errors on <see cref="P:LibLSLCC.CodeValidator.LSLSyntaxListenerPriorityQueue.SyntaxWarningListener" />
                so that the syntax warnings are reported in order by their position in source code.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLSyntaxListenerPriorityQueue.InvokeQueuedActions">
            <summary>
                Invoke all the queued warnings and errors on <see cref="P:LibLSLCC.CodeValidator.LSLSyntaxListenerPriorityQueue.SyntaxErrorListener" /> and
                <see cref="P:LibLSLCC.CodeValidator.LSLSyntaxListenerPriorityQueue.SyntaxWarningListener" />
                so that the syntax warnings and errors are reported in order by their position in source code.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLCommentType">
            <summary>
                Represents a source code comment type.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLCommentType.Block">
            <summary>
                A Block comment.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLCommentType.SingleLine">
            <summary>
                A Single Line comment.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLConditionalStatementType">
            <summary>
                Represents different types of conditional/control statements
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLConditionalStatementType.If">
            <summary>
                An If statement.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLConditionalStatementType.ElseIf">
            <summary>
                An Else-If statement.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLConditionalStatementType.While">
            <summary>
                A While loop.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLConditionalStatementType.DoWhile">
            <summary>
                A Do-While loop.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLConditionalStatementType.For">
            <summary>
                A For loop.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException">
            <summary>
                Thrown when <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" />, <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" />,
                <see cref="T:LibLSLCC.CodeValidator.LSLEventSignature" /> or <see cref="T:LibLSLCC.CodeValidator.LSLParameterSignature" />
                have their Name set to a value that does not conform the LSL's symbol naming convention.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException.#ctor">
            <summary>
                Default constructor.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException.#ctor(System.String)">
            <summary>
                Construct with message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException.#ctor(System.String,System.Exception)">
            <summary>
                Construct with message and inner exception.
            </summary>
            <param name="message">Exception message.</param>
            <param name="innerException">Inner exception.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Serializable constructor.
            </summary>
            <param name="info">SerializationInfo.</param>
            <param name="context">StreamingContext.</param>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLCodeValidator">
            <summary>
                An interface for code validators.
            </summary>
            <seealso cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCodeValidator.HasSyntaxWarnings">
            <summary>
                Set to true if the last call to <see cref="M:LibLSLCC.CodeValidator.ILSLCodeValidator.Validate(System.IO.TextReader)"/> generated syntax warnings.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCodeValidator.HasSyntaxErrors">
            <summary>
                Set to <c>true</c> if the last call to <see cref="M:LibLSLCC.CodeValidator.ILSLCodeValidator.Validate(System.IO.TextReader)"/> generated syntax errors.
                <see cref="M:LibLSLCC.CodeValidator.ILSLCodeValidator.Validate(System.IO.TextReader)"/> will return <c>null</c> upon encountering syntax errors as well.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLCodeValidator.Validate(System.IO.TextReader)">
            <summary>
                Validates the code content of a TextReader and returns the top of the compilation unit syntax tree.
                If parsing resulted in syntax errors the result will be <c>null</c>.
            </summary>
            <param name="stream">The TextReader to parse code from.</param>
            <returns>Top level node of an LSL syntax tree.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLFunctionSignatureMatch">
            <summary>
                Represents the status of an attempted function signature match against parameter expressions
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionSignatureMatch.NotEnoughParameters">
            <summary>
                True if not enough parameter expressions were supplied to the function signature.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionSignatureMatch.ToManyParameters">
            <summary>
                True if to many parameter expressions were supplied to the function signature.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionSignatureMatch.TypeMismatchIndex">
            <summary>
                The index where there was a parameter mismatch if TypeMismatch is true, otherwise -1.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionSignatureMatch.TypeMismatch">
            <summary>
                True if a type mismatch between a passed expression and a defined parameter type occurred.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionSignatureMatch.Success">
            <summary>
                True if the function can successfully be compiled with the given parameter expressions.
                Equivalent to !NotEnoughParameters &amp;&amp; !ToManyParameters &amp;&amp; !TypeMismatch
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionSignatureMatch.ImproperParameterCount">
            <summary>
                True if either ToManyParameters or NotEnoughParameters are true
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLFunctionOverloadMatches`1">
            <summary>
                Represents the status of an attempted overload resolution match against parameter expressions.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionOverloadMatches`1.#ctor(LibLSLCC.Collections.IReadOnlyGenericArray{`0})">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.CodeValidator.LSLFunctionOverloadMatches`1" /> class with an
                <see cref="T:LibLSLCC.Collections.IReadOnlyGenericArray`1" /> containing signature matches.
            </summary>
            <param name="matches">The matches.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionOverloadMatches`1.#ctor(System.Collections.Generic.List{`0})">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.CodeValidator.LSLFunctionOverloadMatches`1" /> class with an <see cref="T:System.Collections.Generic.List`1" />
                containing signature matches, a wrapper is created around the list.
            </summary>
            <param name="matches">The matches.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionOverloadMatches`1.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.CodeValidator.LSLFunctionOverloadMatches`1" /> class with no signature matches at
                all.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionOverloadMatches`1.#ctor(`0)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.CodeValidator.LSLFunctionOverloadMatches`1" /> class with a single un-ambiguous
                signature match.
            </summary>
            <param name="match">The match.</param>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionOverloadMatches`1.Ambiguous">
            <summary>
                This is set to true if multiple overload matches were found given the expressions passed into the function
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionOverloadMatches`1.Matches">
            <summary>
                This is a list of all possible overload matches.  This will have more
                than one element when Ambiguous is set to true
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionOverloadMatches`1.MatchingOverload">
            <summary>
                If multiple matches were found (Ambiguous is set to true) then this will be <c>null</c>.
                This will also be <c>null</c> if no matches were found at all
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionOverloadMatches`1.Success">
            <summary>
                This returns true if there are no ambiguous matches, and a single overload match was found
                it is equivalent to: (!Ambiguous &amp;&amp; Matches.Count != 0)
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLFunctionSignatureMatcher">
            <summary>
                A tool for matching comparing <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" /> objects and preforming overload resolution across
                multiple <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" /> objects.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionSignatureMatcher.MatchOverloads``1(LibLSLCC.Collections.IReadOnlyGenericArray{``0},LibLSLCC.Collections.IReadOnlyGenericArray{LibLSLCC.CodeValidator.ILSLReadOnlyExprNode},LibLSLCC.CodeValidator.ILSLExpressionValidator)">
            <summary>
                Find a matching overload from a list of function signatures, given the parameter expressions. return null if none
                is found.
            </summary>
            <typeparam name="T">The type of <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature"/> derived object to preform matching against.</typeparam>
            <param name="expressionValidator">
                The expression validator, which is used to determine if an expression can be passed
                into a parameter of a certain type.
            </param>
            <param name="functionSignatures">The function signatures to search through.</param>
            <param name="expressionNodes">The expression nodes of the function parameters we want to pass and find an overload for.</param>
            <returns>A matching <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" /> overload or null.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionSignatureMatcher.MatchOverloads``1(LibLSLCC.Collections.IReadOnlyGenericArray{``0},LibLSLCC.Collections.IReadOnlyGenericArray{LibLSLCC.CodeValidator.ILSLReadOnlyExprNode},System.Func{LibLSLCC.CodeValidator.LSLParameterSignature,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode,System.Boolean})">
            <summary>
                Find a matching overload from a list of function signatures, given the parameter expressions. return null if none
                is found.
            </summary>
            <typeparam name="T">The type of <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature"/> derived object to preform matching against.</typeparam>
            <param name="typeComparer">
                A function used to compare an <see cref="T:LibLSLCC.CodeValidator.LSLParameterSignature" /> to another <see cref="T:LibLSLCC.CodeValidator.ILSLExprNode" /> to check for a
                match.
                Should return true if the <see cref="T:LibLSLCC.CodeValidator.ILSLExprNode" /> can be passed into the <see cref="T:LibLSLCC.CodeValidator.LSLParameterSignature" />.
            </param>
            <param name="functionSignatures">The function signatures to search through.</param>
            <param name="expressionNodes">The expression nodes of the function parameters we want to pass and find an overload for.</param>
            <returns>A matching <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" /> overload or null.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionSignatureMatcher.TryMatch(LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.Collections.IReadOnlyGenericArray{LibLSLCC.CodeValidator.ILSLReadOnlyExprNode},LibLSLCC.CodeValidator.ILSLExpressionValidator)">
            <summary>
                Check if a given function signature can be called with the given expressions as parameters
            </summary>
            <param name="expressionValidator">
                The expression validator, which is used to determine if an expression can be passed
                into a parameter of a certain type.
            </param>
            <param name="functionSignature">The function signature of the functions your passing the parameter expressions to.</param>
            <param name="expressions">The expressions we want to test against this function signatures defined parameters.</param>
            <returns>
                A <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignatureMatch"/> object containing information about how the parameters matched
                or did not match the call signature.
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionSignatureMatcher.SignaturesEquivalent(LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLFunctionSignature)">
            <summary>
                Determines if two function signatures match exactly (including return type), parameter names do not matter but
                parameter types and variadic parameter status do.
            </summary>
            <param name="left">The first function signature in the comparison.</param>
            <param name="right">The other function signature in the comparison.</param>
            <returns>True if the two signatures are identical</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="left"/> or <paramref name="right"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionSignatureMatcher.DefinitionIsDuplicate(LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLFunctionSignature)">
            <summary>
                Determines if a two LSLFunctionSignatures are duplicate definitions of each other.
                <para>
                    The logic behind this is a bit different than <see cref="M:LibLSLCC.CodeValidator.LSLFunctionSignatureMatcher.SignaturesEquivalent(LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLFunctionSignature)" />.
                    If the given function signatures have the same name, differing return types and no parameters; than this
                    function will return true
                    and <see cref="M:LibLSLCC.CodeValidator.LSLFunctionSignatureMatcher.SignaturesEquivalent(LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLFunctionSignature)" /> will not.
                    If the given function signatures have differing return types, and the exact same parameter types/count; than
                    this function will return true
                    and <see cref="M:LibLSLCC.CodeValidator.LSLFunctionSignatureMatcher.SignaturesEquivalent(LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLFunctionSignature)" /> will not.
                </para>
            </summary>
            <param name="left">The first function signature in the comparison.</param>
            <param name="right">The other function signature in the comparison.</param>
            <returns>
                True if the two signatures are duplicate definitions of each other, taking static overloading ambiguities into
                account.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="left"/> or <paramref name="right"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionSignatureMatcher.TryMatch(LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.Collections.IReadOnlyGenericArray{LibLSLCC.CodeValidator.ILSLReadOnlyExprNode},System.Func{LibLSLCC.CodeValidator.LSLParameterSignature,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode,System.Boolean})">
            <summary>
                Check if a given function signature can be called with the given expressions as parameters
            </summary>
            <param name="typeComparer">A function which should return true if two types match</param>
            <param name="functionSignature">The function signature of the functions your passing the parameter expressions to.</param>
            <param name="expressions">The expressions we want to test against this function signatures defined parameters.</param>
            <returns>
                A LSLFunctionCallSignatureMatcher.MatchStatus object containing information about how the parameters matched
                or did not match the call signature.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="functionSignature"/> or <paramref name="expressions"/> or <paramref name="typeComparer"/> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLExprNodeExtensions">
            <summary>
                Various extensions for dealing with syntax tree node interfaces.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExprNodeExtensions.IsNegated(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
            Determine if a given expressions parent node is a prefix negate operator.
            </summary>
            <param name="node">The <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlyExprNode"/> to test.</param>
            <returns><c>true</c> if <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.Parent"/> is an <see cref="T:LibLSLCC.CodeValidator.ILSLPrefixOperationNode"/> where <see cref="P:LibLSLCC.CodeValidator.ILSLPrefixOperationNode.Operation"/> equals <see cref="F:LibLSLCC.CodeValidator.LSLPrefixOperationType.Negate"/>.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExprNodeExtensions.IsLiteral(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Determines if the expression node represents a code literal.  Such as a string, vector, rotation or list literal.
            </summary>
            <param name="node">The expression node to test.</param>
            <returns>True if the expression node represents a code literal.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="node"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExprNodeExtensions.IsCompoundExpression(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Determines if the expression node represents a compound expression.
                Compound expressions are:
                Binary Expressions
                Parenthesized Expressions
                Postfix Expressions
                Prefix Expressions
                Typecast Expressions
            </summary>
            <param name="node">The expression node to test.</param>
            <returns>True if the expression node represents a compound expression.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="node"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExprNodeExtensions.IsFunctionCall(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Determines if an expression node represents a function call to a user defined or library defined function.
            </summary>
            <param name="node">The expression node to test.</param>
            <returns>True if the expression node represents a function call to either a user defined or library defined function.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="node"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExprNodeExtensions.IsLibraryFunctionCall(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Determines if an expression node represents a function call to a library defined function.
            </summary>
            <param name="node">The expression node to test.</param>
            <returns>True if the expression node represents a function call to a library defined function.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="node"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExprNodeExtensions.IsUserFunctionCall(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Determines if an expression node represents a function call to a user defined function.
            </summary>
            <param name="node">The expression node to test.</param>
            <returns>True if the expression node represents a function call to a user defined function.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="node"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExprNodeExtensions.IsVariable(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Determines if an expression node represents a reference to a global or local variable.
            </summary>
            <param name="node">The expression node to test.</param>
            <returns>True if the expression node represents a reference to either a global or local variable.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="node"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExprNodeExtensions.IsVectorOrRotationComponent(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Determines whether the expression is a reference to a vector or rotation component, using the dot operator.
            </summary>
            <param name="node">The expression node to test.</param>
            <returns>
                True if the expression node represents a reference to a vector or rotation variable component via the dot
                operator.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="node"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExprNodeExtensions.IsModifiableLeftValue(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Determines whether the given expression is a modifiable L-Value.
                This is true if its a global variable, local variable, local parameter or a reference to a vector component via the
                dot operator.
            </summary>
            <param name="node">The expression node to test.</param>
            <returns>True if the expression is a modifiable L-Value.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExprNodeExtensions.IsVariableOrParameter(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Determines if an expression node represents a reference to a global/local variable or parameter reference.
            </summary>
            <param name="node">The expression node to test.</param>
            <returns>True if the expression node represents a reference to either a global/local variable or parameter reference.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="node"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExprNodeExtensions.IsLocalVariable(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Determines if an expression node represents a reference to a local variable.
            </summary>
            <param name="node">The expression node to test.</param>
            <returns>True if the expression node represents a reference to a local variable.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="node"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExprNodeExtensions.IsLocalParameter(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Determines if an expression node represents a reference to a local parameter.
            </summary>
            <param name="node">The expression node to test.</param>
            <returns>True if the expression node represents a reference to a local parameter.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="node"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExprNodeExtensions.IsGlobalVariable(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Determines if an expression node represents a reference to a global variable.
            </summary>
            <param name="node">The expression node to test.</param>
            <returns>True if the expression node represents a reference to a global variable.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="node"/> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLBinaryOperationSignature">
            <summary>
                Represents the signature of a binary operation. Includes the types on either side of the expression, and the
                operation type.
            </summary>
            <remarks>Immutable.</remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLBinaryOperationSignature.#ctor(System.String,LibLSLCC.CodeValidator.LSLType,LibLSLCC.CodeValidator.LSLType,LibLSLCC.CodeValidator.LSLType)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationSignature" /> from the source code string representation of the binary
                operation,
                the operations return type, the return type of the expression on the left and the return type of the expression on
                the right.
            </summary>
            <param name="operation">Source code string representation of the operator.</param>
            <param name="returns">The return type of the binary operation.</param>
            <param name="left">The return type of the expression on the left side of the binary operation.</param>
            <param name="right">The return type of the expression on the right side of the binary operation.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLBinaryOperationSignature.#ctor(LibLSLCC.CodeValidator.LSLBinaryOperationType,LibLSLCC.CodeValidator.LSLType,LibLSLCC.CodeValidator.LSLType,LibLSLCC.CodeValidator.LSLType)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationSignature" /> from an <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationType" />, the
                operations return type,
                the return type of the expression on the left and the return type of the expression on the right.
            </summary>
            <param name="operation">The <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationType" /> of the binary operation signature.</param>
            <param name="returns">The return type of the binary operation.</param>
            <param name="left">The return type of the expression on the left side of the binary operation.</param>
            <param name="right">The return type of the expression on the right side of the binary operation.</param>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLBinaryOperationSignature.Returns">
            <summary>
                The return type of the binary operation.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLBinaryOperationSignature.Left">
            <summary>
                The return type of the expression on the left side of the binary operation.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLBinaryOperationSignature.Right">
            <summary>
                The return type of the expression on the right side of the binary operation.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLBinaryOperationSignature.Operation">
            <summary>
                The <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationType" /> describing the operator used in the binary expression.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLBinaryOperationSignature.GetHashCode">
            <summary>
                Gets a hash code for the <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationSignature" /> object derived from the properties: Returns,
                Left, Right and Operation.
            </summary>
            <returns>The hash code for this object.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLBinaryOperationSignature.Equals(System.Object)">
            <summary>
                Compares this <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationSignature" /> to another <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationSignature" /> or
                object.
                The properties: Returns, Left, Right and Operation are compared for equality and if they are all equal True is
                returned, otherwise False.
                If 'obj' is not an <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationSignature" />, then false is always returned.
            </summary>
            <param name="obj">The other <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationSignature" /> to compare this one to.</param>
            <returns>
                True if 'obj' is an <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationSignature" /> object, and the properties: Returns, Left,
                Right and Operation are equal in both of them.
            </returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLExpressionValidatorResult">
            <summary>
                Represents the result of an expression/type validation preformed by an ILSLExpressionValidator object
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.Error">
            <summary>
                Represents a validation error.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.List">
            <summary>
                Represents a list return type for an expression validation.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.String">
            <summary>
                Represents a string return type for an expression validation.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.Vector">
            <summary>
                Represents a vector return type for an expression validation.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.Rotation">
            <summary>
                Represents a rotation return type for an expression validation.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.Key">
            <summary>
                Represents a key return type for an expression validation.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.Integer">
            <summary>
                Represents an integer return type for an expression validation.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.Float">
            <summary>
                Represents a float return type for an expression validation.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.#ctor(LibLSLCC.CodeValidator.LSLType,System.Boolean)">
            <summary>
                Constructs an expression validation result.
            </summary>
            <param name="resultType">The return type of the expression that was validated.</param>
            <param name="isValid">True specifies that the validation was a success, false specifies that there was an error.</param>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.ResultType">
            <summary>
                Contains the resulting type of an expression validation.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.IsValid">
            <summary>
                True if the expression passed validation, false if it did not.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.Equals(LibLSLCC.CodeValidator.LSLExpressionValidatorResult)">
            <summary>
                Equates <see cref="T:LibLSLCC.CodeValidator.LSLExpressionValidatorResult" /> objects using equality between their ResultType property and
                IsValid property.
            </summary>
            <param name="other">The other  <see cref="T:LibLSLCC.CodeValidator.LSLExpressionValidatorResult" /> to compare this one to.</param>
            <returns>
                True if both  <see cref="T:LibLSLCC.CodeValidator.LSLExpressionValidatorResult" /> objects have the same  <see cref="P:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.ResultType" /> and
                <see cref="P:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.IsValid" /> values.
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.Equals(System.Object)">
            <summary>
                Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
                true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
            <param name="obj">Another object to compare to. </param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.GetHashCode">
            <summary>
                Returns the hash code for this instance.
            </summary>
            <returns>
                A 32-bit signed integer that is the hash code for this instance.
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.op_Equality(LibLSLCC.CodeValidator.LSLExpressionValidatorResult,LibLSLCC.CodeValidator.LSLExpressionValidatorResult)">
            <summary>
                Equality operator that checks if <see cref="P:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.ResultType" /> and <see cref="P:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.IsValid" /> are the same in both objects.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>
                True if both <see cref="T:LibLSLCC.CodeValidator.LSLExpressionValidatorResult" /> objects have the same <see cref="P:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.ResultType" /> and
                <see cref="P:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.IsValid" /> values.
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.op_Inequality(LibLSLCC.CodeValidator.LSLExpressionValidatorResult,LibLSLCC.CodeValidator.LSLExpressionValidatorResult)">
            <summary>
                In-Equality operator that checks if <see cref="P:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.ResultType" /> or <see cref="P:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.IsValid" /> are different in both
                objects.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>
                True if both <see cref="T:LibLSLCC.CodeValidator.LSLExpressionValidatorResult" /> objects  <see cref="P:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.ResultType" /> or
                <see cref="P:LibLSLCC.CodeValidator.LSLExpressionValidatorResult.IsValid" /> property values differ from each others.
            </returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLExpressionValidator">
            <summary>
                An interface used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" /> to validate and retrieve the return type of
                expressions such as binary expressions, as well as other expressions that return a type.
                this interface also defines type validation for expressions in boolean condition areas, vectors, rotations, lists
                and function call parameters.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLExpressionValidator.ValidatePostfixOperation(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode,LibLSLCC.CodeValidator.LSLPostfixOperationType)">
            <summary>
                Validates the types involved in a postfix operation and returns an object describing whether or not
                the postfix operation expression was valid for the involved types.
                The return type of the postfix operation is also evaluated and returned in the result.
            </summary>
            <param name="left">The expression on the left of the postfix operation.</param>
            <param name="operation">The postfix operation preformed.</param>
            <returns>An <see cref="T:LibLSLCC.CodeValidator.LSLExpressionValidatorResult" /> containing the validation results.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLExpressionValidator.ValidatePrefixOperation(LibLSLCC.CodeValidator.LSLPrefixOperationType,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Validates the types involved in a prefix operation and returns an object describing whether or not
                the prefix operation expression was valid for the involved types.
                The return type of the prefix operation is also evaluated and returned in the result.
            </summary>
            <param name="right">The expression on the right of the prefix operation.</param>
            <param name="operation">The prefix operation preformed.</param>
            <returns>An <see cref="T:LibLSLCC.CodeValidator.LSLExpressionValidatorResult" /> containing the validation results.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLExpressionValidator.ValidateCastOperation(LibLSLCC.CodeValidator.LSLType,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Validates that a cast to a certain type can be preformed on a expression node of a certain type.
                Returns an object describing whether or not the cast is valid.
                The return type of the cast operation is also evaluated and returned in the result.
            </summary>
            <param name="castTo">The type being casted to.</param>
            <param name="castedExpression">The expression being casted.</param>
            <returns>An <see cref="T:LibLSLCC.CodeValidator.LSLExpressionValidatorResult" /> containing the validation results.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLExpressionValidator.ValidateBinaryOperation(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode,LibLSLCC.CodeValidator.LSLBinaryOperationType,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Validates the types involved in a binary operation and returns an object describing whether or not
                the binary operation expression was valid for the involved types.
                The return type of the binary operation is also evaluated and returned in the result.
            </summary>
            <param name="left">The expression on the left of the binary operation.</param>
            <param name="operation">The binary operation preformed.</param>
            <param name="right">The expression on the left of the binary operation.</param>
            <returns>An <see cref="T:LibLSLCC.CodeValidator.LSLExpressionValidatorResult" /> containing the validation results.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLExpressionValidator.ValidateReturnTypeMatch(LibLSLCC.CodeValidator.LSLType,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Validates that an expression matches the return type of a function, or rather if a certain expression can be
                returned
                from a function with the given return type.
            </summary>
            <param name="returnType">The return type of the function.</param>
            <param name="returnedExpression">The expression to be returned from the function.</param>
            <returns>
                True if the given expression is of a valid type to be returned from a function with the given return type,
                false if otherwise.
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLExpressionValidator.ValidateVectorContent(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Validates that a given expression is able to be used inside of a vector literal initializer list.
            </summary>
            <param name="type">
                The expression the user is attempting to use to initialize one of the components of a vector
                literal.
            </param>
            <returns>True if the expression can be used in a vector literal initializer list, false if otherwise.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLExpressionValidator.ValidateRotationContent(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Validates that a given expression is able to be used inside of a rotation literal initializer list.
            </summary>
            <param name="type">
                The expression the user is attempting to use to initialize one of the components of a rotation
                literal.
            </param>
            <returns>True if the expression can be used in a rotation literal initializer list, false if otherwise.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLExpressionValidator.ValidateListContent(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Validates that a given expression is able to be used inside of a list literal initializer list.
            </summary>
            <param name="type">The expression the user is attempting to use to initialize a list literal element.</param>
            <returns>True if the expression can be used in a list literal initializer list, false if otherwise.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLExpressionValidator.ValidBooleanConditional(LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Validates that a given expression can be used as a boolean conditional for a control or loop statement.
            </summary>
            <param name="type">
                The expression the user is attempting to use as a boolean conditional in a control or loop
                statement.
            </param>
            <returns>True if the expression can be used as a boolean conditional, false if otherwise.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLExpressionValidator.ValidateFunctionParameter(LibLSLCC.CodeValidator.LSLParameterSignature,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Validates that an expression can be passed into the parameter slot of a function.
                IE: That the passed expression matches up with or can be converted to the parameter type.
            </summary>
            <param name="parameterSignature">The parameter definition.</param>
            <param name="parameterExpressionPassed">The expression the user has attempting to pass into the parameter.</param>
            <returns><c>true</c> if <paramref name="parameterExpressionPassed"/> can be passed to the given parameter signature.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLStringCharacterError">
            <summary>
                Represents a character error for the <see cref="T:LibLSLCC.CodeValidator.ILSLStringPreProcessor" /> type.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStringCharacterError.#ctor(System.Char,System.Int32)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLStringCharacterError" /> for a given character and index in the string.
            </summary>
            <param name="causingCharacter">The character that caused the error.</param>
            <param name="stringIndex">The index in the string the character error was encountered at.</param>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStringCharacterError.CausingCharacter">
            <summary>
                The character that caused the error.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStringCharacterError.StringIndex">
            <summary>
                The index in the string at which the error occurred.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStringCharacterError.Equals(LibLSLCC.CodeValidator.LSLStringCharacterError)">
            <summary>
                Equals checks equality by determining whether or not the <see cref="P:LibLSLCC.CodeValidator.LSLStringCharacterError.CausingCharacter" /> and
                <see cref="P:LibLSLCC.CodeValidator.LSLStringCharacterError.StringIndex" /> are the
                same in both objects.
            </summary>
            <param name="other">The other <see cref="T:LibLSLCC.CodeValidator.LSLStringCharacterError" /> object to test for equality with.</param>
            <returns>True if <see cref="P:LibLSLCC.CodeValidator.LSLStringCharacterError.CausingCharacter" /> and <see cref="P:LibLSLCC.CodeValidator.LSLStringCharacterError.StringIndex" /> are the same in both objects.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStringCharacterError.Equals(System.Object)">
            <summary>
                Equals checks equality by determining whether or not the <see cref="P:LibLSLCC.CodeValidator.LSLStringCharacterError.CausingCharacter" /> and
                <see cref="P:LibLSLCC.CodeValidator.LSLStringCharacterError.StringIndex" /> are the
                same in both objects.
            </summary>
            <param name="obj">The other <see cref="T:LibLSLCC.CodeValidator.LSLStringCharacterError" /> object to test for equality with.</param>
            <returns>
                True if 'obj' is a <see cref="T:LibLSLCC.CodeValidator.LSLStringCharacterError" /> object, and <see cref="P:LibLSLCC.CodeValidator.LSLStringCharacterError.CausingCharacter" /> and
                <see cref="P:LibLSLCC.CodeValidator.LSLStringCharacterError.StringIndex" /> are the same in both objects.  False if otherwise.
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStringCharacterError.GetHashCode">
            <summary>
                Returns the hash code for this instance.
                The hash code is derived from the <see cref="P:LibLSLCC.CodeValidator.LSLStringCharacterError.CausingCharacter" /> property and the <see cref="P:LibLSLCC.CodeValidator.LSLStringCharacterError.StringIndex" />
                property.
            </summary>
            <returns>
                A 32-bit signed integer that is the hash code for this instance.
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStringCharacterError.op_Equality(LibLSLCC.CodeValidator.LSLStringCharacterError,LibLSLCC.CodeValidator.LSLStringCharacterError)">
            <summary>
                The equality operator checks equality by determining whether or not the <see cref="P:LibLSLCC.CodeValidator.LSLStringCharacterError.CausingCharacter" /> and
                <see cref="P:LibLSLCC.CodeValidator.LSLStringCharacterError.StringIndex" /> are the
                same in both <see cref="T:LibLSLCC.CodeValidator.LSLStringCharacterError" /> objects.
            </summary>
            <param name="left">The <see cref="T:LibLSLCC.CodeValidator.LSLStringCharacterError" /> on the left of the equality operator.</param>
            <param name="right">The <see cref="T:LibLSLCC.CodeValidator.LSLStringCharacterError" /> on the right of the equality operator.</param>
            <returns>
                True if <see cref="P:LibLSLCC.CodeValidator.LSLStringCharacterError.CausingCharacter" /> and <see cref="P:LibLSLCC.CodeValidator.LSLStringCharacterError.StringIndex" /> are the same in both
                <see cref="T:LibLSLCC.CodeValidator.LSLStringCharacterError" /> objects, false if otherwise.
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStringCharacterError.op_Inequality(LibLSLCC.CodeValidator.LSLStringCharacterError,LibLSLCC.CodeValidator.LSLStringCharacterError)">
            <summary>
                The in-equality operator checks in-equality by determining whether either the <see cref="P:LibLSLCC.CodeValidator.LSLStringCharacterError.CausingCharacter" /> or
                <see cref="P:LibLSLCC.CodeValidator.LSLStringCharacterError.StringIndex" /> are different among two <see cref="T:LibLSLCC.CodeValidator.LSLStringCharacterError" /> objects.
            </summary>
            <param name="left">The <see cref="T:LibLSLCC.CodeValidator.LSLStringCharacterError" /> on the left of the in-equality operator.</param>
            <param name="right">The <see cref="T:LibLSLCC.CodeValidator.LSLStringCharacterError" /> on the right of the in-equality operator.</param>
            <returns>
                True if <see cref="P:LibLSLCC.CodeValidator.LSLStringCharacterError.CausingCharacter" /> or <see cref="P:LibLSLCC.CodeValidator.LSLStringCharacterError.StringIndex" /> are different among the two
                <see cref="T:LibLSLCC.CodeValidator.LSLStringCharacterError" /> objects, false otherwise.
            </returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLStringPreProcessor">
            <summary>
                An interface use by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" /> to pre-processes string literals encountered
                in source code before the text is stored in the <see cref="P:LibLSLCC.CodeValidator.LSLStringLiteralNode.PreProcessedText" /> property of
                the <see cref="T:LibLSLCC.CodeValidator.ILSLStringLiteralNode" /> node.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLStringPreProcessor.HasErrors">
            <summary>
                True if the string that was just pre-processed contains invalid escape sequences or illegal character errors.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLStringPreProcessor.HasInvalidEscapeSequences">
            <summary>
               True if the string that was just pre-processed contains invalid escape sequences
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLStringPreProcessor.HasInvalidCharacters">
            <summary>
               True if the string that was just pre-processed contains illegal characters.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLStringPreProcessor.InvalidEscapeCodes">
            <summary>
                An enumerable of all invalid escape sequences found in the string.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLStringPreProcessor.IllegalCharacters">
            <summary>
                An enumerable of all illegal characters found in the string.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLStringPreProcessor.Result">
            <summary>
                The resulting string after the input string has been pre-processed.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLStringPreProcessor.ProcessString(System.String)">
            <summary>
                Process the string and place descriptions of invalid escape codes in the <see cref="P:LibLSLCC.CodeValidator.ILSLStringPreProcessor.InvalidEscapeCodes" />
                enumerable,
                Place illegal character errors in the <see cref="P:LibLSLCC.CodeValidator.ILSLStringPreProcessor.IllegalCharacters" /> enumerable.
            </summary>
            <param name="stringLiteral">
                The string literal to be processed, the string is expected to be wrapped in double quote
                characters still.
            </param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLStringPreProcessor.Reset">
            <summary>
                Reset the pre-processor so it can process another string
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener">
            <summary>
                Interface for a syntax error listener, this is called into by the code validator
                when syntax errors occur.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.GrammarLevelParserSyntaxError(System.Int32,System.Int32,LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String,System.String)">
            <summary>
                A parsing error at the grammar level has occurred somewhere in the source code.
            </summary>
            <param name="line">The line on which the error occurred.</param>
            <param name="column">The character column at which the error occurred.</param>
            <param name="offendingTokenText">The text representing the offending token.</param>
            <param name="message">The parsing error messaged passed along from the parsing back end.</param>
            <param name="offendingTokenRange">The source code range of the offending symbol.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.UndefinedVariableReference(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String)">
            <summary>
                A reference to an undefined variable was encountered.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="name">Name of the variable attempting to be referenced.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.ParameterNameRedefined(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLParameterListType,LibLSLCC.CodeValidator.LSLType,System.String)">
            <summary>
                A parameter name for a function or event handler was used more than once.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="parameterListType">The type of parameter list the duplicate parameter name was found in.</param>
            <param name="type">The type of the new parameter who's name was duplicate.</param>
            <param name="name">The name of the new parameter, which was duplicate.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.InvalidBinaryOperation(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode,System.String,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                A binary operation was encountered that had expressions with incorrect return types on either or both sides.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="left">The left expression.</param>
            <param name="operation">The binary operation that was attempted on the two expressions.</param>
            <param name="right">The right expression.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.InvalidPrefixOperation(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                A prefix operation was attempted on expression with an invalid return type.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="operation">The prefix operation that was attempted on the expression.</param>
            <param name="right">The expression the prefix operation was used on.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.InvalidPostfixOperation(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode,System.String)">
            <summary>
                A postfix operation was attempted on expression with an invalid return type.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="operation">The postfix operation that was attempted on the expression.</param>
            <param name="left">The expression the postfix operation was used on.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.InvalidCastOperation(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLType,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                An invalid cast was preformed on an expression.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="castTo">The type that the cast operation attempted to cast the expression to.</param>
            <param name="fromExpression">The expression that the cast was attempted on.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.TypeMismatchInVariableDeclaration(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLType,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                A variable declaration was initialized with an invalid type on the right.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="variableType">The actual type of the variable attempting to be initialized.</param>
            <param name="assignedExpression">The invalid expression that was assigned in the variable declaration.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.VariableRedefined(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLType,System.String)">
            <summary>
                A variable was redefined.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="variableType">The type of the variable that was considered a re-definition.</param>
            <param name="variableName">The name of the variable that was considered a re-definition.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.InvalidVectorContent(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLVectorComponent,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                A vector literal contained an invalid expression in its initializer list.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="component">The vector component of the initializer that contained the invalid expression.</param>
            <param name="invalidExpressionContent">The expression that was considered to be invalid vector initializer content.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.InvalidListContent(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.Int32,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                A list literal contained an invalid expression in its initializer list.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="index">The index in the initializer list that contained the invalid expression.</param>
            <param name="invalidExpressionContent">The expression that was considered to be invalid list initializer content.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.InvalidRotationContent(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLRotationComponent,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                A rotation literal contained an invalid expression in its initializer list.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="component">The rotation component of the initializer that contained the invalid expression.</param>
            <param name="invalidExpressionContent">The expression that was considered to be invalid rotation initializer content.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.ReturnedValueFromVoidFunction(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Attempted to return a value from a function with no return type. (A void function)
            </summary>
            <param name="location">Location in source code.</param>
            <param name="functionSignature">The signature of the function the return was attempted from.</param>
            <param name="attemptedReturnExpression">The expression that was attempted to be returned.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.TypeMismatchInReturnValue(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Type mismatch between the expression returned from a function and the functions actual return type.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="functionSignature">The signature of the function the return was attempted from.</param>
            <param name="attemptedReturnExpression">The expression that was attempted to be returned.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.ReturnedVoidFromNonVoidFunction(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature)">
            <summary>
                An empty return statement was encountered in a non void function. <para/>
                In other words, the function required an expression to be returned but none was provided.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="functionSignature">The signature of the function the return was attempted from.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.JumpToUndefinedLabel(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String)">
            <summary>
                A jump statement to an undefined label name was encountered.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="labelName">The name of the label that was given to the jump statement.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.CallToUndefinedFunction(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String)">
            <summary>
                A call to an undefined function was encountered.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="functionName">The name of the function used in the call.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.ImproperParameterCountInFunctionCall(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode[])">
            <summary>
                A user defined or library function was called with the wrong number of parameters.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="functionSignature">The function signature of the defined function attempting to be called.</param>
            <param name="parameterExpressionsGiven">The expressions given to the function call.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.RedefinedFunction(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature)">
            <summary>
                A user defined function was re-defined.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="previouslyDefinedSignature">
                The signature of the previously defined function that is considered a
                duplicated to the new definition.
            </param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.RedefinedLabel(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String)">
            <summary>
                A code label was considered a redefinition, given the scope of the new definition.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="labelName">The name of the label being redefined.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.InvalidTupleComponentAccessOperation(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode,System.String)">
            <summary>
                A '.' member access operation was attempted on an invalid variable type, or the variable type did not contain the given member.  <para/>
                Valid member names for vectors are:  "x", "y" and "z" <para/>
                Valid member names for rotations are:  "x", "y", "z" and "s" <para/>
            </summary>
            <param name="location">Location in source code.</param>
            <param name="exprLvalue">The variable expression on the left side of the dot operator.</param>
            <param name="memberAccessed">The member/component name on the right side of the dot operator.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.IfConditionNotValidType(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                The return type of an expression used in an if statement condition is not a valid type.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="attemptedConditionExpression">The invalid expression in the condition area of the if statement.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.ElseIfConditionNotValidType(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                The return type of an expression used in an else-if statement condition is not a valid type.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="attemptedConditionExpression">The invalid expression in the condition area of the else-if statement.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.DoLoopConditionNotValidType(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                The return type of an expression used in a do-loops condition is not a valid type.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="attemptedConditionExpression">The invalid expression in the condition area of the do-loop.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.WhileLoopConditionNotValidType(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                The return type of an expression used in a while-loops condition is not a valid type.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="attemptedConditionExpression">The invalid expression in the condition area of the while-loop.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.ForLoopConditionNotValidType(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                The return type of an expression used in a for-loops condition is not a valid type.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="attemptedConditionExpression">The invalid expression in the condition area of the for-loop.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.ParameterTypeMismatchInFunctionCall(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.Int32,LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode[])">
            <summary>
                A parameter type mismatch occured when trying to call a user defined or library function.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="parameterIndexWithError">The index of the parameter with the type mismatch. (Zero based)</param>
            <param name="calledFunction">The defined/library function that was attempting to be called.</param>
            <param name="parameterExpressionsGiven">The parameter expressions given for the function call.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.RedefinedStateName(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String)">
            <summary>
                A state name was re-defined.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="stateName">The name of the state being redefined.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.UnknownEventHandlerDeclared(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLEventSignature)">
            <summary>
                An event handler was declared that was not defined in the library data provider.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="givenEventHandlerSignature">The signature of the event handler attempting to be used.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.IncorrectEventHandlerSignature(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLEventSignature,LibLSLCC.CodeValidator.ILSLEventSignature)">
            <summary>
                An event handler was declared in the program with a call signature differing from its definition in the library data provider.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="givenEventHandlerSignature">The invalid signature used for the event handler in the source code.</param>
            <param name="correctEventHandlerSignature">
                The correct signature for for the event handler; the one that was expected.
            </param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.RedefinedStandardLibraryConstant(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLType,LibLSLCC.CodeValidator.ILSLConstantSignature)">
            <summary>
                A standard library constant defined in the library data provider was redefined in source code as a global or local
                variable.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="redefinitionType">The type used in the re-definition.</param>
            <param name="originalSignature">The original signature of the constant taken from the library data provider.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.RedefinedStandardLibraryFunction(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String,LibLSLCC.Collections.IReadOnlyGenericArray{LibLSLCC.CodeValidator.ILSLFunctionSignature})">
            <summary>
                A library function that exist in the library data provider was redefined by the user.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="functionName">The name of the library function the user attempted to redefine.</param>
            <param name="libraryFunctionSignatureOverloads">
                All of the overloads for the library function, there may only be one if
                no overloads actually exist.
            </param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.ChangeToUndefinedState(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String)">
            <summary>
                A state change statement was encountered that referenced an undefined state name.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="stateName">The undefined state name referenced.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.ModifiedLibraryConstant(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String)">
            <summary>
                An attempt to modify a library constant defined in the library data provider was made.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="constantName">The name of the constant the user attempted to modified.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.RedefinedDefaultState(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                The user attempted to use 'default' for a user defined state name.
            </summary>
            <param name="location">Location in source code.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.DeadCodeAfterReturnPath(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLDeadCodeSegment)">
            <summary>
                Dead code after a return path was detected in a function with a non-void return type.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="inFunction">The signature of the function the dead code was detected in.</param>
            <param name="deadSegment">An object describing the location an span of the dead code segment.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.NotAllCodePathsReturnAValue(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature)">
            <summary>
                A function with a non-void return type lacks a necessary return statement. <para/>
                There is a path that leads to the end of the function without it returning a value.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="inFunction">The signature of the function in question.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.StateHasNoEventHandlers(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String)">
            <summary>
                A code state does not declare any event handlers at all; this is not allowed.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="stateName">The name of the state in which this error occurred.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.MissingConditionalExpression(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLConditionalStatementType)">
            <summary>
                A conditional expression is missing from an IF, ELSE IF, or WHILE/DO-WHILE statement.  <para/>
                FOR loops can have a missing condition expression, but other control statements cannot.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="statementType">The type of branch/loop statement the condition was missing from.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.DefinedVariableInBracelessScope(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Attempted to define a variable inside of a braceless scope. <para/>
                For example, inside of an IF statement which does not use braces in its code area. (a single statement is used) <para/>
                This applies to other control/loop statements that can use braceless scopes as well.
            </summary>
            <param name="location">Location in source code.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.IllegalStringCharacter(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLStringCharacterError)">
            <summary>
                An illegal character was found inside of a string literal according to the current
                <see cref="T:LibLSLCC.CodeValidator.ILSLStringPreProcessor" /> instance.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="err">The generated character error object from the <see cref="T:LibLSLCC.CodeValidator.ILSLStringPreProcessor" /> instance.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.InvalidStringEscapeCode(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLStringCharacterError)">
            <summary>
                An invalid escape sequence was found inside of a string literal according to the current
                <see cref="T:LibLSLCC.CodeValidator.ILSLStringPreProcessor" /> instance.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="err">The generated character error object from the <see cref="T:LibLSLCC.CodeValidator.ILSLStringPreProcessor" /> instance.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.CallToFunctionInStaticContext(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String)">
            <summary>
                A call to function was attempted in a static context. (in a global variable declaration expression) <para/>
                This will occur even for undeclared functions.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="functionName">The name of the function.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.RedefinedEventHandler(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String,System.String)">
            <summary>
                A library defined event handler was used more than once in the same state.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="eventHandlerName">The name of the event handler which was used more than once.</param>
            <param name="stateName">The name of the code state in which the error occured.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.MissingDefaultState">
            <summary>
                The default code state was missing from the program.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.NoSuitableLibraryFunctionOverloadFound(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String,LibLSLCC.Collections.IReadOnlyGenericArray{LibLSLCC.CodeValidator.ILSLReadOnlyExprNode})">
            <summary>
                An overload could not be resolved for an attempted call to an overloaded library function.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="functionName">The name of the overloaded library function that the user attempted to call.</param>
            <param name="givenParameterExpressions">
                The parameter expressions the user attempted to pass to the overloaded library
                function.
            </param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.CallToOverloadedLibraryFunctionIsAmbiguous(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String,LibLSLCC.Collections.IReadOnlyGenericArray{LibLSLCC.CodeValidator.ILSLFunctionSignature},LibLSLCC.Collections.IReadOnlyGenericArray{LibLSLCC.CodeValidator.ILSLReadOnlyExprNode})">
            <summary>
                The arguments passed to an overloaded library function match up with more than one defined overload.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="functionName">The name of the overloaded library function that the user attempted to call.</param>
            <param name="ambiguousMatches">All of the function overloads the call to the library function matched up with.</param>
            <param name="givenParameterExpressions">
                The parameter expressions the user attempted to pass to the overloaded library
                function.
            </param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.TupleComponentAccessOnLibraryConstant(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLVariableNode,LibLSLCC.CodeValidator.ILSLConstantSignature,System.String)">
            <summary>
                The dot operator used to access the components of vectors and rotations was used on a library constant.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="libraryConstantReferenceNode">The variable reference node on the left side of the dot operator.</param>
            <param name="libraryConstantSignature">
                The library constant signature that was referenced, retrieved from the library
                data provider.
            </param>
            <param name="accessedMember">The member the user attempted to access.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.BinaryOperatorInStaticContext(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                A binary operator was used in a static context.  <para/>
                (in a global variable declaration expression)
            </summary>
            <param name="location">The location of the error.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.ParenthesizedExpressionInStaticContext(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                A parenthesized expression was used in a static context.  <para/>
                (in a global variable declaration expression)
            </summary>
            <param name="location">The location of the error.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.PostfixOperationInStaticContext(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                A postfix expression was used in a static context.  <para/>
                (in a global variable declaration expression)
            </summary>
            <param name="location">The location of the error.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.InvalidPrefixOperationUsedInStaticContext(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLPrefixOperationType)">
            <summary>
                An invalid prefix expression was used in a static context (a global variable declaration expression) <para/>
                Negate is the only prefix operator allowed in a static context, and only on literals and not variables.
            </summary>
            <param name="location">The location of the error.</param>
            <param name="type">The operation type.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.PrefixOperationOnGlobalVariableInStaticContext(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLPrefixOperationType)">
            <summary>
                A prefix operator was used on a global variable reference in a static context.  <para/>
                (in a global variable declaration expression)
            </summary>
            <param name="location">The location of the error.</param>
            <param name="type">The operation type.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.PostfixOperationOnNonVariable(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLPostfixOperationType)">
            <summary>
                A postfix operation was applied to an expression that was not a variable.
            </summary>
            <param name="location">The location of the error.</param>
            <param name="type">The operation type.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.ModifyingPrefixOperationOnNonVariable(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLPrefixOperationType)">
            <summary>
                A modifying prefix operation was applied to an expression that was not a variable.
            </summary>
            <param name="location">The location of the error.</param>
            <param name="type">The operation type.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.NegateOperationOnVectorLiteralInStaticContext(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                The negate prefix operator was used on a vector literal in a static context. <para/>
                 (in a global variable declaration expression)
            </summary>
            <param name="location">The location of the error.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.NegateOperationOnRotationLiteralInStaticContext(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                The negate prefix operator was used on a rotation literal in a static context. <para/>
                (in a global variable declaration expression)
            </summary>
            <param name="location">The location of the error.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.CastExpressionInStaticContext(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                A cast expression was used inside of a static context. <para/>
                (in a global variable declaration expression)
            </summary>
            <param name="location">The location of the error.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.AssignmentToNonassignableExpression(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String)">
            <summary>
                Occurs with an expression that is left of an assignment type operator is not assignable.
                This includes compound assignment operators such as: += ... <para/>
                This error occurs only for left expressions that are not library constants.
                There is a separate error for library constants, see <see cref="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.ModifiedLibraryConstant(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String)" />.
            </summary>
            <param name="location">The source code range of the assignment operator used.</param>
            <param name="assignmentOperatorUsed">The assignment operator used.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.CastOnCastExpression(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                A cast expression was used directly on another cast expression without parenthesizing the expression on the right. <para/>
                LibLSLCC's parser can handle this, but Secondlife's LSL parser cannot; it's ambiguous to it and causes a syntax error.
            </summary>
            <param name="location">The source code range of the offending cast expression.</param>
            <param name="castedExpression">The casted expression, which will be another typecast expression.</param>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener">
            <summary>
                Interface for a syntax warning listener, this is called into by the code validator
                when syntax warnings occur.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.MultipleListAssignmentsInExpression(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Warns about the occurrence of multiple list or list variable assignments occurring inside of a single expression.
            </summary>
            <remarks>
                This sort of thing was a common optimization for LSL when LSO was used instead of Mono.
                It can result in unexpected behavior in some LSL compilers such as OpenSims default compiler.
                The code generator provided with this library can handle old LSO optimizations such as this one, but it is good
                to warn about it since the optimization is completely unnecessary now days and may even make your code slower on
                Mono.
            </remarks>
            <param name="location">The location in the source code.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.MultipleStringAssignmentsInExpression(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Warns about the occurrence of multiple string or string variable assignments occurring inside of a single expression.
            </summary>
            <remarks>
                This sort of thing was a common optimization for LSL when LSO was used instead of Mono.
                It can result in unexpected behavior in some LSL compilers such as OpenSims default compiler.
                The code generator provided with this library can handle old LSO optimizations such as this one, but it is good
                to warn about it since the optimization is completely unnecessary now days and may even make your code slower on
                Mono.
            </remarks>
            <param name="location">The location in the source code.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.DeadCodeDetected(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLDeadCodeSegment)">
            <summary>
                Dead code was detected, but it was not an error because it was inside a function with a void return type.
            </summary>
            <param name="location">The location in the source code.</param>
            <param name="currentFunction">The signature of the function that dead code was detected in.</param>
            <param name="deadSegment">An object describing the range of code that is considered to be dead.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.DeadCodeDetected(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLEventSignature,LibLSLCC.CodeValidator.ILSLDeadCodeSegment)">
            <summary>
                Dead code was detected, but it was not an error because it was inside an event handler.
            </summary>
            <param name="location">The location in the source code.</param>
            <param name="currentEvent">The signature of the event handler that dead code was detected in.</param>
            <param name="deadSegment">An object describing the range of code that is considered to be dead.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.ConditionalExpressionIsConstant(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode,LibLSLCC.CodeValidator.LSLConditionalStatementType)">
            <summary>
                A constant value was used for the conditional expression in a control or loop statement.
            </summary>
            <param name="location">The location in the source code.</param>
            <param name="expression">The offending expression.</param>
            <param name="conditionalStatementType">The type of conditional statement the expression was used in.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.UselessSemicolon(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                An un-needed but valid semi-colon was detected in code, such as when a semi-colon is on a line by itself or
                multiple semi-colons follow an expression statement when only one is needed.
            </summary>
            <param name="location">The location in the source code.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.ExpressionStatementHasNoEffect(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                An expression statement has no effect; this can happen if you simply reference a variable as an expression statement and do nothing to it. <para/>
                As an example, referencing a counter but forgetting to add an increment or decrement operator to it would cause this. <para/>
                It will compile but it might be an error.
            </summary>
            <param name="location">The source code location of the expression statement.</param>
            <param name="statementExpression">The offending expression used as a statement.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.ForLoopAfterthoughtHasNoEffect(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode,System.Int32,System.Int32)">
            <summary>
                The expression in the 'after thought' of a for loop has no affect. <para/>
                As an example, this can happen if you forget to add an increment or decrement operator to a loop counter variable.
            </summary>
            <param name="location">The location in the source code.</param>
            <param name="expression">The offending expression.</param>
            <param name="expressionIndex">
                For loop afterthoughts can be a list of expressions to be executed, separated by commas.
                This is the index of the expression in the possible list of expressions.
                If the for loop afterthought does not use a list of expressions, this is always 0.
            </param>
            <param name="expressionCountTotal">
                The number of expressions used in the for loop afterthought expression list.
            </param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.ForLoopInitExpressionHasNoEffect(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode,System.Int32,System.Int32)">
            <summary>
                The expression in the 'init section' of a for loop has no affect, for example: If its just a variable reference.  <para/>
                As an example, this can happen if you forget to assign a starting value to a loop counter.
            </summary>
            <param name="location">The location in the source code.</param>
            <param name="expression">The offending expression.</param>
            <param name="expressionIndex">
                For loop init expressions can be a list of expressions to be executed, separated by commas.
                This is the index of the expression in the possible list of expressions.
                If the for loop init expression does not use a list of expressions, this is always 0.
            </param>
            <param name="expressionCountTotal">
                The number of expressions used in the for loop init expression list.
            </param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.RedundantCast(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLType)">
            <summary>
                A cast is considered redundant because the expression the user casted already has the same return type as the cast-to type.
            </summary>
            <param name="location">The location in the source code.</param>
            <param name="castType">The type the user attempted to cast the expression to.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.FunctionNeverUsed(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionDeclarationNode)">
            <summary>
                A user defined function was never referenced.
            </summary>
            <param name="location">The location in the source code of the function that was never referenced.</param>
            <param name="functionDeclarationNode">The function declaration node of the un-referenced function.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.GlobalVariableNeverUsed(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
            <summary>
                A user defined global variable was never referenced.
            </summary>
            <param name="location">The location in the source code of the global variable that was never referenced.</param>
            <param name="variable">The variable declaration node of the un-referenced global variable.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.LocalVariableNeverUsed(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode,LibLSLCC.CodeValidator.ILSLFunctionSignature)">
            <summary>
                A user defined local variable was never referenced.
            </summary>
            <param name="location">The location in the source code of the local variable that was never referenced.</param>
            <param name="variable">The variable declaration node of the un-referenced local variable.</param>
            <param name="inFunction">The signature of the function in which the local variable exists.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.LocalVariableNeverUsed(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode,LibLSLCC.CodeValidator.ILSLEventSignature)">
            <summary>
                A user defined local variable was never referenced.
            </summary>
            <param name="location">The location in the source code of the local variable that was never referenced.</param>
            <param name="variable">The variable declaration node of the un-referenced local variable.</param>
            <param name="inEvent">The signature of the event handler in which the local variable exists.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.FunctionParameterNeverUsed(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode,LibLSLCC.CodeValidator.ILSLFunctionSignature)">
            <summary>
                A user defined function parameter was never referenced.
            </summary>
            <param name="location">The location in the source code of the parameter that was never referenced.</param>
            <param name="parameter">The variable declaration node of the un-referenced function parameter.</param>
            <param name="inFunction">The signature of the function in which the parameter exists.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.ParameterHidesGlobalVariable(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLParameterNode,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
            <summary>
                A parameter name of a user defined function hides the definition of a global variable.
            </summary>
            <param name="location">The location in source code of the parameter that hides the global variable.</param>
            <param name="functionSignature">The function signature to which the parameter definition belongs to.</param>
            <param name="parameter">The signature of the parameter that hides the global variable.</param>
            <param name="globalVariable">The variable declaration node of the global variable that was hidden.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.ParameterHidesGlobalVariable(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLEventSignature,LibLSLCC.CodeValidator.ILSLParameterNode,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
            <summary>
                A parameter name of a library defined event handler hides the definition of a global variable.
            </summary>
            <param name="location">The location in source code of the parameter that hides the global variable.</param>
            <param name="eventHandlerSignature">The event handler signature to which the parameter definition belongs to.</param>
            <param name="parameter">The signature of the parameter that hides the global variable.</param>
            <param name="globalVariable">The variable declaration node of the global variable that was hidden.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.LocalVariableHidesParameter(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode,LibLSLCC.CodeValidator.ILSLParameterNode)">
            <summary>
                A local variable name inside of a user defined function hides the definition of one of the functions parameters.
            </summary>
            <param name="location">The location in source code of the local variable that hides the function parameter.</param>
            <param name="functionSignature">The signature of the function in which the local variable is defined.</param>
            <param name="localVariable">The variable declaration node of the local variable that hides the parameter.</param>
            <param name="parameter">The parameter node of the parameter that was hidden.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.LocalVariableHidesParameter(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLEventSignature,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode,LibLSLCC.CodeValidator.ILSLParameterNode)">
            <summary>
                A local variable name inside of a library defined event handler hides the definition of one of the event handlers
                parameters.
            </summary>
            <param name="location">The location in source code of the local variable that hides the event handler parameter.</param>
            <param name="eventHandlerSignature">The signature of the event handler in which the local variable is defined.</param>
            <param name="localVariable">The variable declaration node of the local variable that hides the parameter.</param>
            <param name="parameter">The parameter node of the parameter that was hidden.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.LocalVariableHidesGlobalVariable(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
            <summary>
                A local variable inside of a user defined function hides the definition of a user defined global variable.
            </summary>
            <param name="location">The location in source code of the local variable that hides the global variable.</param>
            <param name="functionSignature">The signature of the function in which the local variable is defined.</param>
            <param name="localVariable">The variable declaration node of the local variable that hides the global variable.</param>
            <param name="globalVariable">The variable declaration node of the user defined global variable that was hidden.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.LocalVariableHidesGlobalVariable(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLEventSignature,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
            <summary>
                A local variable inside of a library defined event handler hides the definition of a user defined global variable.
            </summary>
            <param name="location">The location in source code of the local variable that hides the global variable.</param>
            <param name="eventHandlerSignature">The signature of the event handler in which the local variable is defined.</param>
            <param name="localVariable">The variable declaration node of the local variable that hides the global variable.</param>
            <param name="globalVariable">The variable declaration node of the user defined global variable that was hidden.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.UseOfDeprecatedLibraryFunction(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature)">
            <summary>
                A library function that was marked as being deprecated was used.
            </summary>
            <param name="location">The location in source code where the deprecated function was called.</param>
            <param name="functionSignature">The function signature of the deprecated library function that was called.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.UseOfDeprecatedLibraryConstant(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLConstantSignature)">
            <summary>
                A library constant that was marked as being deprecated was used.
            </summary>
            <param name="location">The location in source code where the deprecated constant was referenced.</param>
            <param name="constantSignature">The library constant signature of the deprecated constant that was referenced.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.UseOfDeprecatedLibraryEventHandler(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLEventSignature)">
            <summary>
                A library event handler that was marked as being deprecated was used.
            </summary>
            <param name="location">The location in source code where the deprecated event handler was referenced.</param>
            <param name="eventSignature">The event signature of the deprecated event handler that was referenced.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.VariableRedeclaredInInnerScope(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
            <summary>
                A local variable was re-declared inside of a nested scope, such as an if statement or for loop, ect... <para/>
                This is not an error, but bad practice. This function handles the warning case inside function declarations.
            </summary>
            <param name="location">The source code range of the new variable declaration.</param>
            <param name="currentFunctionBodySignature">The signature of the function the new variable was declared in.</param>
            <param name="newDeclarationNode">The tree node of the new declaration that has not been added to the tree yet.</param>
            <param name="previousDeclarationNode">
                The previous variable declaration node which already exist in the syntax tree, in
                an outer scope.
            </param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.VariableRedeclaredInInnerScope(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLEventSignature,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
            <summary>
                A local variable was re-declared inside of a nested scope, such as an if statement or for loop, ect... <para/>
                This is not an error, but bad practice.  This function handles the warning case inside event handlers.
            </summary>
            <param name="location">The source code range of the new variable declaration.</param>
            <param name="currentEventBodySignature">The signature of the event handler the new variable was declared in.</param>
            <param name="newDeclarationNode">The tree node of the new declaration that has not been added to the tree yet.</param>
            <param name="previousDeclarationNode">
                The previous variable declaration node which already exist in the syntax tree, in
                an outer scope.
            </param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.IntegerLiteralOverflow(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String,System.Boolean)">
            <summary>
                Occurs when an integer literal present in the source code is greater than the max value of a 32 bit LSL integer.
            </summary>
            <param name="location">The source code range of the integer literal.</param>
            <param name="literalText">The text representing the integer literal.</param>
            <param name="negated">Whether or not a negate operator was applied to the integer literal.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.IntegerLiteralUnderflow(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String,System.Boolean)">
            <summary>
                Occurs when an integer literal present in the source code is less than the minimum value of a 32 bit LSL integer.
            </summary>
            <param name="location">The source code range of the integer literal.</param>
            <param name="literalText">The text representing the integer literal.</param>
            <param name="negated">Whether or not a negate operator was applied to the integer literal.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.HexLiteralOverflow(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String,System.Boolean)">
            <summary>
                Occurs when a hex literal present in the source code is greater than the max value of a 32 bit LSL integer.
            </summary>
            <param name="location">The source code range of the hex literal.</param>
            <param name="literalText">The text representing the hex literal.</param>
            <param name="negated">Whether or not a negate operator was applied to the hex literal.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.HexLiteralUnderflow(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String,System.Boolean)">
            <summary>
                Occurs when a hex literal present in the source code is less than the minimum value of a 32 bit LSL integer.
            </summary>
            <param name="location">The source code range of the hex literal.</param>
            <param name="literalText">The text representing the hex literal.</param>
            <param name="negated">Whether or not a negate operator was applied to the hex literal.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.ReturnedValueFromEventHandler(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLEventSignature,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Occurs when a return value inside of an event handler returns an expression instead of nothing.  <para/>
                The return value of the expression is simply discarded in this case.
            </summary>
            <param name="location">The location.</param>
            <param name="eventSignature">The signature of the event handler this warning occurred in.</param>
            <param name="returnExpression">The return expression.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.FloatLiteralUnderflow(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String,System.Boolean)">
            <summary>
                Occurs when an float literal present in the source code is greater than the max value of a 32 bit LSL float.
            </summary>
            <param name="location">The source code range of the float literal.</param>
            <param name="literalText">The text representing the float literal.</param>
            <param name="negated">Whether or not a negate operator was applied to the float literal.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener.FloatLiteralOverflow(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String,System.Boolean)">
            <summary>
                Occurs when an float literal present in the source code is less than the minimum value of a 32 bit LSL float.
            </summary>
            <param name="location">The source code range of the float literal.</param>
            <param name="literalText">The text representing the float literal.</param>
            <param name="negated">Whether or not a negate operator was applied to the float literal.</param>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies">
            <summary>
                Represents various sub strategies and listeners that are used in the <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" /> implementation
                of <see cref="T:LibLSLCC.CodeValidator.ILSLCodeValidator" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies.ExpressionValidator">
            <summary>
                The expression validator is in charge of determining if two types are valid
                in a binary expression.  It also does several other things, one being checking if an expression
                with a certain return type can be passed into a function parameter.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies.LibraryDataProvider">
            <summary>
                The library data provider gives the code validator information about standard library functions,
                constants and events that exist in the LSL namespace.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies.StringLiteralPreProcessor">
            <summary>
                The string literal pre-processor is in charge of pre-processing string literals
                from source code before the value is assigned to an <see cref="P:LibLSLCC.CodeValidator.ILSLStringLiteralNode.PreProcessedText" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies.SyntaxErrorListener">
            <summary>
                The syntax error listener is an interface that listens for syntax
                errors from the code validator
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies.SyntaxWarningListener">
            <summary>
                The syntax error listener is an interface that listens for syntax
                warnings from the code validator
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLDefaultStringPreProcessor">
            <summary>
                The default implementation of <see cref="T:LibLSLCC.CodeValidator.ILSLStringPreProcessor" /> for the library
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultStringPreProcessor.#ctor">
            <summary>
                Construct the default implementation of <see cref="T:LibLSLCC.CodeValidator.ILSLStringPreProcessor" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDefaultStringPreProcessor.HasErrors">
            <summary>
                True if the string that was just pre-processed contains invalid escape sequences or illegal character errors.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDefaultStringPreProcessor.HasInvalidEscapeSequences">
            <summary>
               True if the string that was just pre-processed contains invalid escape sequences
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDefaultStringPreProcessor.HasInvalidCharacters">
            <summary>
               True if the string that was just pre-processed contains illegal characters.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDefaultStringPreProcessor.InvalidEscapeCodes">
            <summary>
                An enumerable of all invalid escape sequences found in the string.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDefaultStringPreProcessor.IllegalCharacters">
            <summary>
                An enumerable of all illegal characters found in the string.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDefaultStringPreProcessor.Result">
            <summary>
                The resulting string after the input string has been pre-processed.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultStringPreProcessor.ProcessString(System.String)">
            <summary>
                Process the string and place descriptions of invalid escape codes in the InvalidEscapeCodes enumerable,
                Place illegal character errors in the IllegalCharacters enumerable.
            </summary>
            <param name="stringLiteral">
                The string literal to be processed, the string is expected to be wrapped in double quote
                characters still.
            </param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultStringPreProcessor.Reset">
            <summary>
                Reset the pre-processor so it can process another string
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener">
            <summary>
                The default implementation of <see cref="T:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener" /> for the library.
                It writes error information to standard out or an arbitrary stream.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.GrammarLevelParserSyntaxError(System.Int32,System.Int32,LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String,System.String)">
            <summary>
                A parsing error at the grammar level has occurred somewhere in the source code.
            </summary>
            <param name="line">The line on which the error occurred.</param>
            <param name="column">The character column at which the error occurred.</param>
            <param name="offendingTokenText">The text representing the offending token.</param>
            <param name="message">The parsing error messaged passed along from the parsing back end.</param>
            <param name="offendingTokenRange">The source code range of the offending symbol.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.UndefinedVariableReference(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String)">
            <summary>
                A reference to an undefined variable was encountered.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="name">Name of the variable attempting to be referenced.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.ParameterNameRedefined(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLParameterListType,LibLSLCC.CodeValidator.LSLType,System.String)">
            <summary>
                A parameter name for a function or event handler was used more than once.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="parameterListType">The type of parameter list the duplicate parameter name was found in.</param>
            <param name="type">The type of the new parameter who's name was duplicate.</param>
            <param name="name">The name of the new parameter, which was duplicate.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.InvalidBinaryOperation(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode,System.String,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                A binary operation was encountered that had expressions with incorrect return types on either or both sides.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="left">The left expression.</param>
            <param name="operation">The binary operation that was attempted on the two expressions.</param>
            <param name="right">The right expression.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.InvalidPrefixOperation(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                A prefix operation was attempted on expression with an invalid return type.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="operation">The prefix operation that was attempted on the expression.</param>
            <param name="right">The expression the prefix operation was used on.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.InvalidPostfixOperation(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode,System.String)">
            <summary>
                A postfix operation was attempted on expression with an invalid return type.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="operation">The postfix operation that was attempted on the expression.</param>
            <param name="left">The expression the postfix operation was used on.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.InvalidCastOperation(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLType,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                An invalid cast was preformed on an expression.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="castTo">The type that the cast operation attempted to cast the expression to.</param>
            <param name="fromExpression">The expression that the cast was attempted on.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.TypeMismatchInVariableDeclaration(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLType,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                A variable declaration was initialized with an invalid type on the right.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="variableType">The actual type of the variable attempting to be initialized.</param>
            <param name="assignedExpression">The invalid expression that was assigned in the variable declaration.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.VariableRedefined(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLType,System.String)">
            <summary>
                A variable was redefined.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="variableType">The type of the variable that was considered a re-definition.</param>
            <param name="variableName">The name of the variable that was considered a re-definition.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.InvalidVectorContent(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLVectorComponent,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                A vector literal contained an invalid expression in its initializer list.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="component">The vector component of the initializer that contained the invalid expression.</param>
            <param name="invalidExpressionContent">The expression that was considered to be invalid vector initializer content.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.InvalidListContent(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.Int32,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                A list literal contained an invalid expression in its initializer list.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="index">The index in the initializer list that contained the invalid expression.</param>
            <param name="invalidExpressionContent">The expression that was considered to be invalid list initializer content.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.InvalidRotationContent(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLRotationComponent,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                A rotation literal contained an invalid expression in its initializer list.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="component">The rotation component of the initializer that contained the invalid expression.</param>
            <param name="invalidExpressionContent">The expression that was considered to be invalid rotation initializer content.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.ReturnedValueFromVoidFunction(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Attempted to return a value from a function with no return type. (A void function)
            </summary>
            <param name="location">Location in source code.</param>
            <param name="functionSignature">The signature of the function the return was attempted from.</param>
            <param name="attemptedReturnExpression">The expression that was attempted to be returned.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.TypeMismatchInReturnValue(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Type mismatch between the expression returned from a function and the functions actual return type.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="functionSignature">The signature of the function the return was attempted from.</param>
            <param name="attemptedReturnExpression">The expression that was attempted to be returned.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.ReturnedVoidFromNonVoidFunction(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature)">
            <summary>
                An empty return statement was encountered in a non void function. <para/>
                In other words, the function required an expression to be returned but none was provided.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="functionSignature">The signature of the function the return was attempted from.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.JumpToUndefinedLabel(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String)">
            <summary>
                A jump statement to an undefined label name was encountered.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="labelName">The name of the label that was given to the jump statement.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.CallToUndefinedFunction(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String)">
            <summary>
                A call to an undefined function was encountered.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="functionName">The name of the function used in the call.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.ImproperParameterCountInFunctionCall(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode[])">
            <summary>
                A user defined or library function was called with the wrong number of parameters.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="functionSignature">The function signature of the defined function attempting to be called.</param>
            <param name="parameterExpressionsGiven">The expressions given to the function call.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.RedefinedFunction(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature)">
            <summary>
                A user defined function was re-defined.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="previouslyDefinedSignature">
                The signature of the previously defined function that is considered a
                duplicated to the new definition.
            </param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.RedefinedLabel(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String)">
            <summary>
                A code label was considered a redefinition, given the scope of the new definition.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="labelName">The name of the label being redefined.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.DeadCodeAfterReturnPath(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLDeadCodeSegment)">
            <summary>
                Dead code after a return path was detected in a function with a non-void return type.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="inFunction">The signature of the function the dead code was detected in.</param>
            <param name="deadSegment">An object describing the location an span of the dead code segment.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.NotAllCodePathsReturnAValue(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature)">
            <summary>
                A function with a non-void return type lacks a necessary return statement. <para/>
                There is a path that leads to the end of the function without it returning a value.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="inFunction">The signature of the function in question.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.StateHasNoEventHandlers(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String)">
            <summary>
                A code state does not declare any event handlers at all; this is not allowed.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="stateName">The name of the state in which this error occurred.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.MissingConditionalExpression(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLConditionalStatementType)">
            <summary>
                A conditional expression is missing from an IF, ELSE IF, or WHILE/DO-WHILE statement.  <para/>
                FOR loops can have a missing condition expression, but other control statements cannot.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="statementType">The type of branch/loop statement the condition was missing from.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.DefinedVariableInBracelessScope(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Attempted to define a variable inside of a braceless scope. <para/>
                For example, inside of an IF statement which does not use braces in its code area. (a single statement is used) <para/>
                This applies to other control/loop statements that can use braceless scopes as well.
            </summary>
            <param name="location">Location in source code.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.IllegalStringCharacter(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLStringCharacterError)">
            <summary>
                An illegal character was found inside of a string literal according to the current
                <see cref="T:LibLSLCC.CodeValidator.ILSLStringPreProcessor" /> instance.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="err">The generated character error object from the <see cref="T:LibLSLCC.CodeValidator.ILSLStringPreProcessor" /> instance.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.InvalidStringEscapeCode(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLStringCharacterError)">
            <summary>
                An invalid escape sequence was found inside of a string literal according to the current
                <see cref="T:LibLSLCC.CodeValidator.ILSLStringPreProcessor" /> instance.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="err">The generated character error object from the <see cref="T:LibLSLCC.CodeValidator.ILSLStringPreProcessor" /> instance.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.RedefinedEventHandler(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String,System.String)">
            <summary>
                A library defined event handler was used more than once in the same state.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="eventHandlerName">The name of the event handler which was used more than once.</param>
            <param name="stateName">The name of the code state in which the error occured.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.MissingDefaultState">
            <summary>
                The default code state was missing from the program.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.NoSuitableLibraryFunctionOverloadFound(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String,LibLSLCC.Collections.IReadOnlyGenericArray{LibLSLCC.CodeValidator.ILSLReadOnlyExprNode})">
            <summary>
                An overload could not be resolved for an attempted call to an overloaded library function.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="functionName">The name of the overloaded library function that the user attempted to call.</param>
            <param name="givenParameterExpressions">
                The parameter expressions the user attempted to pass to the overloaded library
                function.
            </param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.CallToOverloadedLibraryFunctionIsAmbiguous(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String,LibLSLCC.Collections.IReadOnlyGenericArray{LibLSLCC.CodeValidator.ILSLFunctionSignature},LibLSLCC.Collections.IReadOnlyGenericArray{LibLSLCC.CodeValidator.ILSLReadOnlyExprNode})">
            <summary>
                The arguments passed to an overloaded library function match up with more than one defined overload.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="functionName">The name of the overloaded library function that the user attempted to call.</param>
            <param name="ambiguousMatches">All of the function overloads the call to the library function matched up with.</param>
            <param name="givenParameterExpressions">
                The parameter expressions the user attempted to pass to the overloaded library
                function.
            </param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.TupleComponentAccessOnLibraryConstant(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLVariableNode,LibLSLCC.CodeValidator.ILSLConstantSignature,System.String)">
            <summary>
                The dot operator used to access the components of vectors and rotations was used on a library constant.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="libraryConstantReferenceNode">The variable reference node on the left side of the dot operator.</param>
            <param name="libraryConstantSignature">
                The library constant signature that was referenced, retrieved from the library
                data provider.
            </param>
            <param name="accessedMember">The member the user attempted to access.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.CallToFunctionInStaticContext(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String)">
            <summary>
                A call to function was attempted in a static context. (in a global variable declaration expression) <para/>
                This will occur even for undeclared functions.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="functionName">The name of the function.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.BinaryOperatorInStaticContext(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                A binary operator was used in a static context.  <para/>
                (in a global variable declaration expression)
            </summary>
            <param name="location">The location of the error.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.ParenthesizedExpressionInStaticContext(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                A parenthesized expression was used in a static context.  <para/>
                (in a global variable declaration expression)
            </summary>
            <param name="location">The location of the error.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.PostfixOperationInStaticContext(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                A postfix expression was used in a static context.  <para/>
                (in a global variable declaration expression)
            </summary>
            <param name="location">The location of the error.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.InvalidPrefixOperationUsedInStaticContext(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLPrefixOperationType)">
            <summary>
                An invalid prefix expression was used in a static context (a global variable declaration expression) <para/>
                Negate is the only prefix operator allowed in a static context, and only on literals and not variables.
            </summary>
            <param name="location">The location of the error.</param>
            <param name="type">The operation type.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.PrefixOperationOnGlobalVariableInStaticContext(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLPrefixOperationType)">
            <summary>
                A prefix operator was used on a global variable reference in a static context.  <para/>
                (in a global variable declaration expression)
            </summary>
            <param name="location">The location of the error.</param>
            <param name="type">The operation type.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.PostfixOperationOnNonVariable(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLPostfixOperationType)">
            <summary>
                A postfix operation was applied to an expression that was not a variable.
            </summary>
            <param name="location">The location of the error.</param>
            <param name="type">The operation type.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.InvalidTupleComponentAccessOperation(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode,System.String)">
            <summary>
                A '.' member access operation was attempted on an invalid variable type, or the variable type did not contain the given member.  <para/>
                Valid member names for vectors are:  "x", "y" and "z" <para/>
                Valid member names for rotations are:  "x", "y", "z" and "s" <para/>
            </summary>
            <param name="location">Location in source code.</param>
            <param name="exprLvalue">The variable expression on the left side of the dot operator.</param>
            <param name="memberAccessed">The member/component name on the right side of the dot operator.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.IfConditionNotValidType(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                The return type of an expression used in an if statement condition is not a valid type.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="attemptedConditionExpression">The invalid expression in the condition area of the if statement.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.ElseIfConditionNotValidType(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                The return type of an expression used in an else-if statement condition is not a valid type.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="attemptedConditionExpression">The invalid expression in the condition area of the else-if statement.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.DoLoopConditionNotValidType(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                The return type of an expression used in a do-loops condition is not a valid type.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="attemptedConditionExpression">The invalid expression in the condition area of the do-loop.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.WhileLoopConditionNotValidType(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                The return type of an expression used in a while-loops condition is not a valid type.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="attemptedConditionExpression">The invalid expression in the condition area of the while-loop.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.ForLoopConditionNotValidType(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                The return type of an expression used in a for-loops condition is not a valid type.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="attemptedConditionExpression">The invalid expression in the condition area of the for-loop.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.ParameterTypeMismatchInFunctionCall(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.Int32,LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode[])">
            <summary>
                A parameter type mismatch occured when trying to call a user defined or library function.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="parameterIndexWithError">The index of the parameter with the type mismatch. (Zero based)</param>
            <param name="calledFunction">The defined/library function that was attempting to be called.</param>
            <param name="parameterExpressionsGiven">The parameter expressions given for the function call.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.RedefinedStateName(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String)">
            <summary>
                A state name was re-defined.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="stateName">The name of the state being redefined.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.UnknownEventHandlerDeclared(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLEventSignature)">
            <summary>
                An event handler was declared that was not defined in the library data provider.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="givenEventHandlerSignature">The signature of the event handler attempting to be used.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.IncorrectEventHandlerSignature(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLEventSignature,LibLSLCC.CodeValidator.ILSLEventSignature)">
            <summary>
                An event handler was declared in the program with a call signature differing from its definition in the library data provider.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="givenEventHandlerSignature">The invalid signature used for the event handler in the source code.</param>
            <param name="correctEventHandlerSignature">
                The correct signature for for the event handler; the one that was expected.
            </param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.RedefinedStandardLibraryConstant(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLType,LibLSLCC.CodeValidator.ILSLConstantSignature)">
            <summary>
                A standard library constant defined in the library data provider was redefined in source code as a global or local
                variable.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="redefinitionType">The type used in the re-definition.</param>
            <param name="originalSignature">The original signature of the constant taken from the library data provider.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.RedefinedStandardLibraryFunction(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String,LibLSLCC.Collections.IReadOnlyGenericArray{LibLSLCC.CodeValidator.ILSLFunctionSignature})">
            <summary>
                A library function that exist in the library data provider was redefined by the user.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="functionName">The name of the library function the user attempted to redefine.</param>
            <param name="libraryFunctionSignatureOverloads">
                All of the overloads for the library function, there may only be one if
                no overloads actually exist.
            </param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.ChangeToUndefinedState(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String)">
            <summary>
                A state change statement was encountered that referenced an undefined state name.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="stateName">The undefined state name referenced.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.ModifiedLibraryConstant(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String)">
            <summary>
                An attempt to modify a library constant defined in the library data provider was made.
            </summary>
            <param name="location">Location in source code.</param>
            <param name="constantName">The name of the constant the user attempted to modified.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.RedefinedDefaultState(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                The user attempted to use 'default' for a user defined state name.
            </summary>
            <param name="location">Location in source code.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.ModifyingPrefixOperationOnNonVariable(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLPrefixOperationType)">
            <summary>
                A modifying prefix operation was applied to an expression that was not a variable.
            </summary>
            <param name="location">The location of the error.</param>
            <param name="type">The operation type.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.NegateOperationOnVectorLiteralInStaticContext(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                The negate prefix operator was used on a vector literal in a static context. <para/>
                 (in a global variable declaration expression)
            </summary>
            <param name="location">The location of the error.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.NegateOperationOnRotationLiteralInStaticContext(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                The negate prefix operator was used on a rotation literal in a static context. <para/>
                (in a global variable declaration expression)
            </summary>
            <param name="location">The location of the error.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.CastExpressionInStaticContext(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                A cast expression was used inside of a static context. <para/>
                (in a global variable declaration expression)
            </summary>
            <param name="location">The location of the error.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.AssignmentToNonassignableExpression(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String)">
            <summary>
                Occurs with an expression that is left of an assignment type operator is not assignable.
                This includes compound assignment operators such as: += ... <para/>
                This error occurs only for left expressions that are not library constants.
                There is a separate error for library constants, see <see cref="M:LibLSLCC.CodeValidator.ILSLSyntaxErrorListener.ModifiedLibraryConstant(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String)" />.
            </summary>
            <param name="location">The source code range of the assignment operator used.</param>
            <param name="assignmentOperatorUsed">The assignment operator used.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.CastOnCastExpression(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                A cast expression was used directly on another cast expression without parenthesizing the expression on the right. <para/>
                LibLSLCC's parser can handle this, but Secondlife's LSL parser cannot; it's ambiguous to it and causes a syntax error.
            </summary>
            <param name="location">The source code range of the offending cast expression.</param>
            <param name="castedExpression">The casted expression, which will be another typecast expression.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.OnError(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String)">
            <summary>
                A hook for intercepting error messages produced by the implementations of all other functions in the
                LSLDefaultSyntaxErrorListener object.
                The default behavior is to write error messages to the Console.
            </summary>
            <param name="location">Location in source code for the error.</param>
            <param name="message">The error message.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxErrorListener.MapLineNumber(System.Int32)">
            <summary>
                A hook to allow the modification of line numbers used in either the header of an error or the body.
            </summary>
            <remarks>
                <para>
                    You should pass line numbers you wish to put into customized error messages
                    through this function so that the derived class can easily offset them.
                    Line numbers reported in syntax errors default to using a 'one' based index where
                    line #1 is the first line of source code.  To modify all line numbers reported in syntax
                    errors you could overload this function and return the passed in value with some offset
                    added/subtracted.
                    For example, if you want all line number references in errors sent to OnError to have a 0 based index.
                    then you should return (oneBasedLine-1) from this function.
                </para>
            </remarks>
            <param name="oneBasedLine">
                The 'one' based line number that we might need to modify, a common modification would be to
                subtract 1 from it.
            </param>
            <returns>The possibly modified line number to use in the error message.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener">
            <summary>
                The default library implementation of <see cref="T:LibLSLCC.CodeValidator.ILSLSyntaxWarningListener" /> that can write warning
                information to an arbitrary output stream.  The default stream is standard out.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.MultipleListAssignmentsInExpression(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Warns about the occurrence of multiple list or list variable assignments occurring inside of a single expression.
            </summary>
            <remarks>
                This sort of thing was a common optimization for LSL when LSO was used instead of Mono.
                It can result in unexpected behavior in some LSL compilers such as OpenSims default compiler.
                The code generator provided with this library can handle old LSO optimizations such as this one, but it is good
                to warn about it since the optimization is completely unnecessary now days and may even make your code slower on
                Mono.
            </remarks>
            <param name="location">The location in the source code.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.MultipleStringAssignmentsInExpression(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Warns about the occurrence of multiple string or string variable assignments occurring inside of a single expression.
            </summary>
            <remarks>
                This sort of thing was a common optimization for LSL when LSO was used instead of Mono.
                It can result in unexpected behavior in some LSL compilers such as OpenSims default compiler.
                The code generator provided with this library can handle old LSO optimizations such as this one, but it is good
                to warn about it since the optimization is completely unnecessary now days and may even make your code slower on
                Mono.
            </remarks>
            <param name="location">The location in the source code.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.DeadCodeDetected(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLDeadCodeSegment)">
            <summary>
                Dead code was detected, but it was not an error because it was inside a function with a void return type.
            </summary>
            <param name="location">The location in the source code.</param>
            <param name="currentFunction">The signature of the function that dead code was detected in.</param>
            <param name="deadSegment">An object describing the range of code that is considered to be dead.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.DeadCodeDetected(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLEventSignature,LibLSLCC.CodeValidator.ILSLDeadCodeSegment)">
            <summary>
                Dead code was detected, but it was not an error because it was inside an event handler.
            </summary>
            <param name="location">The location in the source code.</param>
            <param name="currentEvent">The signature of the event handler that dead code was detected in.</param>
            <param name="deadSegment">An object describing the range of code that is considered to be dead.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.UselessSemicolon(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                An un-needed but valid semi-colon was detected in code, such as when a semi-colon is on a line by itself or
                multiple semi-colons follow an expression statement when only one is needed.
            </summary>
            <param name="location">The location in the source code.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.ExpressionStatementHasNoEffect(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                An expression statement has no effect; this can happen if you simply reference a variable as an expression statement and do nothing to it. <para/>
                As an example, referencing a counter but forgetting to add an increment or decrement operator to it would cause this. <para/>
                It will compile but it might be an error.
            </summary>
            <param name="location">The source code location of the expression statement.</param>
            <param name="statementExpression">The offending expression used as a statement.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.ForLoopAfterthoughtHasNoEffect(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode,System.Int32,System.Int32)">
            <summary>
                The expression in the 'after thought' of a for loop has no affect. <para/>
                As an example, this can happen if you forget to add an increment or decrement operator to a loop counter variable.
            </summary>
            <param name="location">The location in the source code.</param>
            <param name="expression">The offending expression.</param>
            <param name="expressionIndex">
                For loop afterthoughts can be a list of expressions to be executed, separated by commas.
                This is the index of the expression in the possible list of expressions.
                If the for loop afterthought does not use a list of expressions, this is always 0.
            </param>
            <param name="expressionCountTotal">
                The number of expressions used in the for loop afterthought expression list.
            </param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.ForLoopInitExpressionHasNoEffect(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode,System.Int32,System.Int32)">
            <summary>
                The expression in the 'init section' of a for loop has no affect, for example: If its just a variable reference.  <para/>
                As an example, this can happen if you forget to assign a starting value to a loop counter.
            </summary>
            <param name="location">The location in the source code.</param>
            <param name="expression">The offending expression.</param>
            <param name="expressionIndex">
                For loop init expressions can be a list of expressions to be executed, separated by commas.
                This is the index of the expression in the possible list of expressions.
                If the for loop init expression does not use a list of expressions, this is always 0.
            </param>
            <param name="expressionCountTotal">
                The number of expressions used in the for loop init expression list.
            </param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.RedundantCast(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLType)">
            <summary>
                A cast is considered redundant because the expression the user casted already has the same return type as the cast-to type.
            </summary>
            <param name="location">The location in the source code.</param>
            <param name="castType">The type the user attempted to cast the expression to.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.FunctionNeverUsed(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionDeclarationNode)">
            <summary>
                A user defined function was never referenced.
            </summary>
            <param name="location">The location in the source code of the function that was never referenced.</param>
            <param name="functionDeclarationNode">The function declaration node of the un-referenced function.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.GlobalVariableNeverUsed(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
            <summary>
                A user defined global variable was never referenced.
            </summary>
            <param name="location">The location in the source code of the global variable that was never referenced.</param>
            <param name="variable">The variable declaration node of the un-referenced global variable.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.LocalVariableNeverUsed(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode,LibLSLCC.CodeValidator.ILSLFunctionSignature)">
            <summary>
                A user defined local variable was never referenced.
            </summary>
            <param name="location">The location in the source code of the local variable that was never referenced.</param>
            <param name="variable">The variable declaration node of the un-referenced local variable.</param>
            <param name="inFunction">The signature of the function in which the local variable exists.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.LocalVariableNeverUsed(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode,LibLSLCC.CodeValidator.ILSLEventSignature)">
            <summary>
                A user defined local variable was never referenced.
            </summary>
            <param name="location">The location in the source code of the local variable that was never referenced.</param>
            <param name="variable">The variable declaration node of the un-referenced local variable.</param>
            <param name="inEvent">The signature of the event handler in which the local variable exists.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.FunctionParameterNeverUsed(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode,LibLSLCC.CodeValidator.ILSLFunctionSignature)">
            <summary>
                A user defined function parameter was never referenced.
            </summary>
            <param name="location">The location in the source code of the parameter that was never referenced.</param>
            <param name="parameter">The variable declaration node of the un-referenced function parameter.</param>
            <param name="inFunction">The signature of the function in which the parameter exists.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.ParameterHidesGlobalVariable(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLParameterNode,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
            <summary>
                A parameter name of a user defined function hides the definition of a global variable.
            </summary>
            <param name="location">The location in source code of the parameter that hides the global variable.</param>
            <param name="functionSignature">The function signature to which the parameter definition belongs to.</param>
            <param name="parameter">The signature of the parameter that hides the global variable.</param>
            <param name="globalVariable">The variable declaration node of the global variable that was hidden.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.ParameterHidesGlobalVariable(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLEventSignature,LibLSLCC.CodeValidator.ILSLParameterNode,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
            <summary>
                A parameter name of a library defined event handler hides the definition of a global variable.
            </summary>
            <param name="location">The location in source code of the parameter that hides the global variable.</param>
            <param name="eventHandlerSignature">The event handler signature to which the parameter definition belongs to.</param>
            <param name="parameter">The signature of the parameter that hides the global variable.</param>
            <param name="globalVariable">The variable declaration node of the global variable that was hidden.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.LocalVariableHidesParameter(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode,LibLSLCC.CodeValidator.ILSLParameterNode)">
            <summary>
                A local variable name inside of a user defined function hides the definition of one of the functions parameters.
            </summary>
            <param name="location">The location in source code of the local variable that hides the function parameter.</param>
            <param name="functionSignature">The signature of the function in which the local variable is defined.</param>
            <param name="localVariable">The variable declaration node of the local variable that hides the parameter.</param>
            <param name="parameter">The parameter node of the parameter that was hidden.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.LocalVariableHidesParameter(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLEventSignature,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode,LibLSLCC.CodeValidator.ILSLParameterNode)">
            <summary>
                A local variable name inside of a library defined event handler hides the definition of one of the event handlers
                parameters.
            </summary>
            <param name="location">The location in source code of the local variable that hides the event handler parameter.</param>
            <param name="eventHandlerSignature">The signature of the event handler in which the local variable is defined.</param>
            <param name="localVariable">The variable declaration node of the local variable that hides the parameter.</param>
            <param name="parameter">The parameter node of the parameter that was hidden.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.LocalVariableHidesGlobalVariable(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
            <summary>
                A local variable inside of a user defined function hides the definition of a user defined global variable.
            </summary>
            <param name="location">The location in source code of the local variable that hides the global variable.</param>
            <param name="functionSignature">The signature of the function in which the local variable is defined.</param>
            <param name="localVariable">The variable declaration node of the local variable that hides the global variable.</param>
            <param name="globalVariable">The variable declaration node of the user defined global variable that was hidden.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.LocalVariableHidesGlobalVariable(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLEventSignature,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
            <summary>
                A local variable inside of a library defined event handler hides the definition of a user defined global variable.
            </summary>
            <param name="location">The location in source code of the local variable that hides the global variable.</param>
            <param name="eventHandlerSignature">The parsed signature of the event handler in which the local variable is defined.</param>
            <param name="localVariable">The variable declaration node of the local variable that hides the global variable.</param>
            <param name="globalVariable">The variable declaration node of the user defined global variable that was hidden.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.UseOfDeprecatedLibraryFunction(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature)">
            <summary>
                A library function that was marked as being deprecated was used.
            </summary>
            <param name="location">The location in source code where the deprecated function was called.</param>
            <param name="functionSignature">The function signature of the deprecated library function that was called.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.UseOfDeprecatedLibraryConstant(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLConstantSignature)">
            <summary>
                A library constant that was marked as being deprecated was used.
            </summary>
            <param name="location">The location in source code where the deprecated constant was referenced.</param>
            <param name="constantSignature">The library constant signature of the deprecated constant that was referenced.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.UseOfDeprecatedLibraryEventHandler(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLEventSignature)">
            <summary>
                A library event handler that was marked as being deprecated was used.
            </summary>
            <param name="location">The location in source code where the deprecated event handler was referenced.</param>
            <param name="eventSignature">The event signature of the deprecated event handler that was referenced.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.VariableRedeclaredInInnerScope(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
            <summary>
                A local variable was re-declared inside of a nested scope, such as an if statement or for loop, ect... <para/>
                This is not an error, but bad practice. This function handles the warning case inside function declarations.
            </summary>
            <param name="location">The source code range of the new variable declaration.</param>
            <param name="currentFunctionBodySignature">The signature of the function the new variable was declared in.</param>
            <param name="newDeclarationNode">The tree node of the new declaration that has not been added to the tree yet.</param>
            <param name="previousDeclarationNode">
                The previous variable declaration node which already exist in the syntax tree, in
                an outer scope.
            </param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.VariableRedeclaredInInnerScope(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLEventSignature,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
            <summary>
                A local variable was re-declared inside of a nested scope, such as an if statement or for loop, ect... <para/>
                This is not an error, but bad practice.  This function handles the warning case inside event handlers.
            </summary>
            <param name="location">The source code range of the new variable declaration.</param>
            <param name="currentEventBodySignature">The signature of the event handler the new variable was declared in.</param>
            <param name="newDeclarationNode">The tree node of the new declaration that has not been added to the tree yet.</param>
            <param name="previousDeclarationNode">
                The previous variable declaration node which already exist in the syntax tree, in
                an outer scope.
            </param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.IntegerLiteralOverflow(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String,System.Boolean)">
            <summary>
                Occurs when an integer literal present in the source code is greater than the max value of a 32 bit LSL integer.
            </summary>
            <param name="location">The source code range of the integer literal.</param>
            <param name="literalText">The text representing the integer literal.</param>
            <param name="negated">Whether or not a negate operator was applied to the integer literal.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.IntegerLiteralUnderflow(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String,System.Boolean)">
            <summary>
                Occurs when an integer literal present in the source code is less than the minimum value of a 32 bit LSL integer.
            </summary>
            <param name="location">The source code range of the integer literal.</param>
            <param name="literalText">The text representing the integer literal.</param>
            <param name="negated">Whether or not a negate operator was applied to the integer literal.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.HexLiteralOverflow(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String,System.Boolean)">
            <summary>
                Occurs when a hex literal present in the source code is greater than the max value of a 32 bit LSL integer.
            </summary>
            <param name="location">The source code range of the hex literal.</param>
            <param name="literalText">The text representing the hex literal.</param>
            <param name="negated">Whether or not a negate operator was applied to the hex literal.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.HexLiteralUnderflow(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String,System.Boolean)">
            <summary>
                Occurs when a hex literal present in the source code is less than the minimum value of a 32 bit LSL integer.
            </summary>
            <param name="location">The source code range of the hex literal.</param>
            <param name="literalText">The text representing the hex literal.</param>
            <param name="negated">Whether or not a negate operator was applied to the hex literal.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.ReturnedValueFromEventHandler(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLEventSignature,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode)">
            <summary>
                Occurs when a return value inside of an event handler returns an expression instead of nothing.  <para/>
                The return value of the expression is simply discarded in this case.
            </summary>
            <param name="location">The location.</param>
            <param name="eventSignature">The signature of the event handler this warning occurred in.</param>
            <param name="returnExpression">The return expression.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.FloatLiteralUnderflow(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String,System.Boolean)">
            <summary>
                Occurs when an float literal present in the source code is greater than the max value of a 32 bit LSL float.
            </summary>
            <param name="location">The source code range of the float literal.</param>
            <param name="literalText">The text representing the float literal.</param>
            <param name="negated">Whether or not a negate operator was applied to the float literal.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.FloatLiteralOverflow(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String,System.Boolean)">
            <summary>
                Occurs when an float literal present in the source code is less than the minimum value of a 32 bit LSL float.
            </summary>
            <param name="location">The source code range of the float literal.</param>
            <param name="literalText">The text representing the float literal.</param>
            <param name="negated">Whether or not a negate operator was applied to the float literal.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.ConditionalExpressionIsConstant(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.ILSLReadOnlyExprNode,LibLSLCC.CodeValidator.LSLConditionalStatementType)">
            <summary>
                A constant value was used for the conditional expression in a control or loop statement.
            </summary>
            <param name="location">The location in the source code.</param>
            <param name="expression">The offending expression.</param>
            <param name="conditionalStatementType">The type of conditional statement the expression was used in.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.MapLineNumber(System.Int32)">
            <summary>
                A hook to allow the modification of line numbers used in either the header of a warning or the body.
            </summary>
            <remarks>
                <para>
                    You should pass line numbers you wish to put into customized error messages
                    through this function so that the derived class can easily offset them.
                    Line numbers reported in syntax warnings default to using a 'one' based index where
                    line #1 is the first line of source code.  To modify all line numbers reported in syntax
                    warnings you could overload this function and return the passed in value with some offset
                    added/subtracted.
                    For example, if you want all line number references in warnings sent to OnWarning to have a 0 based index.
                    then you should return (oneBasedLine-1) from this function.
                </para>
            </remarks>
            <param name="oneBasedLine">
                The 'one' based line number that we might need to modify, a common modification would be to
                subtract 1 from it.
            </param>
            <returns>The possibly modified line number to use in the warning message.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDefaultSyntaxWarningListener.OnWarning(LibLSLCC.CodeValidator.LSLSourceCodeRange,System.String)">
            <summary>
                A hook for intercepting warning messages produced by the implementations of all other functions in the
                LSLDefaultSyntaxWarningListener object.
                The default behavior is to write error messages to the Console.
            </summary>
            <param name="location">Location in source code for the warning.</param>
            <param name="message">The warning message.</param>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLCodeScopeType">
            <summary>
                Represents a category of code scope.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLCodeScopeType.EventHandler">
            <summary>
                An event handlers code scope.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLCodeScopeType.Function">
            <summary>
                A user defined functions code scope.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLCodeScopeType.DoLoop">
            <summary>
                A Do-Loops code scope.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLCodeScopeType.WhileLoop">
            <summary>
                A While-Loops code scope.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLCodeScopeType.ForLoop">
            <summary>
                A For-Loops code scope.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLCodeScopeType.If">
            <summary>
                An If statements code scope.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLCodeScopeType.ElseIf">
            <summary>
                An Else-If statements code scope.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLCodeScopeType.Else">
            <summary>
                An Else statements code scope.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLCodeScopeType.AnonymousBlock">
            <summary>
                An anonymous code scope defined inside of another code scope.
                Basically a matching pare of curly braces inside of another code scope that does not associate with any control
                statement.
                This is sometimes used to create an anonymous new scope for local variables.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLType">
            <summary>
                Represents the basic types in LSL
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLType.Key">
            <summary>
                LSL type key
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLType.Integer">
            <summary>
                LSL type integer
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLType.String">
            <summary>
                LSL type string
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLType.Float">
            <summary>
                LSL type float
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLType.List">
            <summary>
                LSL type list
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLType.Vector">
            <summary>
                LSL type vector
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLType.Rotation">
            <summary>
                LSL type rotation
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLType.Void">
            <summary>
                LSL type void (symbolic)
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLTypeTools">
            <summary>
                Extensions for converting <see cref="T:LibLSLCC.CodeValidator.LSLType" />'s to strings and also parsing them.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLTypeTools.FromLSLTypeName(System.String)">
            <summary>
                Convert an LSL type name into an <see cref="T:LibLSLCC.CodeValidator.LSLType" /> representation (case insensitive).  "void" is not
                recognized.
            </summary>
            <param name="typeName">LSL Type name as string.</param>
            <returns>An <see cref="T:LibLSLCC.CodeValidator.LSLType" /> representation of the name passed to <paramref name="typeName" />.</returns>
            <exception cref="T:System.ArgumentException">If <paramref name="typeName" /> was not recognized.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="typeName" /> was <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLTypeTools.ToLSLTypeName(LibLSLCC.CodeValidator.LSLType)">
            <summary>
                Convert an <see cref="T:LibLSLCC.CodeValidator.LSLType" /> to an LSL type name string.
            </summary>
            <param name="type"><see cref="T:LibLSLCC.CodeValidator.LSLType" /> to convert.</param>
            <returns>LSL type string representation.</returns>
            <exception cref="T:System.ArgumentException">If <see cref="T:LibLSLCC.CodeValidator.LSLType" /> is <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" />.</exception>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLExpressionType">
            <summary>
                Represents the expression type of an <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlyExprNode" /> object
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionType.Literal">
            <summary>
                A literal node, such as a string literal, vector literal, rotation literal or list literal
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionType.LibraryFunction">
            <summary>
                A node that is a call to a library function.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionType.LibraryConstant">
            <summary>
                A node that is a reference to a library constant.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionType.UserFunction">
            <summary>
                A node that is a reference to a user defined function.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionType.LocalVariable">
            <summary>
                A node that is a reference to a local variable.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionType.ParameterVariable">
            <summary>
                A node that is a reference to a function or event handler parameter.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionType.GlobalVariable">
            <summary>
                A node that is a reference to a global variable.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionType.VectorComponentAccess">
            <summary>
                A node that represents a vector component access expression on a vector variable.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionType.RotationComponentAccess">
            <summary>
                A node that represents a rotation component access expression on a rotation variable.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionType.BinaryExpression">
            <summary>
                A node that represents a binary expression.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionType.PostfixExpression">
            <summary>
                A node that represents a postfix expression such as a postfix increment or decrement.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionType.PrefixExpression">
            <summary>
                A node that represents a prefix expression such as a prefix increment or decrement.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionType.TypecastExpression">
            <summary>
                A node that represents a typecast expression.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLExpressionType.ParenthesizedExpression">
            <summary>
                A node that represents a parenthesized expression containing sub expressions.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLRotationComponent">
            <summary>
                Enum representing LSL's rotation type components
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLRotationComponent.X">
            <summary>
                X Quaternion Component.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLRotationComponent.Y">
            <summary>
                Y Quaternion Component.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLRotationComponent.Z">
            <summary>
                Z Quaternion Component.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLRotationComponent.S">
            <summary>
                S Quaternion Component.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLRotationComponentTools">
            <summary>
                Extensions for <see cref="T:LibLSLCC.CodeValidator.LSLRotationComponent" />. Used to convert the component enum into a name, or parse it
                from a string.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLRotationComponentTools.ToComponentName(LibLSLCC.CodeValidator.LSLRotationComponent)">
            <summary>
                Convert the component into a string that would be valid to use as a component reference in actual LSL code.
            </summary>
            <param name="component">The component to convert to a string.</param>
            <returns>The lowercase name of the component from the enum.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLRotationComponentTools.ParseComponentName(System.String)">
            <summary>
                Converts a string into an <see cref="T:LibLSLCC.CodeValidator.LSLRotationComponent" />.
            </summary>
            <param name="name">The name of the component ("x", "y", "z" or "s").</param>
            <exception cref="T:System.ArgumentException">Thrown if 'name' was not: "x", "y", "z" or "s"</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if 'name' is <c>null</c>.</exception>
            <returns>The corresponding <see cref="T:LibLSLCC.CodeValidator.LSLRotationComponent" /> for <paramref name="name"/>.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLVariableScope">
            <summary>
                Represents where a variable has been defined
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLVariableScope.Local">
            <summary>
                Variable defined in local scope, such as in a function or event handler.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLVariableScope.Global">
            <summary>
                Variable defined in the outermost global scope.  IE, a global variable.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLVectorComponent">
            <summary>
                Enum representing LSL's vector type components
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLVectorComponent.X">
            <summary>
                X Axis Component
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLVectorComponent.Y">
            <summary>
                Y Axis Component
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLVectorComponent.Z">
            <summary>
                Z Axis Component
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLVectorComponentTools">
            <summary>
                <see cref="T:LibLSLCC.CodeValidator.LSLVectorComponent" /> extension methods for converting the <see cref="T:LibLSLCC.CodeValidator.LSLVectorComponent" /> into a
                properly formed string and back.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVectorComponentTools.ToComponentName(LibLSLCC.CodeValidator.LSLVectorComponent)">
            <summary>
                Converts the <see cref="T:LibLSLCC.CodeValidator.LSLVectorComponent" /> into a name reference that could be used on the right side of the
                dot operator in LSL.
            </summary>
            <param name="component">The component to convert to a string.</param>
            <returns>The lowercase name of the component from the enum.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVectorComponentTools.ParseComponentName(System.String)">
            <summary>
                Converts a string into an <see cref="T:LibLSLCC.CodeValidator.LSLVectorComponent" />.
            </summary>
            <param name="name">The name of the component ("x", "y" or "z").</param>
            <exception cref="T:System.ArgumentNullException">Thrown if 'name' is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">Thrown if 'name' is not one of: "x", "y" or "z".  (Case Sensitive)</exception>
            <returns>The corresponding <see cref="T:LibLSLCC.CodeValidator.LSLVectorComponent" /> for <paramref name="name"/>.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLCodeValidatorInternalException">
            <summary>
                Thrown when <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" /> experiences an un-expected exception.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidatorInternalException.#ctor">
            <summary>
                Default constructor.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidatorInternalException.#ctor(System.String)">
            <summary>
                Construct with message.
            </summary>
            <param name="message">Exception message.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidatorInternalException.#ctor(System.String,System.Exception)">
            <summary>
                Construct with message and inner exception.
            </summary>
            <param name="message">Exception message.</param>
            <param name="inner">Inner exception.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidatorInternalException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Serializable constructor.
            </summary>
            <param name="info">SerializationInfo.</param>
            <param name="context">StreamingContext.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidatorInternalException.VisitContextInvalidState(System.String,System.Boolean)">
            <summary>
                Constructs a typical exception for an invalid ANTLR parser context state during an ANTLR tree visit.
            </summary>
            <param name="visitFunctionName">The name of the function the exception is going to be thrown from.</param>
            <param name="prePass">Whether or not this exception was thrown in the pre-compile pass over the source code.</param>
            <returns>The constructed exception object.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidatorInternalException.VisitContextInInvalidState(System.String,System.Reflection.MemberInfo,System.Boolean)">
            <summary>
                Constructs a typical exception for an invalid ANTLR parser context state during an ANTLR tree visit.
            </summary>
            <param name="visitFunctionName">The name of the function the exception is going to be thrown from.</param>
            <param name="contextType">The type of the ANTLR context being visited.</param>
            <param name="prePass">Whether or not this exception was thrown in the pre-compile pass over the source code.</param>
            <returns>The constructed exception object.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidatorInternalException.VisitReturnTypeException(System.String,System.Reflection.MemberInfo)">
            <summary>
                Constructs a typical exception for an invalid return type from an ANTLR parser visitor function.
            </summary>
            <param name="visitFunctionName">The visitor function the exception is going to be thrown from.</param>
            <param name="expectedReturnType">
                The expected return type of the visitor function which did not meet the return type
                expectation.
            </param>
            <returns></returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLComment">
            <summary>
                A container for LSL source code comment strings.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLComment.Equals(LibLSLCC.CodeValidator.LSLComment)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLComment.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            true if <paramref name="obj"/> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
            <param name="obj">Another object to compare to. </param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLComment.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLComment.op_Equality(LibLSLCC.CodeValidator.LSLComment,LibLSLCC.CodeValidator.LSLComment)">
            <summary>
            Compare comments for equality.
            </summary>
            <param name="left">The comment object on the left.</param>
            <param name="right">The comment object on the right.</param>
            <returns><c>true</c> if equal.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLComment.op_Inequality(LibLSLCC.CodeValidator.LSLComment,LibLSLCC.CodeValidator.LSLComment)">
            <summary>
            Compare comments for inequality.
            </summary>
            <param name="left">The comment object on the left.</param>
            <param name="right">The comment object on the right.</param>
            <returns><c>true</c> if inequal.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLComment.#ctor(System.String,LibLSLCC.CodeValidator.LSLCommentType,LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Construct a comment object from comment text, type and source code range.
            </summary>
            <param name="text">The text that up the entire comment, including the special comment start/end sequences.</param>
            <param name="type">The comment type.  <see cref="T:LibLSLCC.CodeValidator.LSLCommentType" /></param>
            <param name="sourceRange">The source code range that the comment occupies.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="text"/> or <paramref name="sourceRange"/> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLComment.Text">
            <summary>
                The raw comment text.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLComment.SourceRange">
            <summary>
                The source code range which the comment occupies.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLComment.Type">
            <summary>
                The LSLCommentType type of the comment.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLComment.ToString">
            <summary>
                Returns the comment text.
            </summary>
            <seealso cref="P:LibLSLCC.CodeValidator.LSLComment.Text" />
            <returns>
                <see cref="P:LibLSLCC.CodeValidator.LSLComment.Text" />
            </returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLEventSignature">
            <summary>
                Represents a basic event handler call signature.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLEventSignature.#ctor(LibLSLCC.CodeValidator.ILSLEventSignature)">
            <summary>
                Construct an event signature by cloning another <see cref="T:LibLSLCC.CodeValidator.ILSLEventSignature" /> object.
            </summary>
            <param name="other">The  <see cref="T:LibLSLCC.CodeValidator.ILSLEventSignature" /> to copy construct from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLEventSignature.#ctor">
            <summary>
                Construct and empty event signature, can only be used by derived classes.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLEventSignature.#ctor(System.String,System.Collections.Generic.IEnumerable{LibLSLCC.CodeValidator.LSLParameterSignature})">
            <summary>
                Construct and event signature with the provide parameters by providing a name and an enumerable containing
                <see cref="T:LibLSLCC.CodeValidator.LSLParameterSignature" /> objects.
            </summary>
            <param name="name">The name of the event signature.</param>
            <param name="parameters">The parameters to include in the signature.</param>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException">
                Thrown if the event handler name does not follow LSL symbol naming conventions.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLEventSignature.#ctor(System.String)">
            <summary>
                Construct an event signature that has no parameters by providing a name only.
            </summary>
            <param name="name">The name of the event signature.</param>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException">
                Thrown if the event handler name does not follow LSL symbol naming conventions.
            </exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLEventSignature.ParameterCount">
            <summary>
                The number of parameters the event handler signature has
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLEventSignature.Name">
            <summary>
                The event handlers name, must follow LSL symbol naming conventions
            </summary>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException" accessor="set">
                Thrown if the event handler name does not follow LSL symbol naming conventions.
            </exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLEventSignature.Parameters">
            <summary>
                Indexable list of objects describing the event handlers parameters
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLEventSignature.SignatureString">
            <summary>
                Returns a formated signature string for the <see cref="T:LibLSLCC.CodeValidator.ILSLEventSignature" />.  This does not include a trailing
                semi-colon.
                An example would be: listen(integer channel, string name, key id, string message)
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLEventSignature.ToString">
            <summary>
                Delegates to SignatureString
            </summary>
            <returns>SignatureString</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLEventSignature.SignatureMatches(LibLSLCC.CodeValidator.ILSLEventSignature)">
            <summary>
                Determines if two event handler signatures match exactly, parameter names do not matter but parameter
                types do.
            </summary>
            <param name="otherSignature">The other event handler signature to compare to.</param>
            <returns>True if the two signatures are identical.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherSignature"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLEventSignature.GetHashCode">
            <summary>
                <see cref="M:LibLSLCC.CodeValidator.LSLEventSignature.GetHashCode"/> uses the name of the <see cref="T:LibLSLCC.CodeValidator.ILSLEventSignature" /> and the LSL Types of the parameters. <para/>
                This means the Hash Code is determined by the event name, and the Types of all its parameters. <para/>
                Inherently, uniqueness is also determined by the number of parameters.
            </summary>
            <returns>Hash code for this <see cref="T:LibLSLCC.CodeValidator.ILSLEventSignature" /></returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLEventSignature.Equals(System.Object)">
            <summary>
                <see cref="M:LibLSLCC.CodeValidator.LSLEventSignature.Equals(System.Object)"/> delegates to <see cref="M:LibLSLCC.CodeValidator.ILSLEventSignature.SignatureMatches(LibLSLCC.CodeValidator.ILSLEventSignature)" />
            </summary>
            <param name="obj">The other event signature</param>
            <returns>Equality.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLEventSignature.AddParameter(LibLSLCC.CodeValidator.LSLParameterSignature)">
            <summary>
                Add an <see cref="T:LibLSLCC.CodeValidator.LSLParameterSignature" /> object to this event signatures
            </summary>
            <param name="parameterSignature">The <see cref="T:LibLSLCC.CodeValidator.LSLParameterSignature" /> object to add.</param>
            <exception cref="T:System.ArgumentException">Thrown if the added parameter is a variadic parameter.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="parameterSignature"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLEventSignature.Parse(System.String)">
            <summary>
                Attempts to parse the signature from a formated string. <para/>
                Such as:  "listen( integer channel, string name, key id, string message )" <para/>
                Trailing semi-colon is optional.
            </summary>
            <param name="str">The string to parse.</param>
            <exception cref="T:System.ArgumentException">Thrown if the string could not be parsed.</exception>
            <returns>The Parsed <see cref="T:LibLSLCC.CodeValidator.LSLEventSignature" /></returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLFunctionSignature">
            <summary>
                Represents a basic LSL function signature.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionSignature.#ctor">
            <summary>
                Construct an empty <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" />.  Only derived classes can do this.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionSignature.#ctor(LibLSLCC.CodeValidator.ILSLFunctionSignature)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" /> by cloning another <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" /> object.
            </summary>
            <param name="other">The <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" /> object to copy construct from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionSignature.#ctor(LibLSLCC.CodeValidator.LSLType,System.String,System.Collections.Generic.IEnumerable{LibLSLCC.CodeValidator.LSLParameterSignature})">
            <summary>
                Construct a function signature by providing an associated <see cref="T:LibLSLCC.CodeValidator.LSLType" /> for the return type, a function
                Name and an optional enumerable of <see cref="T:LibLSLCC.CodeValidator.LSLParameterSignature" /> objects.
            </summary>
            <param name="returnType"></param>
            <param name="name"></param>
            <param name="parameters"></param>
            <exception cref="T:System.ArgumentException">Thrown if more than one variadic parameter is added to the function signature.</exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException">
                Thrown if the function name does not follow LSL symbol naming conventions.
            </exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionSignature.ParameterCount">
            <summary>
                Returns the number of parameters the function signature has including variadic parameters.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionSignature.ConcreteParameterCount">
            <summary>
                Returns the number of non variadic parameters the function signature has.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionSignature.ReturnType">
            <summary>
                The functions LSL return type.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionSignature.Name">
            <summary>
                The functions name, must follow LSL symbol naming conventions.
            </summary>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException" accessor="set">
                Thrown if the function name does not follow LSL symbol naming conventions.
            </exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionSignature.Parameters">
            <summary>
                Indexable list of objects describing the functions parameters.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionSignature.ConcreteParameters">
            <summary>
                An enumerable of all non-variadic parameters in the function signature.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionSignature.SignatureString">
            <summary>
                Returns a formated signature string for the function signature without a trailing semi-colon. <para/>
                Such as:  float llAbs(float value) Or: modInvokeN(string fname, params any[] parms) <para/>
                The later being a function from OpenSim's modInvoke API to demonstrate variadic parameter formating. <para/>
                If a parameter is variadic and has a type that is not void, the 'any' keyword will be replaced with the corresponding name for the type.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionSignature.HasVariadicParameter">
            <summary>
                Whether or not a variadic parameter has been added to this function signature. <para/>
                There can only be one variadic parameter.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionSignature.VariadicParameterIndex">
            <summary>
                The index of the variadic parameter in the Parameters list, or -1 if none exists.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionSignature.ToString">
            <summary>
                Delegates to SignatureString.
            </summary>
            <returns>
                SignatureString
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionSignature.Parse(System.String)">
            <summary>
                Attempt to parse a function signature from a formated string.
                Such as: float llAbs(float value) or llOwnerSay(string message);
            </summary>
            <param name="str">The string containing the formated function signature.</param>
            <returns>The LSLLibraryFunctionSignature that was parsed from the string, or null.</returns>
            <exception cref="T:System.ArgumentException">If there was a syntax error while parsing the function signature.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionSignature.AddParameter(LibLSLCC.CodeValidator.LSLParameterSignature)">
            <summary>
                Add a new parameter to the function signature object
            </summary>
            <param name="parameterSignature">The <see cref="T:LibLSLCC.CodeValidator.LSLParameterSignature" /> object to add to the signature.</param>
            <exception cref="T:System.ArgumentException">Thrown if more than one variadic parameter is added to the function signature.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="parameterSignature"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionSignature.SignatureEquivalent(LibLSLCC.CodeValidator.ILSLFunctionSignature)">
            <summary>
                Determines if two function signatures match exactly (including return type), parameter names do not matter but
                parameter types do.
            </summary>
            <param name="otherSignature">The other function signature to compare to</param>
            <returns>True if the two signatures are identical</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="otherSignature"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionSignature.DefinitionIsDuplicate(LibLSLCC.CodeValidator.ILSLFunctionSignature)">
            <summary>
                Determines if a given <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" /> is a duplicate definition of this function signature. <para/>
                The logic behind this is a bit different than SignatureMatches(). <para/>
                If the given function signature has the same name, a differing return type and both functions have no parameters;
                than this function will return true
                and <see cref="M:LibLSLCC.CodeValidator.ILSLFunctionSignature.SignatureEquivalent(LibLSLCC.CodeValidator.ILSLFunctionSignature)" /> will not. <para/>
                If the other signature is an overload that is ambiguous in all cases due to variadic parameters, this function
                returns true.
            </summary>
            <remarks>
            </remarks>
            <param name="otherSignature">The other function signature to compare to</param>
            <returns>
                True if the two signatures are duplicate definitions of each other, taking static overloading ambiguities into
                account.
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionSignature.GetHashCode">
            <summary>
                <see cref="M:LibLSLCC.CodeValidator.ILSLFunctionSignature.GetHashCode"/> uses <see cref="P:LibLSLCC.CodeValidator.ILSLFunctionSignature.Name" />, <see cref="P:LibLSLCC.CodeValidator.LSLFunctionSignature.ReturnType" /> and the 
                <see cref="P:LibLSLCC.CodeValidator.LSLParameterSignature.Type" />/<see cref="P:LibLSLCC.CodeValidator.LSLParameterSignature.Variadic" /> status of the parameters. <para/>
                this means the Hash Code is linked the Function name, return Type and the Types/Variadic'ness of all its parameters. <para/>
                Inherently, uniqueness is also determined by the number of parameters.
            </summary>
            <returns>Hash code for this <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" /></returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionSignature.Equals(System.Object)">
            <summary>
                Equals(object obj) delegates to <see cref="M:LibLSLCC.CodeValidator.LSLFunctionSignature.SignatureEquivalent(LibLSLCC.CodeValidator.ILSLFunctionSignature)" />
            </summary>
            <param name="obj">The other function signature</param>
            <returns>Equality</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLFunctionSignatureRegex">
            <summary>
                Regex tools for parsing <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" /> objects from strings.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionSignatureRegex.#ctor(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
            <summary>
                Construct a function signature regex, given an enumerable of acceptable LSL types, a string 'before' that is
                prefixed to the regex, and a string 'after' that is appended to the regex.
            </summary>
            <param name="dataTypes">
                Acceptable LSL types, or other types that can appear as a return type or parameter type in the
                function signature.
            </param>
            <param name="before">The string pre-pended to the regex.</param>
            <param name="after">The string appended to the regex.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionSignatureRegex.#ctor(System.String,System.String)">
            <summary>
                Construct a function signature regex that accepts the standard LSL types for the return type and parameter types.
            </summary>
            <param name="before">The string pre-pended to the regex.</param>
            <param name="after">The string appended to the regex.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionSignatureRegex.#ctor">
            <summary>
                Construct a function signature regex that accepts the standard LSL types for the return type and parameter types.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionSignatureRegex.Regex">
            <summary>
                The function signature regex that was created upon construction.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionSignatureRegex.GetSignature(System.String)">
            <summary>
                Parse an LSLFunction signature from a string.
            </summary>
            <param name="inString">The string to parse the <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" /> from.</param>
            <returns>The parsed <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" />.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionSignatureRegex.GetSignatures(System.String)">
            <summary>
                Returns all LSLFunctionSignatures that could be parsed out of a given string.
            </summary>
            <param name="inString">The string to parse <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" /> objects from.</param>
            <returns>An enumerable of <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" /> objects that were successfully parsed from the string.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLEventSignatureRegex">
            <summary>
                Regex tools for parsing <see cref="T:LibLSLCC.CodeValidator.LSLEventSignature" /> objects from strings.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLEventSignatureRegex.#ctor(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
            <summary>
                Construct an event signature regex, given an enumerable of acceptable LSL types, a string 'before' that is prefixed
                to the regex, and a string 'after' that is appended to the regex.
            </summary>
            <param name="dataTypes">Acceptable LSL types, or other types that can appear as parameter types in the event signature.</param>
            <param name="before">The string pre-pended to the regex.</param>
            <param name="after">The string appended to the regex.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLEventSignatureRegex.#ctor(System.String,System.String)">
            <summary>
                Construct a event signature regex that accepts the standard LSL types for the parameter types.
            </summary>
            <param name="before">The string pre-pended to the regex.</param>
            <param name="after">The string appended to the regex.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLEventSignatureRegex.#ctor">
            <summary>
                Construct a event signature regex that accepts the standard LSL types for the parameter types.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLEventSignatureRegex.Regex">
            <summary>
                The event signature regex that was created upon the construction of this object
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLEventSignatureRegex.GetSignature(System.String)">
            <summary>
                Parse an <see cref="T:LibLSLCC.CodeValidator.LSLEventSignature" /> signature from a string.
            </summary>
            <param name="inString">The string to parse the <see cref="T:LibLSLCC.CodeValidator.LSLEventSignature" /> from.</param>
            <returns>The parsed <see cref="T:LibLSLCC.CodeValidator.LSLEventSignature" />.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLEventSignatureRegex.GetSignatures(System.String)">
            <summary>
                Returns all <see cref="T:LibLSLCC.CodeValidator.LSLEventSignature" /> that could be parsed out of a given string.
            </summary>
            <param name="inString">The string to parse <see cref="T:LibLSLCC.CodeValidator.LSLEventSignature" /> objects from.</param>
            <returns>An enumerable of <see cref="T:LibLSLCC.CodeValidator.LSLEventSignature" /> objects that were successfully parsed from the string.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLParameterSignature">
            <summary>
                Represents a basic parameter that belongs to either an event handler or function signature.
            </summary>
            <remarks>Immutable.</remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParameterSignature.#ctor(LibLSLCC.CodeValidator.LSLType,System.String,System.Boolean,System.Int32)">
            <summary>
                Construct a parameter signature object.
            </summary>
            <param name="type">The parameter type</param>
            <param name="name">The parameter name</param>
            <param name="variadic">Is the parameter variadic</param>
            <param name="parameterIndex">The parameter index.</param>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException">
                Thrown if the parameter name does not follow LSL symbol naming
                conventions for parameters.
            </exception>
            <exception cref="T:System.ArgumentException">Thrown if type is <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" /> and variadic is false.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParameterSignature.#ctor(LibLSLCC.CodeValidator.LSLType,System.String,System.Boolean)">
            <summary>
                Construct a prototype parameter signature object without a parameter index.
            </summary>
            <param name="type">The parameter type</param>
            <param name="name">The parameter name</param>
            <param name="variadic">Is the parameter variadic</param>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException">
                Thrown if the parameter name does not follow LSL symbol naming
                conventions for parameters.
            </exception>
            <exception cref="T:System.ArgumentException">Thrown if type is <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" /> and variadic is false.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParameterSignature.#ctor(LibLSLCC.CodeValidator.LSLParameterSignature,System.Int32)">
            <summary>
                Construct a prototype parameter signature object by cloning another and giving it the specified index.
            </summary>
            <param name="other">The parameter signature to clone from.</param>
            <param name="parameterIndex">The parameter index.</param>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException">
                Thrown if the parameter name does not follow LSL symbol naming
                conventions for parameters.
            </exception>
            <exception cref="T:System.ArgumentException">Thrown if type is <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" /> and variadic is false.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParameterSignature.Name">
            <summary>
                Name of the parameter
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParameterSignature.Variadic">
            <summary>
                Does this parameter represent a variadic place holder
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParameterSignature.Type">
            <summary>
                The parameter type
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParameterSignature.ParameterIndex">
            <summary>
                The parameter index, which gets set when the parameter is added to an <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" /> or
                <see cref="T:LibLSLCC.CodeValidator.LSLEventSignature" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParameterSignature.SignatureString">
            <summary>
                Returns the signature string of the parameter.
                If the parameter is not variadic, then the signature is simply the type name followed by the parameter name,
                separated with a space.
                Otherwise if the parameter is variadic, it will be formated as:  params any[] parameter_name
                If the variadic parameter actually has a type, the 'any' keyword will be replaced with the name of that type.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParameterSignature.GetHashCode">
            <summary>
                Returns a hash code for the <see cref="T:LibLSLCC.CodeValidator.LSLParameterSignature" /> object.
                The hash code is generated from the parameter Type, Name, ParameterIndex and Variadic status.
            </summary>
            <returns>The generated hash code.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParameterSignature.Equals(System.Object)">
            <summary>
                Determines if the <see cref="P:LibLSLCC.CodeValidator.LSLParameterSignature.Type" />, <see cref="P:LibLSLCC.CodeValidator.LSLParameterSignature.Name" />, <see cref="P:LibLSLCC.CodeValidator.LSLParameterSignature.ParameterIndex" /> and
                <see cref="P:LibLSLCC.CodeValidator.LSLParameterSignature.Variadic" /> status are of equal values in another <see cref="T:LibLSLCC.CodeValidator.LSLParameterSignature" /> object.
                If obj is not actually an <see cref="T:LibLSLCC.CodeValidator.LSLParameterSignature" /> object, or derived from one, than this function will always
                return false.
            </summary>
            <param name="obj">The <see cref="T:LibLSLCC.CodeValidator.LSLParameterSignature" /> object to compare this one to.</param>
            <returns>
                True if 'obj' is an <see cref="T:LibLSLCC.CodeValidator.LSLParameterSignature" /> object or derived type; And <see cref="P:LibLSLCC.CodeValidator.LSLParameterSignature.Type" />,
                <see cref="P:LibLSLCC.CodeValidator.LSLParameterSignature.Name" />, <see cref="P:LibLSLCC.CodeValidator.LSLParameterSignature.ParameterIndex" /> and <see cref="P:LibLSLCC.CodeValidator.LSLParameterSignature.Variadic" /> status are of equal values in both
                objects.
            </returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLParsedEventHandlerSignature">
            <summary>
                Represents and event handler signature parsed from source code.
                This object derives from <see cref="T:LibLSLCC.CodeValidator.LSLEventSignature" /> and adds an <see cref="T:LibLSLCC.CodeValidator.LSLParameterListNode" />
                property that contains a parameter list node from the syntax tree.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParsedEventHandlerSignature.#ctor(System.String,LibLSLCC.CodeValidator.LSLParameterListNode)">
            <summary>
                Construct an  <see cref="T:LibLSLCC.CodeValidator.LSLParsedEventHandlerSignature" /> from an event handler name and a
                <see cref="T:LibLSLCC.CodeValidator.LSLParameterListNode" /> from
                an LSL Syntax tree.
            </summary>
            <param name="name">The name of the event handler.</param>
            <param name="parameters">
                The <see cref="T:LibLSLCC.CodeValidator.LSLParameterListNode" /> from the syntax tree that represents the event
                handlers parsed parameters.
            </param>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParsedEventHandlerSignature.ParameterListNode">
            <summary>
                A parameter list node from an LSL syntax tree that represents this event handler signatures parameters.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLPreDefinedFunctionSignature">
            <summary>
                Represents a function signature that was parsed during the pre-pass that occurs during code validation.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLPreDefinedFunctionSignature.#ctor(LibLSLCC.CodeValidator.LSLType,System.String,LibLSLCC.CodeValidator.LSLParameterListNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLPreDefinedFunctionSignature" /> from an <see cref="T:LibLSLCC.CodeValidator.LSLType" /> representing the return
                type, a function name and an <see cref="T:LibLSLCC.CodeValidator.LSLParameterListNode" />
                from an LSL Syntax tree.
            </summary>
            <param name="returnType">The return type of the function signature.</param>
            <param name="name">The name of the function.</param>
            <param name="parameters">
                The <see cref="T:LibLSLCC.CodeValidator.LSLParameterListNode" /> from an LSL syntax tree that represents the function
                signatures parameters.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="parameters"/> is <see langword="null" />.</exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException">
                Thrown if the function name does not follow LSL symbol naming conventions.
            </exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPreDefinedFunctionSignature.ParameterListNode">
            <summary>
                The LSLParameterListNOde from an LSL syntax tree the represents the function signatures parameters.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPreDefinedFunctionSignature.DefinitionNode">
            <summary>
                The <see cref="T:LibLSLCC.CodeValidator.LSLFunctionDeclarationNode" /> in the syntax tree that this function signature belongs
                to/represents.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLPreDefinedFunctionSignature.GiveDefinition(LibLSLCC.CodeValidator.LSLFunctionDeclarationNode)">
            <summary>
                Internal method that sets the DefinitionNode property, this method is named this way to bring clarity to the source
                code where it is used.
            </summary>
            <param name="definition"></param>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLBinaryExpressionNode">
            <summary>
                AST interface for binary expression nodes.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLBinaryExpressionNode.Operation">
            <summary>
                The binary operation type of this node.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLBinaryExpressionNode.OperationString">
            <summary>
                The string representation of the binary operation this node preforms.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLBinaryExpressionNode.LeftExpression">
            <summary>
                The expression tree on the left of side of the binary operation.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLBinaryExpressionNode.RightExpression">
            <summary>
                The expression tree on the right side of the binary operation.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLBinaryExpressionNode.SourceRangeOperation">
            <summary>
                The source code range that encompasses the binary expression and its children.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLExpressionListNode">
            <summary>
                AST node interface for expression list, such as function call parameters, for loop init sections/afterthoughts,
                list initializers ect.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLExpressionListNode.ListType">
            <summary>
                The type of expression list this node represents.
                <see cref="T:LibLSLCC.CodeValidator.LSLExpressionListType" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLExpressionListNode.Expressions">
            <summary>
                A list of expression nodes that belong to this expression list in order of appearance, or an empty list.  <para/>
                This will never be <c>null</c>.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLExpressionListNode.SourceRangeCommaList">
            <summary>
                The source code range for each comma separator that appears in the expression list in order, or an empty list.  <para/>
                This will never be <c>null</c>.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLExprNode">
            <summary>
                AST base interface for syntax tree expression nodes.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLExprNode.Clone">
            <summary>
                Deep clones the expression node.  It should clone the node and all of its children and cloneable properties, except
                the parent.
                When cloned, the parent node reference should be left <c>null</c>.
            </summary>
            <returns>A deep clone of this expression tree node.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLFloatLiteralNode">
            <summary>
                AST token interface for float literals.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFloatLiteralNode.RawText">
            <summary>
                The raw text from the source code representing the float literal token.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLFunctionCallNode">
            <summary>
                AST node interface for function call expression nodes.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionCallNode.Name">
            <summary>
                The name of the function that was called.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionCallNode.Signature">
            <summary>
                The function signature of the function that was called, as it was defined by either the user or library.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionCallNode.ArgumentExpressionList">
            <summary>
                The parameter list node containing the expressions used to call this function, this will never be null even if the
                parameter list is empty.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionCallNode.Definition">
            <summary>
                The syntax tree node where the function was defined if it is a user defined function.  If the function call is to a
                library function this will be null.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionCallNode.IsLibraryFunctionCall">
            <summary>
                True if the function that was called is a library function call, false if it was a call to a user defined function.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionCallNode.SourceRangeOpenParenth">
            <summary>
                The source code range of the opening parentheses where the parameters of the function start.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionCallNode.SourceRangeCloseParenth">
            <summary>
                The source code range of the closing parentheses where the parameters of the function end.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionCallNode.SourceRangeName">
            <summary>
                The source code range of the function name in the function call expression.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLHexLiteralNode">
            <summary>
                AST token interface for HEX literal nodes.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLHexLiteralNode.RawText">
            <summary>
                The raw source code text that defines the HEX literal.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLIntegerLiteralNode">
            <summary>
                AST token interface for integer literal nodes.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLIntegerLiteralNode.RawText">
            <summary>
                The raw source code text that defines the integer literal.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLListLiteralNode">
            <summary>
                AST node interface for list literal nodes.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLListLiteralNode.ExpressionList">
            <summary>
                The expression list node that contains all of the expressions used to initialize the list literal.
                This will never be null, even when the list literal was defined as being empty.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLListLiteralNode.SourceRangeOpenBracket">
            <summary>
                The source code range of the list literals opening bracket.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLListLiteralNode.SourceRangeCloseBracket">
            <summary>
                The source code range of the list literals closing bracket.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLParenthesizedExpressionNode">
            <summary>
                AST node interface for parenthesized expressions.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLParenthesizedExpressionNode.InnerExpression">
            <summary>
                The expression node contained within the parenthesis, this should never be null.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLParenthesizedExpressionNode.SourceRangeOpenParenth">
            <summary>
                The source code range of the opening parenthesis in the parenthesized expression.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLParenthesizedExpressionNode.SourceRangeCloseParenth">
            <summary>
                The source code range of the closing parenthesis in the parenthesized expression.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLPostfixOperationNode">
            <summary>
                AST node interface for postfix operations on an expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLPostfixOperationNode.Operation">
            <summary>
                The postfix operation type preformed on the expression.
                <see cref="T:LibLSLCC.CodeValidator.LSLPostfixOperationType" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLPostfixOperationNode.OperationString">
            <summary>
                The postfix operation string taken from the source code.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLPostfixOperationNode.LeftExpression">
            <summary>
                The expression that is left of the postfix operator, this should never be null.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLPostfixOperationNode.SourceRangeOperation">
            <summary>
                The source code range the postfix operator occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLPrefixOperationNode">
            <summary>
                AST node interface for prefix operations on an expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLPrefixOperationNode.Operation">
            <summary>
                The prefix operation type preformed on the expression.
                <see cref="T:LibLSLCC.CodeValidator.LSLPrefixOperationType" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLPrefixOperationNode.OperationString">
            <summary>
                The prefix operation string taken from the source code.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLPrefixOperationNode.RightExpression">
            <summary>
                The expression that is right of the prefix operator, this should never be null.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLPrefixOperationNode.SourceRangeOperation">
            <summary>
                The source code range the prefix operator occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLReadOnlyExprNode">
            <summary>
                AST node read only interface for expression nodes.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLReadOnlyExprNode.Type">
            <summary>
                The return type of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLType" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLReadOnlyExprNode.ExpressionType">
            <summary>
                The expression type/classification of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLExpressionType" />
            </summary>
            <value>
                The type of the expression.
            </value>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLReadOnlyExprNode.IsConstant">
            <summary>
                True if the expression is constant and can be calculated at compile time.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLReadOnlyExprNode.HasPossibleSideEffects">
            <summary>
                True if the expression has some modifying effect on a local parameter or global/local variable;  or is a function
                call.  False otherwise.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLReadOnlyExprNode.DescribeType">
            <summary>
                Should produce a user friendly description of the expressions return type. <para/>
                This is used in some syntax error messages, Ideally you should enclose your description in
                parenthesis or something that will make it stand out in a string.
            </summary>
            <returns>A use friendly description of the node's <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlyExprNode.Type"/>.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLReadOnlyExprNode.Clone">
            <summary>
                Deep clones the expression node.  It should clone the node and all of its children and cloneable properties, except
                the parent.
                When cloned, the parent node reference should still point to the same node.
            </summary>
            <returns>A deep clone of this expression node.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLRotationLiteralNode">
            <summary>
                AST node interface for rotation literal nodes.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLRotationLiteralNode.SourceRangeOpenBracket">
            <summary>
                The source code range of the opening '&lt;' bracket of the rotation literal.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLRotationLiteralNode.SourceRangeCloseBracket">
            <summary>
                The source code range of the closing '&gt;' bracket of the rotation literal.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLRotationLiteralNode.XExpression">
            <summary>
                The expression node used to initialize the X (first) Component of the rotation literal.
                This should never be null.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLRotationLiteralNode.SourceRangeCommaOne">
            <summary>
                The source code range of the first component separator comma to appear in the rotation literal.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLRotationLiteralNode.YExpression">
            <summary>
                The expression node used to initialize the Y (second) Component of the rotation literal.
                This should never be null.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLRotationLiteralNode.SourceRangeCommaTwo">
            <summary>
                The source code range of the second component separator comma to appear in the rotation literal.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLRotationLiteralNode.ZExpression">
            <summary>
                The expression node used to initialize the Z (third) Component of the rotation literal.
                This should never be null.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLRotationLiteralNode.SourceRangeCommaThree">
            <summary>
                The source code range of the third component separator comma to appear in the rotation literal.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLRotationLiteralNode.SExpression">
            <summary>
                The expression node used to initialize the S (fourth) Component of the rotation literal.
                This should never be null.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLStringLiteralNode">
            <summary>
                AST token interface for string literal nodes.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLStringLiteralNode.PreProcessedText">
            <summary>
                The pre-processed text of the string literal.
                <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" /> relies on an implementation of <see cref="T:LibLSLCC.CodeValidator.ILSLStringPreProcessor" /> to fill this
                value out by passing <see cref="T:LibLSLCC.CodeValidator.ILSLStringPreProcessor" />
                the raw text for the string literal and assigning the string it produces to this property.
                <see cref="T:LibLSLCC.CodeValidator.ILSLStringPreProcessor" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLStringLiteralNode.RawText">
            <summary>
                The raw text for the string literal from the source code, this should include the quote characters that surround
                the string.
                Any escape codes used in the source code string should be double escaped.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLTupleAccessorNode">
            <summary>
                AST node interface for the '.' member access operator expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLTupleAccessorNode.AccessedComponent">
            <summary>
                The raw name of the accessed tuple component, taken from the source code.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLTupleAccessorNode.SourceRangeAccessedComponent">
            <summary>
                The source code range of the tuple component that was accessed.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLTupleAccessorNode.AccessedExpression">
            <summary>
                The expression that the member access operator was used on.
                This should only ever be a reference to a vector or rotation variable.
                Using a member accessor on a constant, even if it is a vector or rotation, is not allowed.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLTypecastExprNode">
            <summary>
                AST node interface for typecast expressions.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLTypecastExprNode.CastedExpression">
            <summary>
                The expression node that represents the expression being casted.  This should never be null.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLTypecastExprNode.CastToType">
            <summary>
                The <see cref="T:LibLSLCC.CodeValidator.LSLType" /> that represents the type the expression is being cast to.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLTypecastExprNode.CastToTypeName">
            <summary>
                The raw type name of the type the expression is being cast to, taken from the source code.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLTypecastExprNode.SourceRangeCloseParenth">
            <summary>
                The source code range of the closing parenthesis of the enclosed cast type.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLTypecastExprNode.SourceRangeOpenParenth">
            <summary>
                The source code range of the open parenthesis of the enclosed cast type.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLTypecastExprNode.SourceRangeCastToType">
            <summary>
                The source code range of the type name used for the cast.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLVariableNode">
            <summary>
                AST node interface for variable references.
                An <see cref="T:LibLSLCC.CodeValidator.ILSLVariableNode" /> is also created as a child of an <see cref="T:LibLSLCC.CodeValidator.ILSLVariableDeclarationNode" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVariableNode.IsLibraryConstant">
            <summary>
                True if this variable node references a library constant, False if it references a user defined variable or
                parameter.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVariableNode.IsGlobal">
            <summary>
                True if this variable node references a user defined global variable.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVariableNode.IsLocal">
            <summary>
                True if this variable node references a user defined local variable.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVariableNode.IsParameter">
            <summary>
                True if this variable node references a function or event handler parameter.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVariableNode.Declaration">
            <summary>
                A reference to the <see cref="T:LibLSLCC.CodeValidator.ILSLVariableDeclarationNode" /> in the syntax tree where this variable was initially
                declared.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVariableNode.TypeName">
            <summary>
                The raw type string describing the type of the variable referenced.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVariableNode.Name">
            <summary>
                The name of the referenced variable.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLVectorLiteralNode">
            <summary>
                AST node interface for vector literal nodes.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVectorLiteralNode.SourceRangeOpenBracket">
            <summary>
                The source code range of the opening '&lt;' bracket of the vector literal.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVectorLiteralNode.SourceRangeCloseBracket">
            <summary>
                The source code range of the closing '&gt;' bracket of the vector literal.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVectorLiteralNode.XExpression">
            <summary>
                The expression node used to initialize the X Axis Component of the vector literal.
                This should never be null.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVectorLiteralNode.SourceRangeCommaOne">
            <summary>
                The source code range of the first component separator comma to appear in the vector literal.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVectorLiteralNode.YExpression">
            <summary>
                The expression node used to initialize the Y Axis Component of the vector literal.
                This should never be null.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVectorLiteralNode.SourceRangeCommaTwo">
            <summary>
                The source code range of the second component separator comma to appear in the vector literal.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVectorLiteralNode.ZExpression">
            <summary>
                The expression node used to initialize the Z Axis Component of the vector literal.
                This should never be null.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLBinaryExpressionNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLBinaryExpressionNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLBinaryExpressionNode.#ctor(LibLSLCC.CodeValidator.LSLBinaryExpressionNode)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLBinaryExpressionNode" /> by cloning from another.
            </summary>
            <param name="other">The other node to clone from.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLBinaryExpressionNode.#ctor(LibLSLCC.CodeValidator.LSLType,LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.LSLBinaryOperationType,LibLSLCC.CodeValidator.ILSLExprNode)">
            <summary>
                Create a <see cref="T:LibLSLCC.CodeValidator.LSLBinaryExpressionNode" /> from two <see cref="T:LibLSLCC.CodeValidator.ILSLExprNode" />'s and an operator description.
            </summary>
            <param name="resultType">
                The resulting type of the binary operation between <paramref name="leftExpression" /> and
                <paramref name="rightExpression" />.
            </param>
            <param name="leftExpression">The left expression.</param>
            <param name="operation">The operator.</param>
            <param name="rightExpression">The right expression.</param>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="leftExpression" /> or <paramref name="rightExpression" /> is
                <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
                Thrown if <paramref name="resultType" /> is equal to <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" /> or
                <paramref name="operation" /> is equal to <see cref="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.Error" />
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLBinaryExpressionNode.#ctor(LibLSLCC.AntlrParser.LSLParser.ExpressionContext,Antlr4.Runtime.IToken,LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.LSLType,System.String)">
            <exception cref="T:System.ArgumentNullException">
                <paramref name="context" /> or
                <paramref name="leftExpression" /> or
                <paramref name="rightExpression" /> is <c>null</c>.
            </exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLBinaryExpressionNode.LeftExpression">
            <summary>
                The expression tree on the left of side of the binary operation.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLBinaryExpressionNode.RightExpression">
            <summary>
                The expression tree on the right side of the binary operation.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLBinaryExpressionNode.SourceRangeOperation">
            <summary>
                The source code range that encompasses the binary expression and its children.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLBinaryExpressionNode.Operation">
            <summary>
                The binary operation type of this node.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLBinaryExpressionNode.OperationString">
            <summary>
                The string representation of the binary operation this node preforms.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLBinaryExpressionNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Gets an instance of this node that represents a syntax error in the node.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>An error form of the node.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLBinaryExpressionNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLBinaryExpressionNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLBinaryExpressionNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLBinaryExpressionNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values
                for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLBinaryExpressionNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLBinaryExpressionNode.HasPossibleSideEffects">
            <summary>
                True if the expression statement has some modifying effect on a local parameter or global/local variable;  or is a
                function call.  False otherwise.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLBinaryExpressionNode.DescribeType">
            <summary>
                Should produce a user friendly description of the expressions return type. <para/>
                This is used in some syntax error messages, Ideally you should enclose your description in
                parenthesis or something that will make it stand out in a string.
            </summary>
            <returns>A use friendly description of the node's <see cref="P:LibLSLCC.CodeValidator.LSLBinaryExpressionNode.Type"/>.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLBinaryExpressionNode.Type">
            <summary>
                The return type of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLType" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLBinaryExpressionNode.ExpressionType">
            <summary>
                The expression type/classification of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLExpressionType" />
            </summary>
            <value>
                The type of the expression.
            </value>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLBinaryExpressionNode.IsConstant">
            <summary>
                True if the expression is constant and can be calculated at compile time.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLBinaryExpressionNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLBinaryExpressionNode.Clone">
            <summary>
                Deep clones the expression node.  It should clone the node and all of its children and cloneable properties, except
                the parent.
                When cloned, the parent node reference should be left <c>null</c>.
            </summary>
            <returns>A deep clone of this expression tree node.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLBinaryOperationType">
            <summary>
                Describes different types of binary operations.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.Add">
            <summary>
                Addition.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.AddAssign">
            <summary>
                Compound Add and assign.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.Subtract">
            <summary>
                Subtraction.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.SubtractAssign">
            <summary>
                Compound Subtract and assign.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.Multiply">
            <summary>
                Multiplication.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.MultiplyAssign">
            <summary>
                Compound Multiply and assign.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.Divide">
            <summary>
                Division.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.DivideAssign">
            <summary>
                Compound Divide and assign.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.Modulus">
            <summary>
                Modulus.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.ModulusAssign">
            <summary>
                Compound Modulus and assign.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.Assign">
            <summary>
                Direct assignment.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.BitwiseXor">
            <summary>
                Bitwise XOR operator.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.BitwiseAnd">
            <summary>
                Bitwise AND operator.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.BitwiseOr">
            <summary>
                Bitwise OR operator.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.LogicalOr">
            <summary>
                Logical OR operator.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.LogicalAnd">
            <summary>
                Logical AND operator.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.LessThan">
            <summary>
                Less than comparison operator.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.LessThanEqual">
            <summary>
                Less than or equal to comparison operator.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.GreaterThan">
            <summary>
                Greater than comparison operator.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.GreaterThanEqual">
            <summary>
                Greater than or equal to comparison operator.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.LeftShift">
            <summary>
                Bitwise left shift operator.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.RightShift">
            <summary>
                Bitwise right shift operator.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.Equals">
            <summary>
                Equality comparison operator.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.NotEquals">
            <summary>
                In-Equality comparison operator.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.Error">
            <summary>
                Undefined operator.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLBinaryOperationTypeTools">
            <summary>
                <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationType" /> extensions for parsing <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationType" />'s from strings.
                As well as converting them into strings.
                This class also contains some methods for group classifications of <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationType" />.
                Such as IsModifyAssign();
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLBinaryOperationTypeTools.IsModifyAssign(LibLSLCC.CodeValidator.LSLBinaryOperationType)">
            <summary>
                Determines if the <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationType" /> is a form of modifying assignment that is not just a plain
                assign operation.
            </summary>
            <param name="type">The <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationType" /> to test.</param>
            <returns>
                True if the provided <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationType" /> is a ModifyAssignOperation such as (+=).  False if
                it is a plain assignment operator, or other type of operator.
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLBinaryOperationTypeTools.IsAssignOrModifyAssign(LibLSLCC.CodeValidator.LSLBinaryOperationType)">
            <summary>
                Determines if the <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationType" /> is a direct assignment, or a modifying assignment
                operation.
                Effectively: (type == <see cref="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.Assign" /> ||
                <see cref="M:LibLSLCC.CodeValidator.LSLBinaryOperationTypeTools.IsModifyAssign(LibLSLCC.CodeValidator.LSLBinaryOperationType)" />)
            </summary>
            <param name="type">The <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationType" /> to test.</param>
            <returns>
                True if the provided <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationType" /> is either a direct assignment operation, or is a
                modifying assignment operation.  False if otherwise.
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLBinaryOperationTypeTools.ParseFromOperator(System.String)">
            <summary>
                Parses an <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationType" /> from a given string.  Accepted strings are any of LSL's binary
                operators, without any whitespace characters added.
            </summary>
            <param name="operationString">The operation string to turn into an <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationType" />.</param>
            <exception cref="T:System.ArgumentException">
                Thrown when 'operationString' does not contain a valid string representation of a
                binary operator that exist's in LSL.
            </exception>
            <returns>The parsed <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationType" />.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLBinaryOperationTypeTools.ToOperatorString(LibLSLCC.CodeValidator.LSLBinaryOperationType)">
            <summary>
                Converts an <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationType" /> into is source code equivalent string.
            </summary>
            <param name="type">The <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationType" /> to convert to a string.</param>
            <returns>The source code equivalent string representation of the provided <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationType" />.</returns>
            <exception cref="T:System.ArgumentException">
                Thrown if the <see cref="T:LibLSLCC.CodeValidator.LSLBinaryOperationType" /> provided is equal to
                <see cref="F:LibLSLCC.CodeValidator.LSLBinaryOperationType.Error" />
            </exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDummyExpr.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLDummyExpr.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDummyExpr.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDummyExpr.Type">
            <summary>
                The return type of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLType" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDummyExpr.ExpressionType">
            <summary>
                The expression type/classification of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLExpressionType" />
            </summary>
            <value>
                The type of the expression.
            </value>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDummyExpr.IsConstant">
            <summary>
                True if the expression is constant and can be calculated at compile time.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDummyExpr.HasPossibleSideEffects">
            <summary>
                True if the expression statement has some modifying effect on a local parameter or global/local variable;  or is a
                function call.  False otherwise.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDummyExpr.Clone">
            <summary>
                Deep clones the expression node.  It should clone the node and all of its children and cloneable properties, except
                the parent.
                When cloned, the parent node reference should be left <c>null</c>.
            </summary>
            <returns>A deep clone of this expression tree node.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDummyExpr.DescribeType">
            <summary>
                Should produce a user friendly description of the expressions return type. <para/>
                This is used in some syntax error messages, Ideally you should enclose your description in
                parenthesis or something that will make it stand out in a string.
            </summary>
            <returns>A use friendly description of the node's <see cref="P:LibLSLCC.CodeValidator.LSLDummyExpr.Type"/>.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDummyExpr.LibLSLCC#CodeValidator#ILSLReadOnlyExprNode#Clone">
            <summary>
                Deep clone the expression node into a new node.
                This should deep clone all of the node's children as well.
            </summary>
            <returns>Cloned <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlyExprNode" /></returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLExpressionListNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLExpressionListNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExpressionListNode.#ctor">
            <summary>
                Create an empty <see cref="T:LibLSLCC.CodeValidator.LSLExpressionListNode" />.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExpressionListNode.#ctor(System.Collections.Generic.IEnumerable{LibLSLCC.CodeValidator.ILSLExprNode})">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLExpressionListNode" /> with the given expressions.
            </summary>
            <param name="expressions">The expressions to fill the expression list node with.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="expressions" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExpressionListNode.#ctor(LibLSLCC.CodeValidator.ILSLExprNode[])">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLExpressionListNode" /> with the given expressions.
            </summary>
            <param name="expressions">The expressions to fill the expression list node with.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="expressions" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExpressionListNode.#ctor(LibLSLCC.CodeValidator.LSLExpressionListNode)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLExpressionListNode" /> by cloning from another.
            </summary>
            <param name="other">The other node to clone from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionListNode.Expressions">
            <summary>
                A list of expression nodes that belong to this expression list in order of appearance, or an empty list object.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionListNode.AllExpressionsConstant">
            <summary>
                True if all expressions in the expression list are considered to be constant expressions.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionListNode.HasExpressionWithPossibleSideEffects">
            <summary>
                True if any expression in the expression list can possibly have side effects on the state of the program.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionListNode.ListType">
            <summary>
                The type of expression list this node represents.
                <see cref="T:LibLSLCC.CodeValidator.LSLExpressionListType" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionListNode.SourceRangeCommaList">
            <summary>
                The source code range for each comma separator that appears in the expression list in order, or an empty list.  <para/>
                This will never be <c>null</c>.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExpressionListNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExpressionListNode.Add(LibLSLCC.CodeValidator.ILSLExprNode)">
            <summary>
                Adds a new expression to the expression list node.
            </summary>
            <param name="node">The expression node to add to the expression list.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if the 'node' parameter is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExpressionListNode.Clone">
            <summary>
                Deep clones the expression list node and all of its child expressions.
            </summary>
            <returns>A deep cloned copy of this expression list node.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExpressionListNode.AddCommaSourceRange(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Add an <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> for a comma in the expression list.
                This method does NOT clone <paramref name="sourceRange" /> for you.
            </summary>
            <param name="sourceRange"></param>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionListNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionListNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionListNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLExpressionListNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExpressionListNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionListNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExpressionListNode.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlyExprNode"/>'s in this expression list.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExpressionListNode.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLFloatLiteralNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLFloatLiteralNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFloatLiteralNode.#ctor(LibLSLCC.CodeValidator.LSLFloatLiteralNode)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLFloatLiteralNode" /> by cloning from another.
            </summary>
            <param name="other">The other node to clone from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFloatLiteralNode.#ctor(System.Single)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLFloatLiteralNode" /> with a positive floating point value.
            </summary>
            <param name="value"></param>
            <exception cref="T:System.ArgumentOutOfRangeException">
                if <paramref name="value" /> is not positive; add to a prefix negate node
                instead.
            </exception>
            <exception cref="T:System.ArithmeticException"><paramref name="value" /> is equal to <see cref="F:System.Single.NaN" />. </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFloatLiteralNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFloatLiteralNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFloatLiteralNode.Clone">
            <summary>
                Deep clones the expression node.  It should clone the node and all of its children and cloneable properties, except
                the parent.
                When cloned, the parent node reference should still point to the same node.
            </summary>
            <returns>A deep clone of this expression node.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLFunctionCallNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLFunctionCallNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionCallNode.#ctor(LibLSLCC.CodeValidator.LSLFunctionDeclarationNode,LibLSLCC.CodeValidator.LSLExpressionListNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLFunctionCallNode" /> with an arguments list and definition reference. <para/>
                <paramref name="definition" /> receives this node as a new reference in <see cref="P:LibLSLCC.CodeValidator.LSLFunctionDeclarationNode.References" />.
            </summary>
            <param name="argumentList">The argument list node.</param>
            <param name="definition">The function definition node.</param>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="definition" /> or <paramref name="argumentList" /> is
                <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionCallNode.#ctor(LibLSLCC.CodeValidator.LSLFunctionDeclarationNode,LibLSLCC.CodeValidator.ILSLExprNode[])">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLFunctionCallNode" /> with an arguments list and definition reference.
                <paramref name="definition" /> receives this node as a new reference in <see cref="P:LibLSLCC.CodeValidator.LSLFunctionDeclarationNode.References" />.
            </summary>
            <param name="argumentList">The list of expression arguments.</param>
            <param name="definition">The function definition node.</param>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="definition" /> or <paramref name="argumentList" /> is
                <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionCallNode.#ctor(LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.LSLExpressionListNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLFunctionCallNode" /> with an arguments list.
                This represents a call to a library function, since it has no definition node.
            </summary>
            <param name="functionSignature">The signature of the library function.</param>
            <param name="argumentList">The argument list node.</param>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="functionSignature" /> or <paramref name="argumentList" /> is
                <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionCallNode.#ctor(LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.ILSLExprNode[])">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLFunctionCallNode" /> with an arguments list.
                This represents a call to a library function, since it has no definition node.
            </summary>
            <param name="functionSignature">The signature of the library function.</param>
            <param name="argumentList">The list of expression arguments.</param>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="functionSignature" /> or <paramref name="argumentList" /> is
                <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionCallNode.#ctor(LibLSLCC.AntlrParser.LSLParser.Expr_FunctionCallContext,LibLSLCC.CodeValidator.LSLPreDefinedFunctionSignature,LibLSLCC.CodeValidator.LSLExpressionListNode)">
            <exception cref="T:System.ArgumentNullException">
                <paramref name="context" /> or <paramref name="preDefinition" /> or
                <paramref name="argumentExpressionList" /> is <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionCallNode.#ctor(LibLSLCC.AntlrParser.LSLParser.Expr_FunctionCallContext,LibLSLCC.CodeValidator.ILSLFunctionSignature,LibLSLCC.CodeValidator.LSLExpressionListNode)">
            <exception cref="T:System.ArgumentNullException">
                <paramref name="context" /> or <paramref name="signature" /> or
                <paramref name="argumentExpressionList" /> is <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionCallNode.#ctor(LibLSLCC.CodeValidator.LSLFunctionCallNode)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLFunctionCallNode" /> by cloning from another.
            </summary>
            <param name="other">The other node to clone from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionCallNode.ArgumentExpressionList">
            <summary>
                The parameter list node containing the expressions used to call this function, this will never be null even if the
                parameter list is empty.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionCallNode.Definition">
            <summary>
                The syntax tree node where the function was defined if it is a user defined function.  If the function call is to a
                library function this will be null.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionCallNode.IsLibraryFunctionCall">
            <summary>
                True if the function that was called is a library function call, false if it was a call to a user defined function.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionCallNode.SourceRangeOpenParenth">
            <summary>
                The source code range of the opening parentheses where the parameters of the function start.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionCallNode.SourceRangeCloseParenth">
            <summary>
                The source code range of the closing parentheses where the parameters of the function end.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionCallNode.SourceRangeName">
            <summary>
                The source code range of the function name in the function call expression.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionCallNode.Name">
            <summary>
                The name of the function that was called.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionCallNode.Signature">
            <summary>
                The function signature of the function that was called, as it was defined by either the user or library.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionCallNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceCodeRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionCallNode.Clone">
            <summary>
                Deep clones the expression node.  It should clone the node and all of its children and cloneable properties, except
                the parent.
                When cloned, the parent node reference should be left <c>null</c>.
            </summary>
            <returns>A deep clone of this expression tree node.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionCallNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionCallNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLFunctionCallNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionCallNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionCallNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionCallNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionCallNode.Type">
            <summary>
                The return type of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLType" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionCallNode.ExpressionType">
            <summary>
                The expression type/classification of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLExpressionType" />
            </summary>
            <value>
                The type of the expression.
            </value>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionCallNode.IsConstant">
            <summary>
                True if the expression is constant and can be calculated at compile time.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionCallNode.HasPossibleSideEffects">
            <summary>
                True if the expression statement has some modifying effect on a local parameter or global/local variable;  or is a
                function call.  False otherwise.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionCallNode.DescribeType">
            <summary>
                Should produce a user friendly description of the expressions return type. <para/>
                This is used in some syntax error messages, Ideally you should enclose your description in
                parenthesis or something that will make it stand out in a string.
            </summary>
            <returns>A use friendly description of the node's <see cref="P:LibLSLCC.CodeValidator.LSLFunctionCallNode.Type"/>.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLHexLiteralNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLHexLiteralNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLHexLiteralNode.#ctor(LibLSLCC.CodeValidator.LSLHexLiteralNode)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLHexLiteralNode" /> by cloning from another.
            </summary>
            <param name="other">The other node to clone from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLHexLiteralNode.#ctor(System.Int32)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLHexLiteralNode" /> from an integer value.
            </summary>
            <param name="value">The integer value, it will be converted to a hex string representation.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLHexLiteralNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLHexLiteralNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLHexLiteralNode.Clone">
            <summary>
                Deep clones the expression node.  It should clone the node and all of its children and cloneable properties, except
                the parent.
                When cloned, the parent node reference should still point to the same node.
            </summary>
            <returns>A deep clone of this expression node.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLIntegerLiteralNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLIntegerLiteralNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLIntegerLiteralNode.#ctor(System.Int64)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLIntegerLiteralNode" /> from a positive integer value.
                <exception cref="T:System.ArgumentOutOfRangeException">
                    if <paramref name="value" /> is not positive; add to a prefix negate node instead. <para/>
                    if <paramref name="value"/> is greater than 2147483648.
                </exception>
            </summary>
            <param name="value">The integer value.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLIntegerLiteralNode.#ctor(LibLSLCC.CodeValidator.LSLIntegerLiteralNode)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLIntegerLiteralNode" /> by cloning from another.
            </summary>
            <param name="other">The other node to clone from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLIntegerLiteralNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLIntegerLiteralNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLIntegerLiteralNode.Clone">
            <summary>
                Deep clones the expression node.  It should clone the node and all of its children and cloneable properties, except
                the parent.
                When cloned, the parent node reference should still point to the same node.
            </summary>
            <returns>A deep clone of this expression node.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLListLiteralNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLListLiteralNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLListLiteralNode.#ctor">
            <summary>
                Create a <see cref="T:LibLSLCC.CodeValidator.LSLListLiteralNode" /> with an empty <see cref="T:LibLSLCC.CodeValidator.LSLExpressionListNode" /> as content.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLListLiteralNode.#ctor(LibLSLCC.CodeValidator.LSLExpressionListNode)">
            <summary>
                Create a <see cref="T:LibLSLCC.CodeValidator.LSLListLiteralNode" /> with the given <see cref="T:LibLSLCC.CodeValidator.LSLExpressionListNode" /> as content.
            </summary>
            <param name="expressionListNode">The expression list node.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="expressionListNode" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLListLiteralNode.#ctor(LibLSLCC.CodeValidator.ILSLExprNode[])">
            <summary>
                Create a <see cref="T:LibLSLCC.CodeValidator.LSLListLiteralNode" /> with the given list of <see cref="T:LibLSLCC.CodeValidator.ILSLExprNode"/> as content.
            </summary>
            <param name="expressionList">The <see cref="T:LibLSLCC.CodeValidator.ILSLExprNode"/> list.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="expressionList" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLListLiteralNode.#ctor(LibLSLCC.AntlrParser.LSLParser.ListLiteralContext,LibLSLCC.CodeValidator.LSLExpressionListNode)">
            <exception cref="T:System.ArgumentNullException">
                <paramref name="context" /> or <paramref name="expressionListNode" /> is
                <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLListLiteralNode.#ctor(LibLSLCC.CodeValidator.LSLListLiteralNode)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLListLiteralNode" /> by cloning from another.
            </summary>
            <param name="other">The other node to clone from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLListLiteralNode.ExpressionListNode">
            <summary>
                The expression list node that contains all of the expressions used to initialize the list literal.
                This will never be null, even when the list literal was defined as being empty.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLListLiteralNode.SourceRangeOpenBracket">
            <summary>
                The source code range of the list literals opening bracket.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLListLiteralNode.SourceRangeCloseBracket">
            <summary>
                The source code range of the list literals closing bracket.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLListLiteralNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLListLiteralNode.Clone">
            <summary>
                Deep clones the expression node.  It should clone the node and all of its children and cloneable properties, except
                the parent.
                When cloned, the parent node reference should be left <c>null</c>.
            </summary>
            <returns>A deep clone of this expression tree node.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLListLiteralNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLListLiteralNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLListLiteralNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLListLiteralNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLListLiteralNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLListLiteralNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLListLiteralNode.Type">
            <summary>
                The return type of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLType" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLListLiteralNode.ExpressionType">
            <summary>
                The expression type/classification of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLExpressionType" />
            </summary>
            <value>
                The type of the expression.
            </value>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLListLiteralNode.IsConstant">
            <summary>
                True if the expression is constant and can be calculated at compile time.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLListLiteralNode.HasPossibleSideEffects">
            <summary>
                True if the expression has some modifying effect on a local parameter or global/local variable;  or is a function
                call.  False otherwise.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLListLiteralNode.DescribeType">
            <summary>
                Should produce a user friendly description of the expressions return type. <para/>
                This is used in some syntax error messages, Ideally you should enclose your description in
                parenthesis or something that will make it stand out in a string.
            </summary>
            <returns>A use friendly description of the node's <see cref="P:LibLSLCC.CodeValidator.LSLListLiteralNode.Type"/>.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLConstantLiteralNode`1">
            <summary>
                Base class for constant literal nodes.
            </summary>
            <typeparam name="TDerivedType">This should be the type that is inheriting this generic class.</typeparam>
            <seealso cref="T:LibLSLCC.CodeValidator.LSLIntegerLiteralNode" />
            <seealso cref="T:LibLSLCC.CodeValidator.LSLHexLiteralNode" />
            <seealso cref="T:LibLSLCC.CodeValidator.LSLFloatLiteralNode" />
            <seealso cref="T:LibLSLCC.CodeValidator.LSLStringLiteralNode" />
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantLiteralNode`1.#ctor(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLConstantLiteralNode{`0}.Err)">
            <summary>
                Allows easy creation of an error state from derived nodes.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <param name="err">Dummy error enum parameter.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantLiteralNode`1.#ctor(LibLSLCC.CodeValidator.LSLConstantLiteralNode{`0})">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLConstantLiteralNode`1" /> by cloning from another.
            </summary>
            <param name="other">The other node to clone from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantLiteralNode`1.#ctor(System.String,LibLSLCC.CodeValidator.LSLType,LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Create a constant literal node using the ANTLR context of the expression atom that represents the source literal.
            </summary>
            <param name="rawText">The raw text of the constant literal.</param>
            <param name="type">The <see cref="T:LibLSLCC.CodeValidator.LSLType" /> that the source code literal represents.</param>
            <param name="sourceRange">
                The source code range of the constant literal, or <c>null</c> if source code ranges are not
                available.
            </param>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLConstantLiteralNode`1.Err">
            <summary>
                Dummy argument for the protected error node constructor.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLConstantLiteralNode`1.Err.Err">
            <summary>
                Dummy member
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLConstantLiteralNode`1.RawText">
            <summary>
                The raw text of the literal taken from the source code.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLConstantLiteralNode`1.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLConstantLiteralNode`1.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLConstantLiteralNode`1.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLConstantLiteralNode`1.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantLiteralNode`1.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLConstantLiteralNode`1.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLConstantLiteralNode`1.Type">
            <summary>
                The return type of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLType" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLConstantLiteralNode`1.ExpressionType">
            <summary>
                The expression type/classification of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLExpressionType" />
            </summary>
            <value>
                The type of the expression.
            </value>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLConstantLiteralNode`1.IsConstant">
            <summary>
                True if the expression is constant and can be calculated at compile time.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLConstantLiteralNode`1.HasPossibleSideEffects">
            <summary>
                True if the expression statement has some modifying effect on a local parameter or global/local variable;  or is a
                function call.  False otherwise.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantLiteralNode`1.Clone">
            <summary>
                Deep clones the expression node.  It should clone the node and all of its children and cloneable properties, except
                the parent.
                When cloned, the parent node reference should be left <c>null</c>.
            </summary>
            <returns>A deep clone of this expression tree node.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantLiteralNode`1.DescribeType">
            <summary>
                Should produce a user friendly description of the expressions return type. <para/>
                This is used in some syntax error messages, Ideally you should enclose your description in
                parenthesis or something that will make it stand out in a string.
            </summary>
            <returns>A use friendly description of the node's <see cref="P:LibLSLCC.CodeValidator.LSLConstantLiteralNode`1.Type"/>.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLParenthesizedExpressionNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLParenthesizedExpressionNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParenthesizedExpressionNode.#ctor(LibLSLCC.CodeValidator.ILSLExprNode)">
            <summary>
                Create a <see cref="T:LibLSLCC.CodeValidator.LSLParenthesizedExpressionNode" /> around a given <see cref="T:LibLSLCC.CodeValidator.ILSLExprNode" />.
            </summary>
            <param name="innerExpression"></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="innerExpression" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParenthesizedExpressionNode.#ctor(LibLSLCC.AntlrParser.LSLParser.ParenthesizedExpressionContext,LibLSLCC.CodeValidator.ILSLExprNode)">
            <exception cref="T:System.ArgumentNullException">
                <paramref name="context" /> or <paramref name="innerExpression" /> is
                <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParenthesizedExpressionNode.#ctor(LibLSLCC.CodeValidator.LSLParenthesizedExpressionNode)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLParenthesizedExpressionNode" /> by cloning from another.
            </summary>
            <param name="other">The other node to clone from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParenthesizedExpressionNode.InnerExpression">
            <summary>
                The expression node contained within the parenthesis, this should never be null.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParenthesizedExpressionNode.SourceRangeOpenParenth">
            <summary>
                The source code range of the opening parenthesis in the parenthesized expression.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParenthesizedExpressionNode.SourceRangeCloseParenth">
            <summary>
                The source code range of the closing parenthesis in the parenthesized expression.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParenthesizedExpressionNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParenthesizedExpressionNode.Clone">
            <summary>
                Deep clones the expression node.  It should clone the node and all of its children and cloneable properties, except
                the parent.
                When cloned, the parent node reference should be left <c>null</c>.
            </summary>
            <returns>A deep clone of this expression tree node.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParenthesizedExpressionNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParenthesizedExpressionNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLParenthesizedExpressionNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParenthesizedExpressionNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParenthesizedExpressionNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParenthesizedExpressionNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParenthesizedExpressionNode.Type">
            <summary>
                The return type of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLType" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParenthesizedExpressionNode.ExpressionType">
            <summary>
                The expression type/classification of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLExpressionType" />
            </summary>
            <value>
                The type of the expression.
            </value>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParenthesizedExpressionNode.IsConstant">
            <summary>
                True if the expression is constant and can be calculated at compile time.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParenthesizedExpressionNode.HasPossibleSideEffects">
            <summary>
                True if the expression has some modifying effect on a local parameter or global/local variable;  or is a function
                call.  False otherwise.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParenthesizedExpressionNode.DescribeType">
            <summary>
                Should produce a user friendly description of the expressions return type. <para/>
                This is used in some syntax error messages, Ideally you should enclose your description in
                parenthesis or something that will make it stand out in a string.
            </summary>
            <returns>A use friendly description of the node's <see cref="P:LibLSLCC.CodeValidator.LSLParenthesizedExpressionNode.Type"/>.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLPostfixOperationNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLPostfixOperationNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLPostfixOperationNode.#ctor(LibLSLCC.CodeValidator.LSLType,LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.LSLPostfixOperationType)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLPostfixOperationNode" /> from a given <see cref="T:LibLSLCC.CodeValidator.ILSLExprNode" /> and
                <see cref="T:LibLSLCC.CodeValidator.LSLPostfixOperationType" />.
            </summary>
            <param name="resultType">The return type of the postfix operation on the given expression.</param>
            <param name="leftExpression">The expression the postfix operation occurs on.</param>
            <param name="operationType">The postfix operation type.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="leftExpression" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="operationType" /> is <see cref="F:LibLSLCC.CodeValidator.LSLPostfixOperationType.Error" />.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLPostfixOperationNode.#ctor(LibLSLCC.AntlrParser.LSLParser.Expr_PostfixOperationContext,LibLSLCC.CodeValidator.LSLType,LibLSLCC.CodeValidator.ILSLExprNode)">
            <exception cref="T:System.ArgumentNullException">
                <paramref name="context" /> or <paramref name="leftExpression" /> is
                <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLPostfixOperationNode.#ctor(LibLSLCC.CodeValidator.LSLPostfixOperationNode)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLPostfixOperationNode" /> by cloning from another.
            </summary>
            <param name="other">The other node to clone from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPostfixOperationNode.LeftExpression">
            <summary>
                The expression that is left of the postfix operator, this should never be null.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPostfixOperationNode.Operation">
            <summary>
                The postfix operation type preformed on the expression.
                <see cref="T:LibLSLCC.CodeValidator.LSLPostfixOperationType" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPostfixOperationNode.OperationString">
            <summary>
                The postfix operation string taken from the source code.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLPostfixOperationNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLPostfixOperationNode.Clone">
            <summary>
                Deep clones the expression node.  It should clone the node and all of its children and cloneable properties, except
                the parent.
                When cloned, the parent node reference should be left <c>null</c>.
            </summary>
            <returns>A deep clone of this expression tree node.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPostfixOperationNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPostfixOperationNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLPostfixOperationNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPostfixOperationNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPostfixOperationNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPostfixOperationNode.SourceRangeOperation">
            <summary>
                The source code range the postfix operator occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLPostfixOperationNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPostfixOperationNode.Type">
            <summary>
                The return type of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLType" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPostfixOperationNode.ExpressionType">
            <summary>
                The expression type/classification of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLExpressionType" />
            </summary>
            <value>
                The type of the expression.
            </value>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPostfixOperationNode.IsConstant">
            <summary>
                True if the expression is constant and can be calculated at compile time.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPostfixOperationNode.HasPossibleSideEffects">
            <summary>
                True if the expression statement has some modifying effect on a local parameter or global/local variable;  or is a
                function call.  False otherwise.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLPostfixOperationNode.DescribeType">
            <summary>
                Should produce a user friendly description of the expressions return type. <para/>
                This is used in some syntax error messages, Ideally you should enclose your description in
                parenthesis or something that will make it stand out in a string.
            </summary>
            <returns>A use friendly description of the node's <see cref="P:LibLSLCC.CodeValidator.LSLPostfixOperationNode.Type"/>.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLPostfixOperationType">
            <summary>
                Represents different types of LSL postfix operators.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLPostfixOperationType.Increment">
            <summary>
                Postfix Increment.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLPostfixOperationType.Decrement">
            <summary>
                Postfix Decrement.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLPostfixOperationType.Error">
            <summary>
                Unknown/Erroneous postfix operator.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLPostfixOperationTypeTools">
            <summary>
                <see cref="T:LibLSLCC.CodeValidator.LSLPostfixOperationType" /> extensions for converting <see cref="T:LibLSLCC.CodeValidator.LSLPostfixOperationType" /> from source
                code string representation
                and back.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLPostfixOperationTypeTools.ToOperatorString(LibLSLCC.CodeValidator.LSLPostfixOperationType)">
            <summary>
                Converts the provided  <see cref="T:LibLSLCC.CodeValidator.LSLPostfixOperationType" /> to its source code string representation.
            </summary>
            <param name="type">The <see cref="T:LibLSLCC.CodeValidator.LSLPostfixOperationType" /> to convert to a string.</param>
            <exception cref="T:System.ArgumentException">
                Thrown if the <see cref="T:LibLSLCC.CodeValidator.LSLPostfixOperationType" /> provided was equal to
                <see cref="F:LibLSLCC.CodeValidator.LSLPostfixOperationType.Error" />.
            </exception>
            <returns>The source code string representation of the <see cref="T:LibLSLCC.CodeValidator.LSLPostfixOperationType" />.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLPostfixOperationTypeTools.IsModifying(LibLSLCC.CodeValidator.LSLPostfixOperationType)">
            <summary>
                Determines whether the given postfix operation is a modifying operation.
                Both <see cref="F:LibLSLCC.CodeValidator.LSLPostfixOperationType.Decrement" /> and <see cref="F:LibLSLCC.CodeValidator.LSLPostfixOperationType.Increment" /> are
                modifying operations.
            </summary>
            <param name="type">If the postfix operation modifies the expression to its left.</param>
            <returns><c>true</c> if <paramref name="type"/> is <see cref="F:LibLSLCC.CodeValidator.LSLPrefixOperationType.Decrement" /> or <see cref="F:LibLSLCC.CodeValidator.LSLPrefixOperationType.Increment" />.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLPostfixOperationTypeTools.ParseFromOperator(System.String)">
            <summary>
                Parses a <see cref="T:LibLSLCC.CodeValidator.LSLPostfixOperationType" /> from its source code string representation.
            </summary>
            <param name="operationString">The string to attempt to parse an <see cref="T:LibLSLCC.CodeValidator.LSLPostfixOperationType" /> from.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if 'operationString' is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">
                Thrown if 'operationString' was not a valid source code string representation of an
                LSL postfix operator.
            </exception>
            <returns>The parsed <see cref="T:LibLSLCC.CodeValidator.LSLPostfixOperationType" />.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLPrefixOperationNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLPrefixOperationNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLPrefixOperationNode.#ctor(LibLSLCC.AntlrParser.LSLParser.Expr_PrefixOperationContext,LibLSLCC.CodeValidator.LSLType,LibLSLCC.CodeValidator.ILSLExprNode)">
            <exception cref="T:System.ArgumentNullException">
                <paramref name="context" /> or <paramref name="rightExpression" /> is
                <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLPrefixOperationNode.#ctor(LibLSLCC.CodeValidator.LSLType,LibLSLCC.CodeValidator.LSLPrefixOperationType,LibLSLCC.CodeValidator.ILSLExprNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLPostfixOperationNode" /> from a given <see cref="T:LibLSLCC.CodeValidator.ILSLExprNode" /> and
                <see cref="T:LibLSLCC.CodeValidator.LSLPostfixOperationType" />.
            </summary>
            <param name="resultType">The return type of the postfix operation on the given expression.</param>
            <param name="rightExpression">The expression the postfix operation occurs on.</param>
            <param name="operationType">The postfix operation type.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="rightExpression" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="operationType" /> is <see cref="F:LibLSLCC.CodeValidator.LSLPrefixOperationType.Error" />.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLPrefixOperationNode.#ctor(LibLSLCC.CodeValidator.LSLPrefixOperationNode)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLPrefixOperationNode" /> by cloning from another.
            </summary>
            <param name="other">The other node to clone from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPrefixOperationNode.RightExpression">
            <summary>
                The expression that is right of the prefix operator, this should never be null.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPrefixOperationNode.Operation">
            <summary>
                The prefix operation type preformed on the expression.
                <see cref="T:LibLSLCC.CodeValidator.LSLPrefixOperationType" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPrefixOperationNode.OperationString">
            <summary>
                The prefix operation string taken from the source code.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLPrefixOperationNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLPrefixOperationNode.Clone">
            <summary>
                Deep clones the expression node.  It should clone the node and all of its children and cloneable properties, except
                the parent.
                When cloned, the parent node reference should be left <c>null</c>.
            </summary>
            <returns>A deep clone of this expression tree node.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPrefixOperationNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPrefixOperationNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLPrefixOperationNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPrefixOperationNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPrefixOperationNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPrefixOperationNode.SourceRangeOperation">
            <summary>
                The source code range the prefix operator occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLPrefixOperationNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPrefixOperationNode.Type">
            <summary>
                The return type of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLType" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPrefixOperationNode.ExpressionType">
            <summary>
                The expression type/classification of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLExpressionType" />
            </summary>
            <value>
                The type of the expression.
            </value>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPrefixOperationNode.IsConstant">
            <summary>
                True if the expression is constant and can be calculated at compile time.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLPrefixOperationNode.HasPossibleSideEffects">
            <summary>
                True if the expression statement has some modifying effect on a local parameter or global/local variable;  or is a
                function call.  False otherwise.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLPrefixOperationNode.DescribeType">
            <summary>
                Should produce a user friendly description of the expressions return type. <para/>
                This is used in some syntax error messages, Ideally you should enclose your description in
                parenthesis or something that will make it stand out in a string.
            </summary>
            <returns>A use friendly description of the node's <see cref="P:LibLSLCC.CodeValidator.LSLPrefixOperationNode.Type"/>.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLPrefixOperationType">
            <summary>
                Represents different types of LSL prefix operators.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLPrefixOperationType.Increment">
            <summary>
                Prefix increment.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLPrefixOperationType.Decrement">
            <summary>
                Prefix decrement.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLPrefixOperationType.Negate">
            <summary>
                Prefix negation.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLPrefixOperationType.BooleanNot">
            <summary>
                Boolean not prefix operator.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLPrefixOperationType.BitwiseNot">
            <summary>
                Bitwise not prefix operator. (~)
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLPrefixOperationType.Error">
            <summary>
                Unknown/Erroneous prefix operator.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLPrefixOperationTypeTools">
            <summary>
                <see cref="T:LibLSLCC.CodeValidator.LSLPrefixOperationType" /> extensions for converting <see cref="T:LibLSLCC.CodeValidator.LSLPrefixOperationType" /> from source
                code string representation
                and back.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLPrefixOperationTypeTools.ToOperatorString(LibLSLCC.CodeValidator.LSLPrefixOperationType)">
            <summary>
                Converts the provided <see cref="T:LibLSLCC.CodeValidator.LSLPrefixOperationType" /> to its source code string representation.
            </summary>
            <param name="type">The <see cref="T:LibLSLCC.CodeValidator.LSLPrefixOperationType" /> to convert to a string.</param>
            <exception cref="T:System.ArgumentException">
                Thrown if the <see cref="T:LibLSLCC.CodeValidator.LSLPrefixOperationType" /> provided was equal to
                <see cref="F:LibLSLCC.CodeValidator.LSLPrefixOperationType.Error" />.
            </exception>
            <returns>The source code string representation of the <see cref="T:LibLSLCC.CodeValidator.LSLPrefixOperationType" />.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLPrefixOperationTypeTools.IsModifying(LibLSLCC.CodeValidator.LSLPrefixOperationType)">
            <summary>
                Determines whether the given prefix operation is a modifying operation.
                Currently only <see cref="F:LibLSLCC.CodeValidator.LSLPrefixOperationType.Decrement" /> and <see cref="F:LibLSLCC.CodeValidator.LSLPrefixOperationType.Increment" />
                are considered modifying operations.
            </summary>
            <param name="type">If the prefix operation modifies the expression to its right.</param>
            <returns><c>true</c> if <paramref name="type"/> is <see cref="F:LibLSLCC.CodeValidator.LSLPrefixOperationType.Decrement" /> or <see cref="F:LibLSLCC.CodeValidator.LSLPrefixOperationType.Increment" />.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLPrefixOperationTypeTools.ParseFromOperator(System.String)">
            <summary>
                Parses a <see cref="T:LibLSLCC.CodeValidator.LSLPrefixOperationType" /> from its source code string representation.
            </summary>
            <param name="operationString">The string to attempt to parse an <see cref="T:LibLSLCC.CodeValidator.LSLPrefixOperationType" /> from.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if 'operationString' is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">
                Thrown if 'operationString' was not a valid source code string representation of an
                LSL prefix operator.
            </exception>
            <returns>The parsed <see cref="T:LibLSLCC.CodeValidator.LSLPrefixOperationType" />.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLRotationLiteralNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLRotationLiteralNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLRotationLiteralNode.#ctor(LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.ILSLExprNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLRotationLiteralNode" /> with the given component expressions.
            </summary>
            <param name="x">The 'x' rotation component expression.</param>
            <param name="y">The 'y' rotation component expression.</param>
            <param name="z">The 'z' rotation component expression.</param>
            <param name="s">The 's' rotation component expression.</param>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="x" /> or
                <paramref name="y" /> or
                <paramref name="z" /> or
                <paramref name="s" /> is <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLRotationLiteralNode.#ctor(LibLSLCC.AntlrParser.LSLParser.RotationLiteralContext,LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.ILSLExprNode)">
            <exception cref="T:System.ArgumentNullException">
                <paramref name="context" /> or
                <paramref name="x" /> or
                <paramref name="y" /> or
                <paramref name="z" /> or
                <paramref name="s" /> is <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLRotationLiteralNode.#ctor(LibLSLCC.CodeValidator.LSLRotationLiteralNode)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLRotationLiteralNode" /> by cloning from another.
            </summary>
            <param name="other">The other node to clone from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLRotationLiteralNode.XExpression">
            <summary>
                The expression node used to initialize the X (first) Component of the rotation literal.
                This should never be null.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLRotationLiteralNode.YExpression">
            <summary>
                The expression node used to initialize the Y (second) Component of the rotation literal.
                This should never be null.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLRotationLiteralNode.ZExpression">
            <summary>
                The expression node used to initialize the Z (third) Component of the rotation literal.
                This should never be null.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLRotationLiteralNode.SExpression">
            <summary>
                The expression node used to initialize the S (fourth) Component of the rotation literal.
                This should never be null.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLRotationLiteralNode.SourceRangeOpenBracket">
            <summary>
                The source code range of the opening '&lt;' bracket of the rotation literal.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLRotationLiteralNode.SourceRangeCloseBracket">
            <summary>
                The source code range of the closing '&gt;' bracket of the rotation literal.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLRotationLiteralNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLRotationLiteralNode.Clone">
            <summary>
                Deep clones the expression node.  It should clone the node and all of its children and cloneable properties, except
                the parent.
                When cloned, the parent node reference should be left <c>null</c>.
            </summary>
            <returns>A deep clone of this expression tree node.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLRotationLiteralNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLRotationLiteralNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLRotationLiteralNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLRotationLiteralNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLRotationLiteralNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLRotationLiteralNode.SourceRangeCommaOne">
            <summary>
                The source code range of the first component separator comma to appear in the rotation literal.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLRotationLiteralNode.SourceRangeCommaTwo">
            <summary>
                The source code range of the second component separator comma to appear in the rotation literal.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLRotationLiteralNode.SourceRangeCommaThree">
            <summary>
                The source code range of the third component separator comma to appear in the rotation literal.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLRotationLiteralNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLRotationLiteralNode.Type">
            <summary>
                The return type of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLType" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLRotationLiteralNode.ExpressionType">
            <summary>
                The expression type/classification of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLExpressionType" />
            </summary>
            <value>
                The type of the expression.
            </value>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLRotationLiteralNode.IsConstant">
            <summary>
                True if the expression is constant and can be calculated at compile time.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLRotationLiteralNode.HasPossibleSideEffects">
            <summary>
                True if the expression statement has some modifying effect on a local parameter or global/local variable;  or is a
                function call.  False otherwise.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLRotationLiteralNode.DescribeType">
            <summary>
                Should produce a user friendly description of the expressions return type. <para/>
                This is used in some syntax error messages, Ideally you should enclose your description in
                parenthesis or something that will make it stand out in a string.
            </summary>
            <returns>A use friendly description of the node's <see cref="P:LibLSLCC.CodeValidator.LSLRotationLiteralNode.Type"/>.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLStringLiteralNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLStringLiteralNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStringLiteralNode.#ctor(LibLSLCC.CodeValidator.LSLStringLiteralNode)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLStringLiteralNode" /> by cloning from another.
            </summary>
            <param name="other">The other node to clone from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStringLiteralNode.#ctor(System.String,System.String)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLStringLiteralNode" /> from the given raw and preprocessed source code text.
                <paramref name="preProccessedText" /> should contain the preprocessed text, with raw control characters entitized
                into escape sequences,
                and existing escape sequences double escaped with an extra backslash.
            </summary>
            <param name="rawContent">The raw string content, without quotes.</param>
            <param name="preProccessedText">The preprocessed string literal text, without quotes.</param>
            <seealso cref="T:LibLSLCC.CodeValidator.LSLDefaultStringPreProcessor" />
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStringLiteralNode.#ctor(System.String)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLStringLiteralNode" /> from the given raw and preprocessed source code text.
                <see cref="P:LibLSLCC.CodeValidator.LSLStringLiteralNode.PreProcessedText" /> is generated using <see cref="T:LibLSLCC.CodeValidator.LSLDefaultStringPreProcessor" />.
            </summary>
            <param name="rawContent">The raw source code text, without quotes.</param>
            <exception cref="T:System.ArgumentException">
                <paramref name="rawContent" /> contains invalid characters or invalid escape
                sequences.
            </exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStringLiteralNode.PreProcessedText">
            <summary>
                The pre-processed text of the string literal.
            </summary>
            <remarks>
                <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" /> relies on an implementation of <see cref="T:LibLSLCC.CodeValidator.ILSLStringPreProcessor" /> to fill this
                value out by passing <see cref="T:LibLSLCC.CodeValidator.ILSLStringPreProcessor" />
                the raw text for the string literal and assigning the string it produces to this property.
            </remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStringLiteralNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStringLiteralNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStringLiteralNode.Clone">
            <summary>
                Deep clones the expression node.  It should clone the node and all of its children and cloneable properties, except
                the parent.
                When cloned, the parent node reference should still point to the same node.
            </summary>
            <returns>A deep clone of this expression node.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLTypecastExprNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLTypecastExprNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLTypecastExprNode.#ctor(LibLSLCC.CodeValidator.LSLType,LibLSLCC.CodeValidator.ILSLExprNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLTypecastExprNode" /> with the given 'cast-to' type and casted expression node.
            </summary>
            <param name="castToType">The <see cref="T:LibLSLCC.CodeValidator.LSLType" /> to cast to.</param>
            <param name="castedExpression">The expression the cast operator acts on.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="castedExpression" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="castToType" /> is <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" />.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLTypecastExprNode.#ctor(LibLSLCC.AntlrParser.LSLParser.Expr_TypeCastContext,LibLSLCC.CodeValidator.LSLType,LibLSLCC.CodeValidator.ILSLExprNode)">
            <exception cref="T:System.ArgumentNullException">
                <paramref name="context" /> or <paramref name="castedExpression" /> is
                <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLTypecastExprNode.#ctor(LibLSLCC.CodeValidator.LSLTypecastExprNode)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLTypecastExprNode" /> by cloning from another.
            </summary>
            <param name="other">The other node to clone from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTypecastExprNode.CastedExpression">
            <summary>
                The expression node that represents the expression being casted.  This should never be null.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTypecastExprNode.CastToType">
            <summary>
                The <see cref="T:LibLSLCC.CodeValidator.LSLType" /> that represents the type the expression is being cast to.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTypecastExprNode.CastToTypeName">
            <summary>
                The raw type name of the type the expression is being cast to, taken from the source code.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTypecastExprNode.SourceRangeCloseParenth">
            <summary>
                The source code range of the closing parenthesis of the enclosed cast type.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTypecastExprNode.SourceRangeOpenParenth">
            <summary>
                The source code range of the open parenthesis of the enclosed cast type.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTypecastExprNode.SourceRangeCastToType">
            <summary>
                The source code range of the type name used for the cast.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLTypecastExprNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLTypecastExprNode.Clone">
            <summary>
                Deep clones the expression node.  It should clone the node and all of its children and cloneable properties, except
                the parent.
                When cloned, the parent node reference should be left <c>null</c>.
            </summary>
            <returns>A deep clone of this expression tree node.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTypecastExprNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTypecastExprNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLTypecastExprNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTypecastExprNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTypecastExprNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLTypecastExprNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTypecastExprNode.Type">
            <summary>
                The return type of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLType" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTypecastExprNode.ExpressionType">
            <summary>
                The expression type/classification of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLExpressionType" />
            </summary>
            <value>
                The type of the expression.
            </value>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTypecastExprNode.IsConstant">
            <summary>
                True if the expression is constant and can be calculated at compile time.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTypecastExprNode.HasPossibleSideEffects">
            <summary>
                True if the expression has some modifying effect on a local parameter or global/local variable;  or is a function
                call.  False otherwise.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLTypecastExprNode.DescribeType">
            <summary>
                Should produce a user friendly description of the expressions return type. <para/>
                This is used in some syntax error messages, Ideally you should enclose your description in
                parenthesis or something that will make it stand out in a string.
            </summary>
            <returns>A use friendly description of the node's <see cref="P:LibLSLCC.CodeValidator.LSLTypecastExprNode.Type"/>.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLVariableNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLVariableNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableNode.#ctor(LibLSLCC.CodeValidator.ILSLVariableNode)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLVariableNode" /> by cloning from another.
            </summary>
            <param name="other">The other node to clone from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableNode.IsLibraryConstant">
            <summary>
                True if this variable node references a library constant, False if it references a user defined variable or
                parameter.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableNode.IsGlobal">
            <summary>
                True if this variable node references a user defined global variable.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableNode.IsLocal">
            <summary>
                True if this variable node references a user defined local variable.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableNode.Declaration">
            <summary>
                A reference to the <see cref="T:LibLSLCC.CodeValidator.ILSLVariableDeclarationNode" /> in the syntax tree where this variable was initially
                declared.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableNode.IsParameter">
            <summary>
                True if this variable node references a function or event handler parameter.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableNode.TypeName">
            <summary>
                The raw type string describing the type of the variable referenced.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableNode.CreateGlobalVarReference(LibLSLCC.CodeValidator.LSLType,System.String,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode,LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLVariableNode" /> that references a global variable declaration node.
            </summary>
            <param name="declarationNode">A global declaration node.</param>
            <param name="variableName">The name of the global variable.</param>
            <param name="type">The type of the global variable.</param>
            <param name="sourceRange">Optional source range for the area the reference exists in.</param>
            <returns>A new variable node representing a reference to <paramref name="declarationNode" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="declarationNode" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="type" /> is <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" /> or
            </exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException"><paramref name="variableName" /> contains characters that are not valid in an LSL ID token.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableNode.CreateLocalVarReference(LibLSLCC.CodeValidator.LSLType,System.String,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode,LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLVariableNode" /> that references a local variable declaration node.
            </summary>
            <param name="declarationNode">A variable declaration node.</param>
            <param name="variableName">The name of the local variable.</param>
            <param name="type">The type of the local variable.</param>
            <param name="sourceRange">Optional source range for the area the reference exists in.</param>
            <returns>A new variable node representing a reference to <paramref name="declarationNode" />.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="declarationNode" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="type" /> is <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" /> or
            </exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException"><paramref name="variableName" /> contains characters that are not valid in an LSL ID token.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableNode.CreateParameterReference(LibLSLCC.CodeValidator.ILSLParameterNode,LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLVariableNode" /> that references a local parameter node.
            </summary>
            <param name="declarationNode">A parameter node that declares the parameter variable.</param>
            <param name="sourceRange">Optional source range for the area the reference exists in.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableNode.CreateLibraryConstantReference(LibLSLCC.CodeValidator.LSLType,System.String,LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLVariableNode" /> that references a library constant.
            </summary>
            <param name="type">The constants type.</param>
            <param name="constantName">The constants name.</param>
            <param name="sourceRange">Optional source range for the area the reference exists in.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="constantName" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="type" /> is <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" />.
            </exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException"><paramref name="constantName" /> is contains characters that are invalid in an LSL ID token.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableNode.CreateVarReference(LibLSLCC.AntlrParser.LSLParser.GlobalVariableDeclarationContext,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
            <exception cref="T:System.ArgumentNullException"><paramref name="context" /> or <paramref name="declaration" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableNode.CreateVarReference(LibLSLCC.AntlrParser.LSLParser.LocalVariableDeclarationContext,LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
            <exception cref="T:System.ArgumentNullException"><paramref name="context" /> or <paramref name="declaration" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableNode.Clone">
            <summary>
                Deep clones the expression node.  It should clone the node and all of its children and cloneable properties, except
                the parent.
                When cloned, the parent node reference should be left <c>null</c>.
            </summary>
            <returns>A deep clone of this expression tree node.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableNode.Name">
            <summary>
                The name of the referenced variable.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLVariableNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableNode.ExpressionType">
            <summary>
                The expression type/classification of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLExpressionType" />
            </summary>
            <value>
                The type of the expression.
            </value>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableNode.IsConstant">
            <summary>
                True if the expression is constant and can be calculated at compile time.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableNode.HasPossibleSideEffects">
            <summary>
                True if the expression statement has some modifying effect on a local parameter or global/local variable;  or is a
                function call.  False otherwise.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableNode.DescribeType">
            <summary>
                Should produce a user friendly description of the expressions return type. <para/>
                This is used in some syntax error messages, Ideally you should enclose your description in
                parenthesis or something that will make it stand out in a string.
            </summary>
            <returns>A use friendly description of the node's <see cref="P:LibLSLCC.CodeValidator.LSLVariableNode.Type"/>.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableNode.Type">
            <summary>
                The return type of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLType" />
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLTupleAccessorNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLTupleAccessorNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLTupleAccessorNode.#ctor(LibLSLCC.CodeValidator.ILSLExprNode,System.String)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLTupleAccessorNode" /> from the accessed expression and component accessed.
            </summary>
            <param name="accessedExpression">The expression the '.' tuple access operator was used on.</param>
            <param name="accessedComponent">The tuple component accessed: "x", "y", "z" or "s".</param>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="accessedExpression" /> or <paramref name="accessedComponent" />
                is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
                <para>
                    <paramref name="accessedExpression" />.Type is not <see cref="F:LibLSLCC.CodeValidator.LSLType.Vector" /> or
                    <see cref="F:LibLSLCC.CodeValidator.LSLType.Rotation" />.
                </para>
                <para>
                    Or <paramref name="accessedComponent" /> is not one of: "x", "y", "z" or "s".
                </para>
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLTupleAccessorNode.#ctor(LibLSLCC.AntlrParser.LSLParser.DotAccessorExprContext,LibLSLCC.CodeValidator.ILSLExprNode)">
            <exception cref="T:System.ArgumentException">
                <para>
                    If <paramref name="accessedExpression" />.Type is not <see cref="F:LibLSLCC.CodeValidator.LSLType.Vector" /> or
                    <see cref="F:LibLSLCC.CodeValidator.LSLType.Rotation" />.
                </para>
                <para>
                    Or <paramref name="context" />.member.Text is not one of: "x", "y", "z" or "s".
                </para>
            </exception>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="context" /> or <paramref name="accessedExpression" /> is
                <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLTupleAccessorNode.#ctor(LibLSLCC.CodeValidator.LSLTupleAccessorNode)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLTupleAccessorNode" /> by cloning from another.
            </summary>
            <param name="other">The other node to clone from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTupleAccessorNode.AccessedExpression">
            <summary>
                The expression that the member access operator was used on.
                This should only ever be a reference to a variable.
                Using a member accessor on a constant, even if it is a vector or rotation, is not allowed.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTupleAccessorNode.AccessedComponent">
            <summary>
                The raw name of the accessed tuple member, taken from the source code.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTupleAccessorNode.SourceRangeAccessedComponent">
            <summary>
                The source code range of the tuple member that was accessed.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLTupleAccessorNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLTupleAccessorNode.Clone">
            <summary>
                Deep clones the expression node.  It should clone the node and all of its children and cloneable properties, except
                the parent.
                When cloned, the parent node reference should be left <c>null</c>.
            </summary>
            <returns>A deep clone of this expression tree node.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTupleAccessorNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTupleAccessorNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLTupleAccessorNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTupleAccessorNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTupleAccessorNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLTupleAccessorNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTupleAccessorNode.Type">
            <summary>
                The return type of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLType" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTupleAccessorNode.ExpressionType">
            <summary>
                The expression type/classification of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLExpressionType" />
            </summary>
            <value>
                The type of the expression.
            </value>
            <exception cref="T:System.InvalidOperationException" accessor="get">If <see cref="P:LibLSLCC.CodeValidator.LSLTupleAccessorNode.AccessedExpression" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTupleAccessorNode.IsConstant">
            <summary>
                True if the expression is constant and can be calculated at compile time.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLTupleAccessorNode.HasPossibleSideEffects">
            <summary>
                True if the expression statement has some modifying effect on a local parameter or global/local variable;  or is a
                function call.  False otherwise.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLTupleAccessorNode.DescribeType">
            <summary>
                Should produce a user friendly description of the expressions return type. <para/>
                This is used in some syntax error messages, Ideally you should enclose your description in
                parenthesis or something that will make it stand out in a string.
            </summary>
            <returns>A use friendly description of the node's <see cref="P:LibLSLCC.CodeValidator.LSLTupleAccessorNode.Type"/>.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLVectorLiteralNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLVectorLiteralNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVectorLiteralNode.#ctor(LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.ILSLExprNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLVectorLiteralNode" /> with the given component expressions.
            </summary>
            <param name="x">The 'x' vector component expression.</param>
            <param name="y">The 'y' vector component expression.</param>
            <param name="z">The 'z' vector component expression.</param>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="x" /> or
                <paramref name="y" /> or
                <paramref name="z" /> is <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVectorLiteralNode.#ctor(LibLSLCC.AntlrParser.LSLParser.VectorLiteralContext,LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.ILSLExprNode)">
            <exception cref="T:System.ArgumentNullException">
                <paramref name="context" /> or
                <paramref name="x" /> or
                <paramref name="y" /> or
                <paramref name="z" /> is <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="x" /> or
                <paramref name="y" /> or
                <paramref name="z" /> already has a Parent node.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVectorLiteralNode.#ctor(LibLSLCC.CodeValidator.LSLVectorLiteralNode)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLVectorLiteralNode" /> by cloning from another.
            </summary>
            <param name="other">The other node to clone from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVectorLiteralNode.XExpression">
            <summary>
                The expression node used to initialize the X Axis Component of the vector literal.
                This should never be null.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVectorLiteralNode.YExpression">
            <summary>
                The expression node used to initialize the Y Axis Component of the vector literal.
                This should never be null.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVectorLiteralNode.ZExpression">
            <summary>
                The expression node used to initialize the Z Axis Component of the vector literal.
                This should never be null.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVectorLiteralNode.SourceRangeOpenBracket">
            <summary>
                The source code range of the opening '&lt;' bracket of the vector literal.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVectorLiteralNode.SourceRangeCloseBracket">
            <summary>
                The source code range of the closing '&gt;' bracket of the vector literal.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVectorLiteralNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVectorLiteralNode.Clone">
            <summary>
                Deep clones the expression node.  It should clone the node and all of its children and cloneable properties, except
                the parent.
                When cloned, the parent node reference should be left <c>null</c>.
            </summary>
            <returns>A deep clone of this expression tree node.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVectorLiteralNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVectorLiteralNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLVectorLiteralNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVectorLiteralNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVectorLiteralNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVectorLiteralNode.SourceRangeCommaOne">
            <summary>
                The source code range of the first component separator comma to appear in the vector literal.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVectorLiteralNode.SourceRangeCommaTwo">
            <summary>
                The source code range of the second component separator comma to appear in the vector literal.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVectorLiteralNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVectorLiteralNode.Type">
            <summary>
                The return type of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLType" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVectorLiteralNode.ExpressionType">
            <summary>
                The expression type/classification of the expression. see: <see cref="T:LibLSLCC.CodeValidator.LSLExpressionType" />
            </summary>
            <value>
                The type of the expression.
            </value>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVectorLiteralNode.IsConstant">
            <summary>
                True if the expression is constant and can be calculated at compile time.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVectorLiteralNode.HasPossibleSideEffects">
            <summary>
                True if the expression statement has some modifying effect on a local parameter or global/local variable;  or is a
                function call.  False otherwise.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVectorLiteralNode.DescribeType">
            <summary>
                Should produce a user friendly description of the expressions return type. <para/>
                This is used in some syntax error messages, Ideally you should enclose your description in
                parenthesis or something that will make it stand out in a string.
            </summary>
            <returns>A use friendly description of the node's <see cref="P:LibLSLCC.CodeValidator.LSLVectorLiteralNode.Type"/>.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode">
            <summary>
                Base read only interface for syntax tree nodes.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.Parent">
            <summary>
                The read only interface of the parent node of this syntax tree node.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be <c>null</c>.</remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLSyntaxTreeNode">
            <summary>
                Base interface for syntax tree nodes.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLSyntaxTreeNode.Parent">
            <summary>
                The parent node of this syntax tree node.
                The parent node may only be assigned once, and may not be assigned <c>null</c>
            </summary>
            <remarks>
                Throw <see cref="T:System.InvalidOperationException" /> upon a detected second assignment,
                Throw <see cref="T:System.ArgumentNullException" /> if assigned null.
            </remarks>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLDoLoopNode">
            <summary>
                AST node interface for do-while loop statements.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLDoLoopNode.SourceRangeOpenParenth">
            <summary>
                The source code range of the opening parenthesis of the condition expression area.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLDoLoopNode.SourceRangeCloseParenth">
            <summary>
                The source code range of the closing parenthesis of the condition expression area.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLDoLoopNode.SourceRangeDoKeyword">
            <summary>
                The source code range of the 'do' keyword in the statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLDoLoopNode.SourceRangeWhileKeyword">
            <summary>
                The source code range of the 'while' keyword in the statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLDoLoopNode.SourceRangeSemicolon">
            <summary>
                The source code range of the semi-colon after the do-while loop statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLForLoopNode">
            <summary>
                AST node interface for for-loop statements.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLForLoopNode.SourceRangeForKeyword">
            <summary>
                The source code range of the 'for' keyword in the statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLForLoopNode.SourceRangeOpenParenth">
            <summary>
                The source code range of the opening parenthesis that starts the for-loop clauses area.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLForLoopNode.InitExpressionList">
            <summary>
                The expression list node that contains the expressions used in the initialization clause of the for-loop.
                This property should never be null unless the for loop node is an erroneous node.
                Ideally you should not be handling a syntax tree containing syntax errors.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLForLoopNode.SourceRangeFirstSemicolon">
            <summary>
                The source code range of the semi-colon that separates the initialization clause from the condition clause of the
                for-loop;
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLForLoopNode.SourceRangeSecondSemicolon">
            <summary>
                The source code range of the semi-colon that separates the condition clause from the afterthought expressions of
                the for-loop;
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLForLoopNode.SourceRangeCloseParenth">
            <summary>
                The source code range of the closing parenthesis that ends the for-loop clause section.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLForLoopNode.AfterthoughtExpressionList">
            <summary>
                The expression list node that contains the expressions used in the afterthought area of the for-loop's clauses.
                This property should never be null unless the for loop node is an erroneous node.
                Ideally you should not be handling a syntax tree containing syntax errors.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLForLoopNode.HasInitExpressions">
            <summary>
                Returns true if the for-loop statement contains any initialization expressions, otherwise False.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLForLoopNode.HasConditionExpression">
            <summary>
                Returns true if the for-loop statement contains a condition expression, otherwise False.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLForLoopNode.HasAfterthoughtExpressions">
            <summary>
                Returns true if the for-loop statement contains any afterthought expressions, otherwise False.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLWhileLoopNode">
            <summary>
                AST node interface for while-loop statements.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLWhileLoopNode.SourceRangeWhileKeyword">
            <summary>
                The source code range of the 'while' keyword in the while loop statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLWhileLoopNode.SourceRangeOpenParenth">
            <summary>
                The source code range of the opening parenthesis starting the condition area of a while loop statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLWhileLoopNode.SourceRangeCloseParenth">
            <summary>
                The source code range of the closing parenthesis ending the condition area of a while loop statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLLoopNode">
            <summary>
                AST node interface for all loop type nodes that rely on a loop condition.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLLoopNode.ConditionExpression">
            <summary>
                The condition expression that controls the loop.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLLoopNode.Code">
            <summary>
                The code scope node that represents the code scope of the loop body.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLDoLoopNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLDoLoopNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDoLoopNode.#ctor(LibLSLCC.CodeValidator.LSLCodeScopeNode,LibLSLCC.CodeValidator.ILSLExprNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLDoLoopNode" /> with a <see cref="P:LibLSLCC.CodeValidator.LSLDoLoopNode.ParentScopeId" /> of zero, condition and code body.
            </summary>
            <param name="condition">The <see cref="P:LibLSLCC.CodeValidator.LSLDoLoopNode.ConditionExpression" />.</param>
            <param name="code">The <see cref="P:LibLSLCC.CodeValidator.LSLDoLoopNode.Code" />.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="code" /> or <paramref name="condition" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDoLoopNode.#ctor(LibLSLCC.AntlrParser.LSLParser.DoLoopContext,LibLSLCC.CodeValidator.LSLCodeScopeNode,LibLSLCC.CodeValidator.ILSLExprNode)">
            <exception cref="T:System.ArgumentNullException">
                <paramref name="code" /> or <paramref name="conditionExpression" /> is
                <c>null</c>.
            </exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDoLoopNode.Code">
            <summary>
                The code scope node that represents the code scope of the loop body.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDoLoopNode.ConditionExpression">
            <summary>
                The condition expression that controls the loop, this could be null in the case of for-loops.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDoLoopNode.LibLSLCC#CodeValidator#ILSLLoopNode#ConditionExpression">
            <summary>
                The condition expression that controls the loop, this could be null in the case of for-loops.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDoLoopNode.ParentScopeId">
            <summary>
                Represents an ID number for the scope this code statement is in, they are unique per-function/event handler.
                this is not the scopes level.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDoLoopNode.SourceRangeOpenParenth">
            <summary>
                The source code range of the opening parenthesis of the condition expression area.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDoLoopNode.SourceRangeCloseParenth">
            <summary>
                The source code range of the closing parenthesis of the condition expression area.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDoLoopNode.SourceRangeDoKeyword">
            <summary>
                The source code range of the 'do' keyword in the statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDoLoopNode.SourceRangeWhileKeyword">
            <summary>
                The source code range of the 'while' keyword in the statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDoLoopNode.SourceRangeSemicolon">
            <summary>
                The source code range of the semi-colon after the do-while loop statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDoLoopNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDoLoopNode.InsideSingleStatementScope">
            <summary>
                True if this statement belongs to a single statement code scope.
                A single statement code scope is a braceless code scope that can be used in control or loop statements.
            </summary>
            <seealso cref="P:LibLSLCC.CodeValidator.ILSLCodeScopeNode.IsSingleStatementScope" />
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDoLoopNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDoLoopNode.IsLastStatementInScope">
            <summary>
                Is this statement the last statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDoLoopNode.DeadCodeType">
            <summary>
                The type of dead code that this statement is considered to be, if it is dead
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDoLoopNode.IsDeadCode">
            <summary>
                Is this statement dead code
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDoLoopNode.StatementIndex">
            <summary>
                The index of this statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDoLoopNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLDoLoopNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDoLoopNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDoLoopNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDoLoopNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDoLoopNode.HasReturnPath">
            <summary>
                True if the node represents a return path out of its ILSLCodeScopeNode parent, False otherwise.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLForLoopNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLForLoopNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLForLoopNode.#ctor(LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.LSLCodeScopeNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLForLoopNode" /> without init expressions or afterthought expressions.
            </summary>
            <param name="condition">The for loop condition expression, may be <c>null</c>.</param>
            <param name="code">The code body of the for loop.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLForLoopNode.#ctor(LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.LSLExpressionListNode,LibLSLCC.CodeValidator.LSLCodeScopeNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLForLoopNode" /> without init expressions.
            </summary>
            <param name="condition">The for loop condition expression, may be <c>null</c>.</param>
            <param name="afterthoughtExpressions">The afterthought expression list.</param>
            <param name="code">The code body of the for loop.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="afterthoughtExpressions" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLForLoopNode.#ctor(LibLSLCC.CodeValidator.LSLExpressionListNode,LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.LSLCodeScopeNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLForLoopNode" /> without afterthought expressions.
            </summary>
            <param name="initExpressions">The init expression list.</param>
            <param name="condition">The for loop condition expression, may be <c>null</c>.</param>
            <param name="code">The code body of the for loop.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="initExpressions" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLForLoopNode.#ctor(LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.LSLCodeScopeNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLForLoopNode" /> with all possible children.
            </summary>
            <param name="initExpression">The init expression.</param>
            <param name="condition">The for loop condition expression, may be <c>null</c>.</param>
            <param name="afterthoughtExpression">The afterthought expression.</param>
            <param name="code">The code body of the for loop.</param>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="initExpression" /> or
                <paramref name="afterthoughtExpression" /> or <paramref name="code" /> is <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLForLoopNode.#ctor(LibLSLCC.CodeValidator.LSLExpressionListNode,LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.LSLExpressionListNode,LibLSLCC.CodeValidator.LSLCodeScopeNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLForLoopNode" /> with all possible children.
            </summary>
            <param name="initExpressions">The init expression list.</param>
            <param name="condition">The for loop condition expression, may be <c>null</c>.</param>
            <param name="afterthoughtExpressions">The afterthought expression list.</param>
            <param name="code">The code body of the for loop.</param>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="initExpressions" /> or
                <paramref name="afterthoughtExpressions" /> or <paramref name="code" /> is <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLForLoopNode.#ctor(LibLSLCC.AntlrParser.LSLParser.ForLoopContext,LibLSLCC.CodeValidator.LSLExpressionListNode,LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.LSLExpressionListNode,LibLSLCC.CodeValidator.LSLCodeScopeNode)">
            <exception cref="T:System.ArgumentNullException">
                <paramref name="context" /> or <paramref name="initExpression" /> or
                <paramref name="afterthoughtExpressionsList" /> or <paramref name="code" /> is <c>null</c>.
            </exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLForLoopNode.InitExpressionList">
            <summary>
                The expression list node that contains the expressions used in the initialization clause of the for-loop.
                This property should never be null unless the for loop node is an erroneous node.
                Ideally you should not be handling a syntax tree containing syntax errors.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLForLoopNode.ConditionExpression">
            <summary>
                The condition expression that controls the loop.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLForLoopNode.AfterthoughtExpressionList">
            <summary>
                The expression list node that contains the expressions used in the afterthought area of the for-loop's clauses.
                This property should never be null unless the for loop node is an erroneous node.
                Ideally you should not be handling a syntax tree containing syntax errors.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLForLoopNode.Code">
            <summary>
                The code scope node that represents the code scope of the loop body.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLForLoopNode.HasInitExpressions">
            <summary>
                Returns true if the for-loop statement contains any initialization expressions, otherwise False.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLForLoopNode.HasConditionExpression">
            <summary>
                Returns true if the for-loop statement contains a condition expression, otherwise False.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLForLoopNode.HasAfterthoughtExpressions">
            <summary>
                Returns true if the for-loop statement contains any afterthought expressions, otherwise False.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLForLoopNode.DeadCodeType">
            <summary>
                The type of dead code that this statement is considered to be, if it is dead
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLForLoopNode.ParentScopeId">
            <summary>
                Represents an ID number for the scope this code statement is in, they are unique per-function/event handler.
                this is not the scopes level.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLForLoopNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLForLoopNode.InsideSingleStatementScope">
            <summary>
                True if this statement belongs to a single statement code scope.
                A single statement code scope is a braceless code scope that can be used in control or loop statements.
            </summary>
            <seealso cref="P:LibLSLCC.CodeValidator.ILSLCodeScopeNode.IsSingleStatementScope" />
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLForLoopNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLForLoopNode.IsLastStatementInScope">
            <summary>
                Is this statement the last statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLForLoopNode.IsDeadCode">
            <summary>
                Is this statement dead code
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLForLoopNode.StatementIndex">
            <summary>
                The index of this statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLForLoopNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLForLoopNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLForLoopNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLForLoopNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLForLoopNode.SourceRangeForKeyword">
            <summary>
                The source code range of the 'for' keyword in the statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLForLoopNode.SourceRangeFirstSemicolon">
            <summary>
                The source code range of the semi-colon that separates the initialization clause from the condition clause of the
                for-loop;
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLForLoopNode.SourceRangeSecondSemicolon">
            <summary>
                The source code range of the semi-colon that separates the condition clause from the afterthought expressions of
                the for-loop;
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLForLoopNode.SourceRangeOpenParenth">
            <summary>
                The source code range of the opening parenthesis that starts the for-loop clauses area.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLForLoopNode.SourceRangeCloseParenth">
            <summary>
                The source code range of the closing parenthesis that ends the for-loop clause section.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLForLoopNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLForLoopNode.HasReturnPath">
            <summary>
                True if the node represents a return path out of its ILSLCodeScopeNode parent, False otherwise.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLWhileLoopNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLWhileLoopNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLWhileLoopNode.#ctor(LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.LSLCodeScopeNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLWhileLoopNode" /> with a <see cref="P:LibLSLCC.CodeValidator.LSLWhileLoopNode.ParentScopeId" /> of zero, condition and code body.
            </summary>
            <param name="condition">The <see cref="P:LibLSLCC.CodeValidator.LSLWhileLoopNode.ConditionExpression" />.</param>
            <param name="code">The <see cref="P:LibLSLCC.CodeValidator.LSLWhileLoopNode.Code" />.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition" /> or <paramref name="code" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLWhileLoopNode.#ctor(LibLSLCC.AntlrParser.LSLParser.WhileLoopContext,LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.LSLCodeScopeNode)">
            <exception cref="T:System.ArgumentNullException">
                <paramref name="code" /> or <paramref name="conditionExpression" /> is
                <c>null</c>.
            </exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLWhileLoopNode.ConditionExpression">
            <summary>
                The condition expression that controls the loop.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLWhileLoopNode.Code">
            <summary>
                The code scope node that represents the code scope of the loop body.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLWhileLoopNode.InsideSingleStatementScope">
            <summary>
                True if this statement belongs to a single statement code scope.
                A single statement code scope is a braceless code scope that can be used in control or loop statements.
            </summary>
            <seealso cref="P:LibLSLCC.CodeValidator.ILSLCodeScopeNode.IsSingleStatementScope" />
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLWhileLoopNode.DeadCodeType">
            <summary>
                The type of dead code that this statement is considered to be, if it is dead
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLWhileLoopNode.ParentScopeId">
            <summary>
                Represents an ID number for the scope this code statement is in, they are unique per-function/event handler.
                this is not the scopes level.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLWhileLoopNode.HasReturnPath">
            <summary>
                True if the node represents a return path out of its ILSLCodeScopeNode parent, False otherwise.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLWhileLoopNode.StatementIndex">
            <summary>
                The index of this statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLWhileLoopNode.IsLastStatementInScope">
            <summary>
                Is this statement the last statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLWhileLoopNode.IsDeadCode">
            <summary>
                Is this statement dead code
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLWhileLoopNode.SourceRangeWhileKeyword">
            <summary>
                The source code range of the 'while' keyword in the while loop statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLWhileLoopNode.SourceRangeOpenParenth">
            <summary>
                The source code range of the opening parenthesis starting the condition area of a while loop statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLWhileLoopNode.SourceRangeCloseParenth">
            <summary>
                The source code range of the closing parenthesis ending the condition area of a while loop statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLWhileLoopNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLWhileLoopNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLWhileLoopNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLWhileLoopNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLWhileLoopNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLWhileLoopNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLWhileLoopNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLSourceCodeRange">
            <summary>
                Represents a range in LSL source code.
            </summary>
            <remarks>Immutable.</remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLSourceCodeRange.#ctor">
            <summary>
                Construct an empty source code range.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLSourceCodeRange.#ctor(Antlr4.Runtime.IToken)">
            <summary>
                Internal constructor for creating an <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> from an ANTLR IToken.
            </summary>
            <param name="ctx">The ANTLR IToken</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="ctx" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLSourceCodeRange.#ctor(Antlr4.Runtime.IToken,Antlr4.Runtime.IToken)">
            <summary>
                Internal constructor for creating an <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> that encompasses two ANTLR ITokens.
            </summary>
            <param name="start">The first ANTLR IToken</param>
            <param name="end">The second ANTLR IToken</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="start" /> or <paramref name="end" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">If start and end overlap.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLSourceCodeRange.#ctor(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Creates a source code range that spans two <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> objects.
            </summary>
            <param name="start">The <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode" /> where the source code range starts.</param>
            <param name="end">The <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode" /> where the source code range ends.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="start" /> or <paramref name="end" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">If start and end overlap.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLSourceCodeRange.#ctor(Antlr4.Runtime.ParserRuleContext)">
            <summary>
                Internal function for creating an <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> from an ANTLR ParserRuleContext.
            </summary>
            <param name="ctx">The ANTLR ParserRuleContext</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="ctx" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLSourceCodeRange.#ctor(LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode)">
            <summary>
                Creates a source code range from an <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode" />
            </summary>
            <param name="node">The syntax tree node to create the <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="node" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable"/> == <c>false</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLSourceCodeRange.#ctor(LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode,LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode)">
            <summary>
                Creates a source code range that spans two <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode" /> objects.
            </summary>
            <param name="start">The <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode" />where the source code range starts.</param>
            <param name="end">The <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode" />where the source code range ends.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="start" /> or <paramref name="end" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">
                If <paramref name="start" />.SourceRangesAvailable or <paramref name="end" />
                .SourceRangesAvailable are false.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLSourceCodeRange.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                Manually create a source code range by providing all of the source code range details.
            </summary>
            <param name="lineStart">Line where the range starts.</param>
            <param name="columnStart">Character column where the range starts.</param>
            <param name="lineEnd">Line where the range ends.</param>
            <param name="columnEnd">Character column where the range ends.</param>
            <param name="startIndex">The index in the source code where range starts.</param>
            <param name="stopIndex">The index in the source code where the range ends.</param>
            <exception cref="T:System.ArgumentException">
                if <paramref name="lineStart" /> is greater than <paramref name="lineEnd" /> or
                <paramref name="startIndex" /> is greater than <paramref name="stopIndex" />.
            </exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSourceCodeRange.IsSingleLine">
            <summary>
                <c>true</c> <see cref="P:LibLSLCC.CodeValidator.LSLSourceCodeRange.IsEmpty" /> is <c>false</c> and <see cref="P:LibLSLCC.CodeValidator.LSLSourceCodeRange.LineEnd" /> == <see cref="P:LibLSLCC.CodeValidator.LSLSourceCodeRange.LineStart" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSourceCodeRange.IsEmpty">
            <summary>
                <c>true</c> if this <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> was constructed without parameters and represents an empty
                source range.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSourceCodeRange.LineStart">
            <summary>
                Line where the source code range starts.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSourceCodeRange.LineEnd">
            <summary>
                Line where the source code range ends.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSourceCodeRange.ColumnStart">
            <summary>
                Character column where the source code range starts.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSourceCodeRange.ColumnEnd">
            <summary>
                Character column where the source code range ends.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSourceCodeRange.StartIndex">
            <summary>
                Character index in the source code where the source code range starts.
                This value is only relevant if HasIndexInfo is set to true.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSourceCodeRange.StopIndex">
            <summary>
                Character index in the source code where the source code range ends.
                This value is only relevant if HasIndexInfo is set to true.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSourceCodeRange.Length">
            <summary>
                The length of the source code range in characters.  Calculated as ((StopIndex - StartIndex) + 1).
                This value is only relevant if HasIndexInfo is set to true.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSourceCodeRange.FirstCharRange">
            <summary>
                Get a source code range for the first character in this <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" />.
                The return value is only relevant if HasIndexInfo is set to true.
            </summary>
            <value>The source code range of the first character in this <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" />.</value>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSourceCodeRange.LastCharRange">
            <summary>
                Get a source code range for the last character in this <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" />.
                The return value is only relevant if HasIndexInfo is set to true.
            </summary>
            <value>The source code range of the last character in this <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" />.</value>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLSourceCodeRange.ToString">
            <summary>
                Gets a string representation of the source code range.
                In the format: "(LineStart: 0, LineEnd: 0, ColumnStart: 0, ColumnEnd: 0, StartIndex: 0, StopIndex: 0)"
            </summary>
            <returns>The string representation of the source code range.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLSourceCodeRange.Equals(System.Object)">
            <summary>
                Determines if this source code range object is exactly equal to another.  (All properties are equal)
                If 'obj' is not an <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> object this function always returns false.
            </summary>
            <param name="obj">The other <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange"/>.</param>
            <returns><c>true</c> if equal.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLSourceCodeRange.Equals(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Determines if this source code range object is exactly equal to another.  (All properties are equal)
            </summary>
            <param name="other">The other <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange"/>.</param>
            <returns><c>true</c> if equal.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLSourceCodeRange.op_Equality(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Determines if this source code range object is exactly equal to another.  (All properties are equal)
            </summary>
            <param name="left">The left <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange"/>.</param>
            <param name="right">The right <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange"/>.</param>
            <returns><c>true</c> if equal.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLSourceCodeRange.op_Inequality(LibLSLCC.CodeValidator.LSLSourceCodeRange,LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Determines if this source code range object is inequal to another.  (All properties are inequal)
            </summary>
            <param name="left">The left <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange"/>.</param>
            <param name="right">The right <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange"/>.</param>
            <returns><c>true</c> if inequal.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLSourceCodeRange.GetHashCode">
            <summary>
                Generates a hash code for this <see cref="T:LibLSLCC.CodeValidator.LSLSourceCodeRange" /> using all of its properties.
            </summary>
            <returns>The generated hash code.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLCodeScopeNode">
            <summary>
                AST node interface for code scopes.
                Includes function, event handler, control/loop statement code body's, and anonymous code scopes.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCodeScopeNode.CodeStatements">
            <summary>
                Code statements that are children of this code scope, this will never be <c>null</c> but it may be empty.
            </summary>
            <seealso cref="P:LibLSLCC.CodeValidator.ILSLCodeScopeNode.HasCodeStatements" />
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCodeScopeNode.HasCodeStatements">
            <summary>
                True if this code scope contains any code statements.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCodeScopeNode.ScopeId">
            <summary>
                The scope ID of this code scope.
                All child statements will inherit this ID.
            </summary>
            <seealso cref="P:LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement.ParentScopeId"/>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCodeScopeNode.IsSingleStatementScope">
            <summary>
                True if this code scope is an implicit braceless code scope.
                Bracless code scopes can only occur as the code body in loop type constructs and control statements.
            </summary>
            <seealso cref="P:LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement.InsideSingleStatementScope" />
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCodeScopeNode.CodeScopeType">
            <summary>
                The type of code scope this node represents.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLCompilationUnitNode">
            <summary>
                AST node interface for the top level node in an LSL syntax tree.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCompilationUnitNode.Comments">
            <summary>
                A list of objects describing the comments found in the source code and their position/range.
                Should never be <c>null</c>, even if there are no comments.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCompilationUnitNode.GlobalVariableDeclarations">
            <summary>
                Global variable declaration nodes, in order of appearance.
                Returns an empty list if none exist.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCompilationUnitNode.FunctionDeclarations">
            <summary>
                User defined function nodes, in order of appearance.
                Returns an empty list if none exist.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCompilationUnitNode.StateDeclarations">
            <summary>
                User defined state nodes, in order of appearance.
                Returns an empty list if none exist.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCompilationUnitNode.DefaultStateNode">
            <summary>
                The state node for the default script state.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLEventHandlerNode">
            <summary>
                AST node interface for library event handler references.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLEventHandlerNode.Name">
            <summary>
                The name of the event handler.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLEventHandlerNode.Code">
            <summary>
                The code scope node that represents the code body of the event handler.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLEventHandlerNode.ParameterList">
            <summary>
                The parameter list node for the parameters of the event handler.  This is non null even when no parameters exist.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLEventHandlerNode.SourceRangeName">
            <summary>
                The source code range of the event handler name.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLFunctionDeclarationNode">
            <summary>
                AST node interface for function declaration nodes.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionDeclarationNode.References">
            <summary>
                A list of function call nodes that reference this function definition, or an empty list.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionDeclarationNode.ReturnTypeName">
            <summary>
                The string from the source code that represents the return type assigned to the function definition,
                or an empty string if no return type was assigned.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionDeclarationNode.Name">
            <summary>
                The name of the function.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionDeclarationNode.SourceRangeName">
            <summary>
                The source code range of the function name
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionDeclarationNode.SourceRangeReturnType">
            <summary>
                The source code range of the function return type, or <c>null</c> if no return type was specified.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionDeclarationNode.ReturnType">
            <summary>
                The return type assigned to the function definition, it will be <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" /> if no return type was
                given.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionDeclarationNode.ParameterList">
            <summary>
                The parameter list node that contains the parameter list definitions for this function.
                It should never be null, even if the function definition contains no parameter definitions.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLFunctionDeclarationNode.Code">
            <summary>
                The code scope node that represents the code body of the function definition.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLStateScopeNode">
            <summary>
                AST node interface for code state blocks.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLStateScopeNode.StateName">
            <summary>
                The name of the state block in the source code.
                'default' should be returned if the node represents the default state.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLStateScopeNode.IsDefaultState">
            <summary>
                True if this state scope node represents the 'default' state,  False if it is a user defined state.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLStateScopeNode.EventHandlers">
            <summary>
                A list of event handlers nodes for each event handler that was used in the state.
                This should never be empty.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLStateScopeNode.SourceRangeOpenBrace">
            <summary>
                The source code range of the opening brace of the state block's scope.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLStateScopeNode.SourceRangeCloseBrace">
            <summary>
                The source code range of the closing brace of the state block's scope.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLStateScopeNode.SourceRangeStateName">
            <summary>
                The source code range where the name of the state is located.
                For the default state, this will be the location of the 'default' keyword.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLStateScopeNode.SourceRangeStateKeyword">
            <summary>
                The source code range where the state keyword is located.
                For the default state, this will be the location of the 'default' keyword.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLCodeScopeNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLCodeScopeNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.PreDefineLabel(LibLSLCC.CodeValidator.LSLLabelStatementNode)">
            <summary>
            Sets a labels parent to this <see cref="T:LibLSLCC.CodeValidator.LSLCodeScopeNode"/>, also sets <see cref="P:LibLSLCC.CodeValidator.LSLLabelStatementNode.ParentScopeId"/> to this nodes <see cref="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.ScopeId"/>.
            </summary>
            <param name="label">The label node to take pre define ownership of.</param>
            <returns><paramref name="label"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="label"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.#ctor(System.Int32)">
            <summary>
                Create a <see cref="T:LibLSLCC.CodeValidator.LSLCodeScopeNode" /> with the given scope ID.
            </summary>
            <param name="scopeId">The <see cref="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.ParentScopeId"/>.</param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.#ctor(System.Int32,System.Collections.Generic.IEnumerable{LibLSLCC.CodeValidator.ILSLCodeStatement})">
            <summary>
                Construct an  <see cref="T:LibLSLCC.CodeValidator.LSLCodeScopeNode" /> with the given scope ID and statements. <para/>
                <see cref="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.EndScope" /> is called after adding the statements in the enumerable, you will not be able to add more statements with <see cref="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.AddStatement(LibLSLCC.CodeValidator.ILSLCodeStatement)" />. <para/>
                If only a single statement is added <see cref="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.IsSingleStatementScope"/> will be <c>true</c>.
            </summary>
            <param name="scopeId">The <see cref="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.ParentScopeId"/>.</param>
            <param name="statements">The statements to add to the code scope.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="statements" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.#ctor(System.Int32,LibLSLCC.CodeValidator.ILSLExprNode[])">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLCodeScopeNode" /> with the given scope ID and expressions as statements.  <para/>
                An <see cref="T:LibLSLCC.CodeValidator.LSLExpressionStatementNode"/> is implicitly created for each <see cref="T:LibLSLCC.CodeValidator.ILSLExprNode"/>. <para/>
                <see cref="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.EndScope" /> is called after adding the statements, you will not be able to add more statements with <see cref="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.AddStatement(LibLSLCC.CodeValidator.ILSLCodeStatement)" />. <para/>
                If only a single expression is added <see cref="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.IsSingleStatementScope"/> will be <c>true</c>.
            </summary>
            <param name="scopeId">The <see cref="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.ParentScopeId"/>.</param>
            <param name="expressions">The expressions to use as statements in the single statement code scope.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="expressions" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.#ctor(System.Int32,LibLSLCC.CodeValidator.ILSLCodeStatement[])">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLCodeScopeNode" /> with the given scope ID and statements. <para/>
                <see cref="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.EndScope" /> is called after adding the statements, you will not be able to add more statements with <see cref="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.AddStatement(LibLSLCC.CodeValidator.ILSLCodeStatement)" />. <para/>
                If only a single statement is added <see cref="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.IsSingleStatementScope"/> will be <c>true</c>.
            </summary>
            <param name="scopeId">The <see cref="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.ParentScopeId"/>.</param>
            <param name="statements">The statements to add to the code scope.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="statements" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.#ctor(LibLSLCC.AntlrParser.LSLParser.CodeScopeContext,System.Int32)">
            <exception cref="T:System.ArgumentNullException"><paramref name="context" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.#ctor(LibLSLCC.AntlrParser.LSLParser.CodeStatementContext,System.Int32,LibLSLCC.CodeValidator.ILSLCodeStatement)">
            <exception cref="T:System.ArgumentNullException"><paramref name="context" /> or <paramref name="statement" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.ConstantJumps">
            <summary>
                Constant jump descriptors for constant jumps that occur in this scope
                used only with JumpStatementAnalysis is turned on and dead code caused by
                jump statements is being detected.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.HasReturnStatementNode">
            <summary>
                ReturnStatementNode != null
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.HasDeadStatementNodes">
            <summary>
                FirstDeadStatementNode != null
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.FirstDeadStatementNode">
            <summary>
                The first statement node to be considered dead, when dead code is detected
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.DeadCodeSegments">
            <summary>
                Returns descriptions of all dead code segments in the top level of this scope,
                if there are any
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.ReturnStatementNode">
            <summary>
                The top level return statement for a code scope, if one exists
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.ReturnPath">
            <summary>
                The statement that acts as the return path for this scope, if there is one
            </summary>
            <remarks>
                This can be a <see cref="T:LibLSLCC.CodeValidator.LSLReturnStatementNode" /> or an <see cref="T:LibLSLCC.CodeValidator.LSLControlStatementNode" />
                as of the current implementation,  loop statements cannot currently
                act as a sole return path; there is no constant evaluation in condition
                statements so they are equivalent to a singular if statement
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.InsideSingleStatementScope">
            <summary>
                Always <c>false</c> for <see cref="T:LibLSLCC.CodeValidator.LSLVariableDeclarationNode" />.
            </summary>
            <seealso cref="P:LibLSLCC.CodeValidator.ILSLCodeScopeNode.IsSingleStatementScope" />
            <exception cref="T:System.NotSupportedException" accessor="set">if <c>value</c> is <c>true</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.ScopeId">
            <summary>
                The scope ID of this code scope.
                All child statements will inherit this ID.
            </summary>
            <seealso cref="P:LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement.ParentScopeId"/>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.IsSingleStatementScope">
            <summary>
                True if this code scope is an implicit braceless scope.
                Bracless code scopes can only occur as the code body in loop type constructs and control statements. <para/>
                Setting this to <c>true</c> when the scope does not currently contain exactly one statement will cause an <see cref="T:System.ArgumentException"/> to be thrown.
            </summary>
            <exception cref="T:System.ArgumentException" accessor="set">If the code scope does not contain exactly one statement and <paramref name="value"/> is set to <c>true</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.CodeScopeType">
            <summary>
                The type of code scope this node represents.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.HasReturnPath">
            <summary>
                True if this code scope has a valid return path
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.CodeStatements">
            <summary>
                Code statements that are children of this code scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.HasCodeStatements">
            <summary>
                True if this code scope contains any child statements
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.DeadCodeType">
            <summary>
                The type of dead code that this statement is considered to be, if it is dead
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.ParentScopeId">
            <summary>
                Represents an ID number for the scope this code statement is in, they are unique per-function/event handler.
                this is not the scopes level.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.StatementIndex">
            <summary>
                The index of this statement in its parent scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.IsLastStatementInScope">
            <summary>
                Is this the last statement in its parent scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.IsDeadCode">
            <summary>
                Is this statement considered dead code
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.AddStatement(LibLSLCC.CodeValidator.ILSLExprNode)">
            <summary>
            Convenience method to add a new <seealso cref="T:LibLSLCC.CodeValidator.LSLExpressionStatementNode"/> via <seealso cref="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.AddStatement(LibLSLCC.CodeValidator.ILSLCodeStatement)"/>.
            </summary>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.AddStatement(LibLSLCC.CodeValidator.ILSLCodeStatement)"/>
            <seealso cref="T:LibLSLCC.CodeValidator.LSLExpressionStatementNode"/>
            <param name="expression"></param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.AddStatement(LibLSLCC.CodeValidator.ILSLCodeStatement)">
            <summary>
                Add a code statement to the code scope, the dead code detection algorithm is encapsulated inside
                of this object, the algorithm is on-line and most of its logic occurs in this function
            </summary>
            <remarks>
                if JumpStatementAnalysis is enabled, this function expects the JumpTarget of every
                <see cref="T:LibLSLCC.CodeValidator.LSLJumpStatementNode" /> object (the <see cref="T:LibLSLCC.CodeValidator.LSLLabelStatementNode" /> reference) to have a correct
                StatementIndex and ScopeId already. this includes JumpTarget's that are jumps forward in code
                and have not been added to the code scope yet.  this prerequisite should be accomplished
                with a pre-pass that creates the jump graph ahead of time. so that all Jump statement objects
                have a reference to where they jump to exactly, and all label statements have references to
                the jump statements that jump to to them.
            </remarks>
            <param name="statement">The statement to add to the code scope</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="statement" /> is <c>null</c>.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.EndScope"/> has already been called.</exception>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.EndScope" />
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.EndScope">
            <summary>
                Must be called after all statements have been added to the code scope; in order to
                tell the dead code detection algorithm that the end of the scope has been reached.
            </summary>
            <exception cref="T:System.InvalidOperationException"><see cref="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.EndScope"/> has already been called.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.SourceRange">
            <summary>
                The source code range this statement occupies in the source code
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLCodeScopeNode._deadCodeSegments">
            <summary>
                When the dead code segment ends, the segment is put in this list and made public
                and readonly through the DeadCodeSegments Property
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLCodeScopeNode._deadCodeSegmentsStack">
            <summary>
                The stack is used to keep track of the current dead code segment that statements
                are being put into
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLCodeScopeNode._deadCodeJumpOverEnding">
            <summary>
                Used to terminate dead code that was jumped over,
                when that case is detected, this is set to the statement index
                of the label we jumped to, so we can stop classifying nodes as dead
                once we reach that point
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLCodeScopeNode._inDeadJumpedOverCode">
            <summary>
                State to track if we are in the middle of a jump forward over statements
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLCodeScopeNode._insideDeadCode">
            <summary>
                State, set to true with the next add will be dead code
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement"/>'s in the code scope.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeScopeNode.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLCodeSegment">
            <summary>
            Code segments are used to describe a sequential set of code statement nodes that exist in the same scope.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeSegment.#ctor">
            <summary>
                Construct an empty code segment.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeSegment.SourceRange">
            <summary>
                The source code range that encompasses all <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement" /> objects in the <see cref="T:LibLSLCC.CodeValidator.LSLCodeSegment"/>.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> for any added statements, this property will be <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeSegment.SourceRangeAvailable">
            <summary>
            <c>true</c> if <see cref="P:LibLSLCC.CodeValidator.LSLCodeSegment.SourceRange"/> could be calculated for this segment and is non <c>null</c>.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeSegment.StartNode">
            <summary>
                The <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement" /> at the start of the code segment.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeSegment.EndNode">
            <summary>
                The <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement" /> at the end of the code segment.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeSegment.StatementNodes">
            <summary>
                All <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement" /> in the code segment, in order of definition.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeSegment.AddStatement(LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement)">
            <summary>
                Adds an <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement" /> to the <see cref="T:LibLSLCC.CodeValidator.LSLCodeSegment" /> object.
            </summary>
            <param name="statement">The <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement" /> to add.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="statement"/> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLCompilationUnitNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLCompilationUnitNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCompilationUnitNode.#ctor">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLCompilationUnitNode" /> with an empty default state node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCompilationUnitNode.#ctor(LibLSLCC.CodeValidator.LSLStateScopeNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLCompilationUnitNode" /> with the provided default state node.
            </summary>
            <param name="defaultState">The default state node to use for the default state.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="defaultState" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="defaultState" />.IsDefaultState is <c>false</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCompilationUnitNode.#ctor(LibLSLCC.AntlrParser.LSLParser.CompilationUnitContext,LibLSLCC.Collections.IReadOnlyGenericArray{LibLSLCC.CodeValidator.LSLComment})">
            <exception cref="T:System.ArgumentNullException"><paramref name="context" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCompilationUnitNode.GlobalVariableDeclarations">
            <summary>
                Global variable declaration nodes, in order of appearance.
                Returns an empty list if none exist.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCompilationUnitNode.FunctionDeclarations">
            <summary>
                User defined function nodes, in order of appearance.
                Returns an empty list if none exist.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCompilationUnitNode.StateDeclarations">
            <summary>
                User defined state nodes, in order of appearance.
                Returns an empty list if none exist.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCompilationUnitNode.DefaultState">
            <summary>
                The state node for the default script state.
            </summary>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCompilationUnitNode.Comments">
            <summary>
                A list of objects describing the comments found in the source code and their position/range.
                Will always be non null, even if there are no comments.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCompilationUnitNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCompilationUnitNode.Add(LibLSLCC.CodeValidator.LSLVariableDeclarationNode)">
            <summary>
                Add a global variable declaration node to this compilation unit node.
            </summary>
            <param name="declaration">The global variable declaration node to add.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if the 'declaration' parameter is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCompilationUnitNode.Add(LibLSLCC.CodeValidator.LSLFunctionDeclarationNode)">
            <summary>
                Add a function declaration node to this compilation unit node.
            </summary>
            <param name="declaration">The function declaration node to add.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if the 'declaration' parameter is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCompilationUnitNode.Add(LibLSLCC.CodeValidator.LSLStateScopeNode)">
            <summary>
                Add a state declaration node to this compilation unit node.
            </summary>
            <param name="declaration">The state declaration node to add.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if the 'declaration' parameter is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCompilationUnitNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLCompilationUnitNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCompilationUnitNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCompilationUnitNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCompilationUnitNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCompilationUnitNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLConstantJumpDescription">
            <summary>
                Represents a statement that causes a jump to happen in a constant manner.
                As in:  There is no condition under which a jump to a single known label will not occur.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantJumpDescription.#ctor(LibLSLCC.CodeValidator.LSLConstantJumpDescription,LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLConstantJumpDescription" /> from another <see cref="T:LibLSLCC.CodeValidator.LSLConstantJumpDescription" /> and
                an <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement" /> that represents the actual jump statement in the syntax tree. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLConstantJumpDescription.DeterminingJump"/> in the constructed object is set to <paramref name="originalJump"/>.DeterminingJump. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLConstantJumpDescription.EffectiveJumpStatement"/> in the constructed object is set to the <paramref name="effectiveJumpStatement"/> parameter.
            </summary>
            <param name="originalJump">The <see cref="T:LibLSLCC.CodeValidator.LSLConstantJumpDescription"/> to copy the DeterminingJump property from.</param>
            <param name="effectiveJumpStatement">
                The <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement" /> that represents the jump statement in
                the syntax tree.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="originalJump"/> or <paramref name="effectiveJumpStatement"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantJumpDescription.#ctor(LibLSLCC.CodeValidator.ILSLJumpStatementNode)">
            <summary>
                Constructs an <see cref="T:LibLSLCC.CodeValidator.LSLConstantJumpDescription" /> from an ILSLJumpStatement node by
                setting the DeterminingJump and EffectiveJumpStatement property in this object to the determiningJump parameter.
            </summary>
            <param name="determiningJump">
                The <see cref="T:LibLSLCC.CodeValidator.ILSLJumpStatementNode" /> to set DeterminingJump and
                EffectiveJumpStatement to.
            </param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLConstantJumpDescription.#ctor(LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement,LibLSLCC.CodeValidator.ILSLJumpStatementNode)">
            <summary>
                Constructs an <see cref="T:LibLSLCC.CodeValidator.LSLConstantJumpDescription" /> from an ILSLJumpStatement node by
                setting the DeterminingJump property of this object to the effectiveJumpStatement parameter, and
                the EffectiveJumpStatement of this object to the effectiveJumpStatement parameter.
            </summary>
            <param name="effectiveJumpStatement">The <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement" /> to set EffectiveJumpStatement to.</param>
            <param name="determiningJump">The <see cref="T:LibLSLCC.CodeValidator.ILSLJumpStatementNode" /> to set DeterminingJump to.</param>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLConstantJumpDescription.EffectiveJumpStatement">
            <summary>
                EffectiveJumpStatement should represent the statement that
                the jump will always occur from, it may be an <see cref="T:LibLSLCC.CodeValidator.LSLControlStatementNode" />
                where all branches jump to a single label in a constant manner, or simply an <see cref="T:LibLSLCC.CodeValidator.LSLJumpStatementNode" />
                on its own.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLConstantJumpDescription.DeterminingJump">
            <summary>
                The actual <see cref="T:LibLSLCC.CodeValidator.LSLJumpStatementNode" /> that caused or is part of the cause for the jump to happen
                if EffectiveJumpStatement is an <see cref="T:LibLSLCC.CodeValidator.LSLControlStatementNode" />, it will be the jump from the 'if' statement
                part of that node, otherwise EffectiveJumpStatement and DeterminingJump will be references to the same
                object.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLConstantJumpDescription.JumpTarget">
            <summary>
                The label node that DeterminingJump jumps to,
                it is equal to DeterminingJump.JumpTarget
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLDeadCodeSegment">
            <summary>
                A read only interface for <see cref="T:LibLSLCC.CodeValidator.LSLDeadCodeSegment"/>.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLDeadCodeSegment.DeadCodeType">
            <summary>
                The type of dead code that this <see cref="T:LibLSLCC.CodeValidator.LSLDeadCodeSegment" /> represents.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLDeadCodeSegment">
            <summary>
                A code segment type for housing a range of statement nodes that are considered to be dead. <para/>
                a <see cref="T:LibLSLCC.CodeValidator.LSLDeadCodeType"/> enum property is provided to describe what caused the code to be dead
            </summary>
            <seealso cref="T:LibLSLCC.CodeValidator.LSLCodeSegment"/>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLDeadCodeSegment.#ctor(LibLSLCC.CodeValidator.LSLDeadCodeType)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLDeadCodeSegment" /> with the given <see cref="T:LibLSLCC.CodeValidator.LSLDeadCodeType" />
            </summary>
            <param name="deadCodeType">The dead code type the segment represents.</param>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLDeadCodeSegment.DeadCodeType">
            <summary>
                The type of dead code that this <see cref="T:LibLSLCC.CodeValidator.LSLDeadCodeSegment" /> represents.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLDeadCodeType">
            <summary>
                Describes the cause of dead code
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLDeadCodeType.None">
            <summary>
                No dead code.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLDeadCodeType.AfterJumpOutOfScope">
            <summary>
                Dead code was found after a jump out of the current code scope.
                Such as an anonymous code scope, or a code scope that belongs to a control statement.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLDeadCodeType.AfterJumpLoopForever">
            <summary>
                Dead code was found after a constant jump that always results in an infinite loop.
                A constant jump is a jump that will always occur no matter what.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLDeadCodeType.JumpOverCode">
            <summary>
                A constant jump jumps over the dead code.
                A constant jump is a jump that will always occur no matter what.
            </summary>
        </member>
        <member name="F:LibLSLCC.CodeValidator.LSLDeadCodeType.AfterReturnPath">
            <summary>
                Dead code was found after a constant return path.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLEventHandlerNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLEventHandlerNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLEventHandlerNode.#ctor(System.String,LibLSLCC.CodeValidator.LSLParameterListNode,LibLSLCC.CodeValidator.LSLCodeScopeNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLEventHandlerNode" /> with the given parameter list and code body.
            </summary>
            <param name="name">The event handler name.</param>
            <param name="parameterList">The parameter list.</param>
            <param name="code">The code body.</param>
            <exception cref="T:System.ArgumentNullException">
                if <paramref name="name" /> or <paramref name="parameterList" /> or
                <paramref name="code" /> is <c>null</c>.
            </exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException"><paramref name="name" /> contained characters not allowed in an LSL ID token.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLEventHandlerNode.#ctor(System.String,LibLSLCC.CodeValidator.LSLCodeScopeNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLEventHandlerNode" /> with the given code body and no parameters.
            </summary>
            <param name="name">The event handler name.</param>
            <param name="code">The code body.</param>
            <exception cref="T:System.ArgumentNullException">if <paramref name="name" /> or <paramref name="code" /> is <c>null</c>.</exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException">
                <paramref name="name" /> provided contained characters not allowed in an LSL ID
                token.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLEventHandlerNode.#ctor(LibLSLCC.AntlrParser.LSLParser.EventHandlerContext,LibLSLCC.CodeValidator.LSLParameterListNode,LibLSLCC.CodeValidator.LSLCodeScopeNode)">
            <exception cref="T:System.ArgumentNullException">
                <paramref name="parameterList" /> or <paramref name="code" /> is
                <c>null</c>.
            </exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLEventHandlerNode.Code">
            <summary>
                The code scope node that represents the code body of the event handler.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLEventHandlerNode.ParameterList">
            <summary>
                The parameter list node for the parameters of the event handler.  This is non null even when no parameters exist.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLEventHandlerNode.SourceRangeName">
            <summary>
                The source code range of the event handler name.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLEventHandlerNode.Name">
            <summary>
                The name of the event handler.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLEventHandlerNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLEventHandlerNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLEventHandlerNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLEventHandlerNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLEventHandlerNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLEventHandlerNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLEventHandlerNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLFunctionDeclarationNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLFunctionDeclarationNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionDeclarationNode.#ctor(LibLSLCC.CodeValidator.LSLType,System.String,LibLSLCC.CodeValidator.LSLCodeScopeNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLFunctionDeclarationNode" /> with the given return type, and code body.
                The function declaration will have an empty parameter list node.
            </summary>
            <param name="returnType">The return type of the function.</param>
            <param name="functionName">The name of the function.</param>
            <param name="code">The code scope that makes up the function's code body.</param>
            <exception cref="T:System.ArgumentException">
                if <paramref name="functionName" /> contains invalid characters for an LSL ID
                token.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionDeclarationNode.#ctor(LibLSLCC.CodeValidator.LSLType,System.String,LibLSLCC.CodeValidator.LSLParameterListNode,LibLSLCC.CodeValidator.LSLCodeScopeNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLFunctionDeclarationNode" /> with the given return type, parameter list, and code body.
            </summary>
            <param name="returnType">The return type of the function.</param>
            <param name="functionName">The name of the function.</param>
            <param name="parameterList">The parameter list node representing the list of parameter definitions for the function.</param>
            <param name="code">The code scope that makes up the function's code body.</param>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="functionName" /> or <paramref name="parameterList" /> or <paramref name="code" /> is <c>null</c>.
            </exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException">
                if <paramref name="functionName" /> contains invalid characters for an LSL ID
                token.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionDeclarationNode.#ctor(LibLSLCC.AntlrParser.LSLParser.FunctionDeclarationContext,LibLSLCC.CodeValidator.LSLParameterListNode,LibLSLCC.CodeValidator.LSLCodeScopeNode)">
            <exception cref="T:System.ArgumentNullException">
                <paramref name="parameterList" /> or <paramref name="code" />
                is <c>null</c>.
            </exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionDeclarationNode.References">
            <summary>
                A list of function call nodes that reference this function definition, or an empty list.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionDeclarationNode.ParameterList">
            <summary>
                The parameter list node that contains the parameter list definitions for this function.
                It should never be null, even if the function definition contains no parameter definitions.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionDeclarationNode.Code">
            <summary>
                The code scope node that represents the code body of the function definition.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionDeclarationNode.SourceRangeName">
            <summary>
                The source code range of the function name.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionDeclarationNode.SourceRangeReturnType">
            <summary>
                The source code range of the function return type, or <c>null</c> if no return type was specified.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionDeclarationNode.ReturnTypeName">
            <summary>
                The string from the source code that represents the return type assigned to the function definition,
                or an empty string if no return type was assigned.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionDeclarationNode.Name">
            <summary>
                The name of the function.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionDeclarationNode.ReturnType">
            <summary>
                The return type assigned to the function definition, it will be <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" /> if no return type was
                given.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionDeclarationNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionDeclarationNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLFunctionDeclarationNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionDeclarationNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionDeclarationNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLFunctionDeclarationNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLFunctionDeclarationNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLStateScopeNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLStateScopeNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStateScopeNode.#ctor(System.String)">
            <summary>
                Construct an empty <see cref="T:LibLSLCC.CodeValidator.LSLStateScopeNode" /> with the given name.
                if <paramref name="stateName" /> is "default", <see cref="P:LibLSLCC.CodeValidator.LSLStateScopeNode.IsDefaultState" /> will be set to <c>true</c>.
            </summary>
            <param name="stateName">The name of the state.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="stateName" /> is <c>null</c>.</exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException"><paramref name="stateName" /> contained characters not allowed in an LSL ID token.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStateScopeNode.#ctor(LibLSLCC.AntlrParser.LSLParser.DefaultStateContext)">
            <exception cref="T:System.ArgumentNullException"><paramref name="context" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStateScopeNode.#ctor(LibLSLCC.AntlrParser.LSLParser.DefinedStateContext)">
            <exception cref="T:System.ArgumentNullException"><paramref name="context" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStateScopeNode.#ctor(LibLSLCC.AntlrParser.LSLParser.DefaultStateContext,System.Collections.Generic.IEnumerable{LibLSLCC.CodeValidator.LSLEventHandlerNode})">
            <exception cref="T:System.ArgumentNullException"><paramref name="eventHandlers" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStateScopeNode.#ctor(LibLSLCC.AntlrParser.LSLParser.DefinedStateContext,System.Collections.Generic.IEnumerable{LibLSLCC.CodeValidator.LSLEventHandlerNode})">
            <exception cref="T:System.ArgumentNullException"><paramref name="eventHandlers" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateScopeNode.EventHandlers">
            <summary>
                A list of event handlers nodes for each event handler that was used in the state.
                This should never be empty.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateScopeNode.StateName">
            <summary>
                The name of the state block in the source code.
                'default' should be returned if the node represents the default state.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateScopeNode.IsDefaultState">
            <summary>
                True if this state scope node represents the 'default' state,  False if it is a user defined state.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStateScopeNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStateScopeNode.Add(LibLSLCC.CodeValidator.LSLEventHandlerNode)">
            <summary>
                Adds an <see cref="T:LibLSLCC.CodeValidator.LSLEventHandlerNode" /> as a child of this state scope node.
            </summary>
            <param name="node">The event handler node to add.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateScopeNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLStateScopeNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateScopeNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateScopeNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateScopeNode.SourceRangeOpenBrace">
            <summary>
                The source code range of the opening brace of the state block's scope.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateScopeNode.SourceRangeCloseBrace">
            <summary>
                The source code range of the closing brace of the state block's scope.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateScopeNode.SourceRangeStateName">
            <summary>
                The source code range where the name of the state is located.
                For the default state, this will be the location of the 'default' keyword.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateScopeNode.SourceRangeStateKeyword">
            <summary>
                The source code range where the state keyword is located.
                For the default state, this will be the location of the 'default' keyword.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStateScopeNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateScopeNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStateScopeNode.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the  <see cref="T:LibLSLCC.CodeValidator.ILSLEventHandlerNode"/>'s in the state scope.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStateScopeNode.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLBranchStatementNode">
            <summary>
                AST node interface for branch statement nodes that participate in the dead code detection algorithm.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLReadOnlyBranchStatementNode">
            <summary>
                Read only AST node interface for branch statement nodes that participate in the dead code detection algorithm.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLReadOnlyBranchStatementNode.IsConstantBranch">
            <summary>
                Determines if the condition controlling the branch is a constant expression.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement">
            <summary>
                Read only AST node interface for code statements, code statements are the line by line statements that appear
                inside code scopes.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement.StatementIndex">
            <summary>
                The index of this statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement.IsLastStatementInScope">
            <summary>
                Is this statement the last statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement.DeadCodeType">
            <summary>
                The type of dead code that this statement is considered to be, if it is dead
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement.IsDeadCode">
            <summary>
                Is this statement dead code
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement.ParentScopeId">
            <summary>
                Represents an ID number for the scope this code statement is in, they are unique per-function/event handler.
                this is not the scopes level.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLReadOnlyCodeStatement.InsideSingleStatementScope">
            <summary>
                True if this statement belongs to a single statement code scope.
                A single statement code scope is a braceless code scope that can be used in control or loop statements.
            </summary>
            <seealso cref="P:LibLSLCC.CodeValidator.ILSLCodeScopeNode.IsSingleStatementScope" />
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLCodeStatement">
            <summary>
                Interface for code statements, code statements are the line by line statements that appear inside code scopes.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCodeStatement.StatementIndex">
            <summary>
                The index of this statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCodeStatement.IsLastStatementInScope">
            <summary>
                Is this statement the last statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCodeStatement.DeadCodeType">
            <summary>
                The type of dead code that this statement is considered to be, if it is dead
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCodeStatement.IsDeadCode">
            <summary>
                Is this statement dead code
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCodeStatement.ParentScopeId">
            <summary>
                Represents an ID number for the scope this code statement is in, they are unique per-function/event handler.
                this is not the scopes level.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLCodeStatement.InsideSingleStatementScope">
            <summary>
                True if this statement belongs to a single statement code scope.
                A single statement code scope is a braceless code scope that can be used in control or loop statements.
            </summary>
            <seealso cref="P:LibLSLCC.CodeValidator.ILSLCodeScopeNode.IsSingleStatementScope" />
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLReturnPathNode">
            <summary>
                Interface for AST nodes that can have a return path.
                This interface is used for any node that can appear as a decedent of an ILSLCodeScopeNode, including
                ILSLCodeScopeNode nodes themselves.
                This interface is used in the Dead Code detection and Return Path validation algorithm.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLReturnPathNode.HasReturnPath">
            <summary>
                True if the node represents a return path out of its ILSLCodeScopeNode parent, False otherwise.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLControlStatementNode">
            <summary>
                AST node interface for control statement chains.  This node's children consists of
                an if statement, optionally multiple else-if statements, and an optional else statement.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLControlStatementNode.HasElseStatement">
            <summary>
                True if the control statement node has an else statement child.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLControlStatementNode.HasIfStatement">
            <summary>
                True if the control statement node has an if statement child.
                This can only really be false if the node contains errors.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLControlStatementNode.HasElseIfStatements">
            <summary>
                True if the control statement node has any if-else statement children.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLControlStatementNode.ElseStatement">
            <summary>
                The else statement child of this control statement node if one exists, otherwise <c>null</c>.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLControlStatementNode.IfStatement">
            <summary>
                The if statement child of this control statement node if one exists, otherwise <c>null</c>.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLControlStatementNode.ElseIfStatement">
            <summary>
                The else-if statement children of this control statement node if one exists, otherwise an empty enumerable.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLElseIfStatementNode">
            <summary>
                AST Node interface for else-if statements.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLElseIfStatementNode.Code">
            <summary>
                The code scope associated with the else-if branch.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLElseIfStatementNode.ConditionExpression">
            <summary>
                The condition expression of the else-if statement.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLElseIfStatementNode.SourceRangeElseKeyword">
            <summary>
                The source code range of the 'else' keyword in the else-if statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLElseIfStatementNode.SourceRangeIfKeyword">
            <summary>
                The source code range of the 'if' keyword in the else-if statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLElseIfStatementNode.SourceRangeOpenParenth">
            <summary>
                The source code range of the opening parenthesis in the else-if statement where the condition area starts.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLElseIfStatementNode.SourceRangeCloseParenth">
            <summary>
                The source code range of the closing parenthesis in the else-if statement where the condition area ends.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLElseStatementNode">
            <summary>
                AST node interface for else statements.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLElseStatementNode.Code">
            <summary>
                The code scope node associated with this else statement.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLElseStatementNode.SourceRangeElseKeyword">
            <summary>
                The source code range of the 'else' keyword in the else statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLExpressionStatementNode">
            <summary>
                AST node interface for expression statements, expression statements are the statements that occur line by line
                inside of code scope.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLExpressionStatementNode.Expression">
            <summary>
                The top expression node that represents the expression in the statement.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLExpressionStatementNode.HasPossibleSideEffects">
            <summary>
                True if the expression statement has some modifying affect on a local parameter or global/local variable;  or is a
                function call.  False otherwise.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLExpressionStatementNode.SourceRangeSemicolon">
            <summary>
                The source code range of the semi-colon that ends the expression statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLIfStatementNode">
            <summary>
                AST Node interface for if statements
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLIfStatementNode.Code">
            <summary>
                The code inside the if statement.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLIfStatementNode.ConditionExpression">
            <summary>
                The expression inside the condition clause of the if statement.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLIfStatementNode.SourceRangeIfKeyword">
            <summary>
                The source code range of the 'if' keyword of the statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLIfStatementNode.SourceRangeOpenParenth">
            <summary>
                The source code range of the opening parenthesis of the condition area.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLIfStatementNode.SourceRangeCloseParenth">
            <summary>
                The source code range of the closing parenthesis of the condition area.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLJumpStatementNode">
            <summary>
                AST node interface for jump statements.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLJumpStatementNode.LabelName">
            <summary>
                The name of the label that the jump statement jumps to.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLJumpStatementNode.JumpTarget">
            <summary>
                The label statement node in the syntax tree that this jump statement jumps to.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLJumpStatementNode.SourceRangeJumpKeyword">
            <summary>
                The source code range of the 'jump' keyword in the jump statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLJumpStatementNode.SourceRangeLabelName">
            <summary>
                The source code range of the target label name in the jump statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLJumpStatementNode.SourceRangeSemicolon">
            <summary>
                The source code range of the semi-colon that follows the jump statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLLabelStatementNode">
            <summary>
                AST node interface for label statements.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLLabelStatementNode.LabelName">
            <summary>
                The name of the label.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLLabelStatementNode.JumpsToHere">
            <summary>
                A list of all jump statement nodes in the syntax tree that jump to this label node, or an empty list.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLLabelStatementNode.SourceRangeLabelPrefix">
            <summary>
                The source code range of the '@' symbol that prefixes the label name.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLLabelStatementNode.SourceRangeLabelName">
            <summary>
                The source code range of the label's name.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLLabelStatementNode.SourceRangeSemicolon">
            <summary>
                The source code range of the semi-colon that follows the label definition.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLParameterListNode">
            <summary>
                AST node interface for parameter list.  Used for function definition and event handler parameters.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLParameterListNode.Parameters">
            <summary>
                A list of parameter definition nodes that this parameter list node contains, or an empty list. <para/>
                This will never be <c>null</c>.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLParameterListNode.SourceRangeCommaList">
            <summary>
                The source code range for each comma separator that appears in the parameter list in order, or an empty list. <para/>
                This will never be <c>null</c>.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLParameterListNode.ParameterListType">
            <summary>
                The parameter list type;  FunctionParameters or EventParameters.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLParameterNode">
            <summary>
                AST node interface for function parameter and event handler parameter definitions.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLParameterNode.Name">
            <summary>
                The name of the parameter.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLParameterNode.Type">
            <summary>
                The <see cref="T:LibLSLCC.CodeValidator.LSLType" /> associated with the parameter.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLParameterNode.TypeName">
            <summary>
                The string representation of the <see cref="T:LibLSLCC.CodeValidator.LSLType" /> for the parameter, taken from the source code.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLParameterNode.ParameterIndex">
            <summary>
                The zero based index of the parameter definition in its parent <see cref="T:LibLSLCC.CodeValidator.ILSLParameterListNode" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLParameterNode.SourceRangeName">
            <summary>
                The source code range of the parameter name.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLParameterNode.SourceRangeType">
            <summary>
                The source code range of the parameter type specifier.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLReturnStatementNode">
            <summary>
                AST node interface for return statements.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLReturnStatementNode.ReturnExpression">
            <summary>
                The expression node that represents the returned expression, or null if no expression was used with the return
                statement.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLReturnStatementNode.HasReturnExpression">
            <summary>
                True if the return statement uses a return expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLReturnStatementNode.SourceRangeReturnKeyword">
            <summary>
                The source code range of the 'return' keyword in the return statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLReturnStatementNode.SourceRangeSemicolon">
            <summary>
                The source code range of the semi-colon that ends the return statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLSemicolonStatement">
            <summary>
                AST node interface for pointless semi-colon statements.
                There is just so you can do: (node is <see cref="T:LibLSLCC.CodeValidator.ILSLSemicolonStatement" />)
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLStateChangeStatementNode">
            <summary>
                AST node interface for state change statements.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLStateChangeStatementNode.StateTargetName">
            <summary>
                The name of the state that this state change statement jumps to.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLStateChangeStatementNode.SourceRangeStateKeyword">
            <summary>
                The source code range of the 'state' keyword in the state change statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLStateChangeStatementNode.SourceRangeStateName">
            <summary>
                The source code range of the target state name in the state change statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLStateChangeStatementNode.SourceRangeSemicolon">
            <summary>
                The source code range of the semi-colon that ends the state change statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLVariableDeclarationNode">
            <summary>
                AST node interface for global and local variable declarations.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVariableDeclarationNode.Name">
            <summary>
                The name of the variable.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVariableDeclarationNode.Type">
            <summary>
                The variable type.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVariableDeclarationNode.TypeName">
            <summary>
                The raw type string representing the variable type, taken from the source code.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVariableDeclarationNode.VariableNode">
            <summary>
                The initial variable node that was created by this variable declaration.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVariableDeclarationNode.References">
            <summary>
                A list of variable nodes representing references to this variable declaration in the source code.  Or an empty
                list.
                ILSLVariableNodes are used to represent a reference to a declared variable, and are present in the syntax tree at
                the site of reference.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVariableDeclarationNode.HasDeclarationExpression">
            <summary>
                True if an expression was used to initialize this variable declaration node when it was defined.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVariableDeclarationNode.IsLocal">
            <summary>
                True if this variable declaration is local to a function or event handler.  False if it is a global variable,
                parameter definition, or library constant.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVariableDeclarationNode.IsGlobal">
            <summary>
                True if this variable declaration is in the global program scope.  False if it is a local variable, parameter
                definition, or library constant.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVariableDeclarationNode.IsParameter">
            <summary>
                True if this variable declaration represents a local function/event handler parameter.  False if it is a local
                variable, global variable, or library constant.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVariableDeclarationNode.IsLibraryConstant">
            <summary>
                True if this variable declaration represents a library defined constant.  False if it is a local variable, global
                variable, or parameter definition.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVariableDeclarationNode.DeclarationExpression">
            <summary>
                The expression used to initialize this variable declaration, this will be null if 'HasDeclarationExpression' is
                false.
                If neither 'IsLocal' or 'IsGlobal' are true, than this property will always be null.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVariableDeclarationNode.SourceRangeType">
            <summary>
                The source code range of the type specifier for the variable declaration.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVariableDeclarationNode.SourceRangeName">
            <summary>
                The source code range that encompasses the variables name in the declaration.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.ILSLVariableDeclarationNode.SourceRangeOperator">
            <summary>
                The source code range of the assignment operator in the declaration expression if one was used.
                This value is only meaningful if either 'IsLocal' or 'IsGlobal' are true, and 'HasDeclarationExpression' is also
                true.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeStatementError.InsideSingleStatementScope">
            <summary>
                True if this statement belongs to a single statement code scope.
                A single statement code scope is a braceless code scope that can be used in control or loop statements.
            </summary>
            <seealso cref="P:LibLSLCC.CodeValidator.ILSLCodeScopeNode.IsSingleStatementScope" />
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeStatementError.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeStatementError.DeadCodeType">
            <summary>
                The type of dead code that this statement is considered to be, if it is dead
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeStatementError.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLCodeStatementError.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeStatementError.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeStatementError.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeStatementError.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeStatementError.HasReturnPath">
            <summary>
                True if the node represents a return path out of its ILSLCodeScopeNode parent, False otherwise.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeStatementError.StatementIndex">
            <summary>
                The index of this statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeStatementError.IsLastStatementInScope">
            <summary>
                Is this statement the last statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeStatementError.IsDeadCode">
            <summary>
                Is this statement dead code
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeStatementError.ParentScopeId">
            <summary>
                Represents an ID number for the scope this code statement is in, they are unique per-function/event handler.
                this is not the scopes level.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeStatementError.Clone">
            <summary>
                Deep clones the code statement node.  It should clone the node and all of its children and cloneable properties,
                except the parent.
                When cloned, the parent node reference should be left <c>null</c>.
            </summary>
            <returns>A deep clone of this statement tree node.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLControlStatementNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLControlStatementNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLControlStatementNode.#ctor(LibLSLCC.CodeValidator.LSLIfStatementNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLControlStatementNode" /> with an 'if' statement
                node.
            </summary>
            <param name="ifStatement">The if statement that starts the control chain.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="ifStatement" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLControlStatementNode.#ctor(LibLSLCC.CodeValidator.LSLIfStatementNode,LibLSLCC.CodeValidator.LSLElseStatementNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLControlStatementNode" /> with 'if' and 'else'
                statement nodes.
            </summary>
            <param name="ifStatement">The if statement that starts the control chain.</param>
            <param name="elseStatement">The else statement.</param>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="ifStatement" /> or <paramref name="elseStatement" /> is
                <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLControlStatementNode.#ctor(LibLSLCC.CodeValidator.LSLIfStatementNode,System.Collections.Generic.IEnumerable{LibLSLCC.CodeValidator.LSLElseIfStatementNode},LibLSLCC.CodeValidator.LSLElseStatementNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLControlStatementNode" /> with 'if', 'else-if' and
                'else' statement nodes.
            </summary>
            <param name="ifStatement">The if statement that starts the control chain.</param>
            <param name="elseIfStatements">Else-if statements.</param>
            <param name="elseStatement">The else statement.</param>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="ifStatement" /> or <paramref name="elseIfStatements" /> or
                <paramref name="elseStatement" /> is <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLControlStatementNode.#ctor(LibLSLCC.CodeValidator.LSLIfStatementNode,System.Collections.Generic.IEnumerable{LibLSLCC.CodeValidator.LSLElseIfStatementNode})">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLControlStatementNode" />  with 'if' and 'else-if'
                statement nodes.
            </summary>
            <param name="ifStatement">The if statement that starts the control chain.</param>
            <param name="elseIfStatements">Else-if statements.</param>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="ifStatement" /> or <paramref name="elseIfStatements" /> is
                <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLControlStatementNode.#ctor(LibLSLCC.AntlrParser.LSLParser.ControlStructureContext)">
            <exception cref="T:System.ArgumentNullException"><paramref name="context" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLControlStatementNode.ElseStatement">
            <summary>
                The else statement child of this control statement node if one exists, otherwise <c>null</c>.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLControlStatementNode.IfStatement">
            <summary>
                The if statement child of this control statement node if one exists, otherwise <c>null</c>.
            </summary>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLControlStatementNode.ElseIfStatements">
            <summary>
                The else-if statement children of this control statement node if one exists, otherwise an empty enumerable.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLControlStatementNode.DeadCodeType">
            <summary>
                The type of dead code that this statement is considered to be, if it is dead
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLControlStatementNode.HasElseStatement">
            <summary>
                True if the control statement node has an else statement child.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLControlStatementNode.HasIfStatement">
            <summary>
                True if the control statement node has an if statement child.
                This can only really be false if the node contains errors.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLControlStatementNode.HasElseIfStatements">
            <summary>
                True if the control statement node has any if-else statement children.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLControlStatementNode.ParentScopeId">
            <summary>
                Represents an ID number for the scope this code statement is in, they are unique per-function/event handler.
                this is not the scopes level.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLControlStatementNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLControlStatementNode.AddElseIfStatement(LibLSLCC.CodeValidator.LSLElseIfStatementNode)">
            <summary>
                Add an <see cref="T:LibLSLCC.CodeValidator.LSLElseIfStatementNode" /> to this control statement chain.
            </summary>
            <param name="node">The <see cref="T:LibLSLCC.CodeValidator.LSLElseIfStatementNode" /> to add.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="node" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLControlStatementNode.InsideSingleStatementScope">
            <summary>
                True if this statement belongs to a single statement code scope.
                A single statement code scope is a braceless code scope that can be used in control or loop statements.
            </summary>
            <seealso cref="P:LibLSLCC.CodeValidator.ILSLCodeScopeNode.IsSingleStatementScope" />
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLControlStatementNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLControlStatementNode.StatementIndex">
            <summary>
                The index of this statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLControlStatementNode.IsLastStatementInScope">
            <summary>
                Is this statement the last statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLControlStatementNode.IsDeadCode">
            <summary>
                Is this statement dead code
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLControlStatementNode.HasReturnPath">
            <summary>
                True if the node represents a return path out of its ILSLCodeScopeNode parent, False otherwise.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLControlStatementNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLControlStatementNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLControlStatementNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLControlStatementNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLControlStatementNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLControlStatementNode.GetConstantJump">
            <summary>
                Returns a constant jump from this control statement chain if there is one,
                otherwise null.  A constant jump is a singular jump to the same label
                from every possible branch of the control chain. meaning the jump
                happens in a constant manner regardless of which branch is taken.
                DeterminingJump will point to the <see cref="T:LibLSLCC.CodeValidator.LSLJumpStatementNode" /> in the 'if' code scope.
                EffectiveJumpStatement will point to the control statement, because it can effectively
                be considered a jump statement since it will always cause a jump to a known label to occur.
                The label that this control statement jumps to can be found with DeterminingJump.JumpTarget.
                EffectiveJumpStatement is mostly useful for its statement index information
            </summary>
            <returns>An object describing the constant jump, if one exists; otherwise <c>null</c>.</returns>
            <seealso cref="P:LibLSLCC.CodeValidator.LSLConstantJumpDescription.DeterminingJump" />
            <seealso cref="P:LibLSLCC.CodeValidator.LSLConstantJumpDescription.EffectiveJumpStatement" />
            <seealso cref="P:LibLSLCC.CodeValidator.LSLConstantJumpDescription.JumpTarget" />
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLElseIfStatementNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLElseIfStatementNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLElseIfStatementNode.#ctor(LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.LSLCodeScopeNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLElseIfStatementNode" /> with the given condition expression and code.
            </summary>
            <param name="condition">The branch condition.</param>
            <param name="code">The code.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition" /> or <paramref name="code" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLElseIfStatementNode.#ctor(Antlr4.Runtime.IToken,LibLSLCC.AntlrParser.LSLParser.ControlStructureContext,LibLSLCC.CodeValidator.LSLCodeScopeNode,LibLSLCC.CodeValidator.ILSLExprNode)">
            <exception cref="T:System.ArgumentNullException">
                <paramref name="code" /> or <paramref name="conditionExpression" /> is
                <c>null</c>.
            </exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLElseIfStatementNode.ConstantJumps">
            <summary>
                <see cref="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.ConstantJumps" /> returned from <see cref="P:LibLSLCC.CodeValidator.LSLElseIfStatementNode.Code" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLElseIfStatementNode.Code">
            <summary>
                The code scope associated with the else-if branch.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLElseIfStatementNode.ConditionExpression">
            <summary>
                The condition expression of the else-if statement.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLElseIfStatementNode.IsConstantBranch">
            <summary>
                Determines if the condition controlling the branch is a constant expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLElseIfStatementNode.HasReturnPath">
            <summary>
                True if the node represents a return path out of its ILSLCodeScopeNode parent, False otherwise.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLElseIfStatementNode.SourceRangeIfKeyword">
            <summary>
                The source code range of the 'if' keyword in the else-if statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLElseIfStatementNode.SourceRangeElseKeyword">
            <summary>
                The source code range of the 'else' keyword in the else-if statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLElseIfStatementNode.SourceRangeOpenParenth">
            <summary>
                The source code range of the opening parenthesis in the else-if statement where the condition area starts.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLElseIfStatementNode.SourceRangeCloseParenth">
            <summary>
                The source code range of the closing parenthesis in the else-if statement where the condition area ends.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLElseIfStatementNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLElseIfStatementNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLElseIfStatementNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLElseIfStatementNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLElseIfStatementNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLElseIfStatementNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLElseIfStatementNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLElseStatementNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLElseStatementNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLElseStatementNode.#ctor(LibLSLCC.CodeValidator.LSLCodeScopeNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLElseStatementNode" /> with the given code body.
            </summary>
            <param name="code">The code.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="code" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLElseStatementNode.#ctor(LibLSLCC.AntlrParser.LSLParser.ElseStatementContext,LibLSLCC.CodeValidator.LSLCodeScopeNode,System.Boolean)">
            <exception cref="T:System.ArgumentNullException"><paramref name="code" /> or <paramref name="code" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLElseStatementNode.ConstantJumps">
            <summary>
                <see cref="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.ConstantJumps" /> returned from <see cref="P:LibLSLCC.CodeValidator.LSLElseStatementNode.Code" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLElseStatementNode.Code">
            <summary>
                The code scope node associated with this else statement.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLElseStatementNode.SourceRangeElseKeyword">
            <summary>
                The source code range of the 'else' keyword in the else statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLElseStatementNode.IsConstantBranch">
            <summary>
                Determines if the condition controlling the branch is a constant expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLElseStatementNode.HasReturnPath">
            <summary>
                True if the node represents a return path out of its ILSLCodeScopeNode parent, False otherwise.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLElseStatementNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLElseStatementNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLElseStatementNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLElseStatementNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLElseStatementNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLElseStatementNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLElseStatementNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLExpressionStatementNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLExpressionStatementNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExpressionStatementNode.#ctor(LibLSLCC.CodeValidator.ILSLExprNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLExpressionStatementNode" /> with the given expression and a <see cref="P:LibLSLCC.CodeValidator.LSLExpressionStatementNode.ParentScopeId" /> of
                zero.
            </summary>
            <param name="expression">The expression to appear as a statement.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="expression" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExpressionStatementNode.#ctor(LibLSLCC.AntlrParser.LSLParser.ExpressionStatementContext,LibLSLCC.CodeValidator.ILSLExprNode)">
            <exception cref="T:System.ArgumentNullException"><paramref name="context" /> or <paramref name="expression" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExpressionStatementNode.#ctor(LibLSLCC.CodeValidator.LSLExpressionStatementNode)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLExpressionStatementNode" /> by cloning from another.
            </summary>
            <param name="other">The other node to clone from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionStatementNode.Expression">
            <summary>
                The top expression node that represents the expression in the statement.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionStatementNode.DeadCodeType">
            <summary>
                The type of dead code that this statement is considered to be, if it is dead
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionStatementNode.ParentScopeId">
            <summary>
                Represents an ID number for the scope this code statement is in, they are unique per-function/event handler.
                this is not the scopes level.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExpressionStatementNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionStatementNode.InsideSingleStatementScope">
            <summary>
                True if this statement belongs to a single statement code scope.
                A single statement code scope is a braceless code scope that can be used in control or loop statements.
            </summary>
            <seealso cref="P:LibLSLCC.CodeValidator.ILSLCodeScopeNode.IsSingleStatementScope" />
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionStatementNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionStatementNode.HasPossibleSideEffects">
            <summary>
                True if the expression statement has some modifying effect on a local parameter or global/local variable;  or is a
                function call.  False otherwise.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionStatementNode.SourceRangeSemicolon">
            <summary>
                The source code range of the semi-colon that ends the expression statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionStatementNode.StatementIndex">
            <summary>
                The index of this statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionStatementNode.HasReturnPath">
            <summary>
                True if the node represents a return path out of its ILSLCodeScopeNode parent, False otherwise.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionStatementNode.IsLastStatementInScope">
            <summary>
                Is this statement the last statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionStatementNode.IsDeadCode">
            <summary>
                Is this statement dead code
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionStatementNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLExpressionStatementNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionStatementNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLExpressionStatementNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExpressionStatementNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLExpressionStatementNode.Clone">
            <summary>
                Deep clones the node.  It should clone the node and all of its children and cloneable properties, except the
                parent.
                When cloned, the parent node reference should be left <c>null</c>.
            </summary>
            <returns>A deep clone of this statement tree node.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLIfStatementNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLIfStatementNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLIfStatementNode.#ctor(LibLSLCC.CodeValidator.ILSLExprNode,LibLSLCC.CodeValidator.LSLCodeScopeNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLIfStatementNode" /> with the given condition expression and code.
            </summary>
            <param name="condition">The branch condition.</param>
            <param name="code">The code.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="condition" /> or <paramref name="code" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLIfStatementNode.#ctor(LibLSLCC.AntlrParser.LSLParser.ControlStructureContext,LibLSLCC.CodeValidator.LSLCodeScopeNode,LibLSLCC.CodeValidator.ILSLExprNode)">
            <exception cref="T:System.ArgumentNullException">
                <paramref name="context" /> or <paramref name="code" /> or
                <paramref name="conditionExpression" /> is <c>null</c>.
            </exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLIfStatementNode.ConstantJumps">
            <summary>
                <see cref="P:LibLSLCC.CodeValidator.LSLCodeScopeNode.ConstantJumps" /> returned from <see cref="P:LibLSLCC.CodeValidator.LSLIfStatementNode.Code" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLIfStatementNode.Code">
            <summary>
                The code inside the if statement.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLIfStatementNode.ConditionExpression">
            <summary>
                The expression inside the condition clause of the if statement.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLIfStatementNode.IsConstantBranch">
            <summary>
                Determines if the condition controlling the branch is a constant expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLIfStatementNode.HasReturnPath">
            <summary>
                True if the node represents a return path out of its ILSLCodeScopeNode parent, False otherwise.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLIfStatementNode.SourceRangeIfKeyword">
            <summary>
                The source code range of the 'if' keyword of the statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLIfStatementNode.SourceRangeOpenParenth">
            <summary>
                The source code range of the opening parenthesis of the condition area.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLIfStatementNode.SourceRangeCloseParenth">
            <summary>
                The source code range of the closing parenthesis of the condition area.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLIfStatementNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLIfStatementNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLIfStatementNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLIfStatementNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLIfStatementNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLIfStatementNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLIfStatementNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLJumpStatementNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLJumpStatementNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLJumpStatementNode.#ctor(LibLSLCC.CodeValidator.LSLLabelStatementNode)">
            <summary>
                Creates an <see cref="T:LibLSLCC.CodeValidator.LSLJumpStatementNode" /> that jumps to a specified <see cref="T:LibLSLCC.CodeValidator.LSLLabelStatementNode" />, with
                a <see cref="P:LibLSLCC.CodeValidator.LSLJumpStatementNode.ParentScopeId" /> of zero.
                <paramref name="jumpTarget" /> receives a <see cref="P:LibLSLCC.CodeValidator.LSLLabelStatementNode.JumpsToHere" /> reference via
                <see cref="M:LibLSLCC.CodeValidator.LSLLabelStatementNode.AddJumpToHere(LibLSLCC.CodeValidator.LSLJumpStatementNode)" />.
            </summary>
            <param name="jumpTarget">The <see cref="T:LibLSLCC.CodeValidator.LSLLabelStatementNode" /> to jump to.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="jumpTarget" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="jumpTarget" /> does not have a Parent, is not already in the syntax tree.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLJumpStatementNode.#ctor(LibLSLCC.AntlrParser.LSLParser.JumpStatementContext,LibLSLCC.CodeValidator.LSLLabelStatementNode)">
            <exception cref="T:System.ArgumentNullException"><paramref name="context" /> or <paramref name="jumpTarget" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLJumpStatementNode.JumpTarget">
            <summary>
                The label statement node in the syntax tree that this jump statement jumps to.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLJumpStatementNode.InsideSingleStatementScope">
            <summary>
                True if this statement belongs to a single statement code scope.
                A single statement code scope is a braceless code scope that can be used in control or loop statements.
            </summary>
            <seealso cref="P:LibLSLCC.CodeValidator.ILSLCodeScopeNode.IsSingleStatementScope" />
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLJumpStatementNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLJumpStatementNode.ConstantJump">
            <summary>
                True if this jump is guaranteed to occur in a constant manner.
                IE, the jump is always encountered regardless of program control flow.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLJumpStatementNode.IsLastStatementInScope">
            <summary>
                Is this statement the last statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLJumpStatementNode.IsDeadCode">
            <summary>
                Is this statement dead code
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLJumpStatementNode.StatementIndex">
            <summary>
                The index of this statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLJumpStatementNode.HasReturnPath">
            <summary>
                True if the node represents a return path out of its ILSLCodeScopeNode parent, False otherwise.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLJumpStatementNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLJumpStatementNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLJumpStatementNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLJumpStatementNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLJumpStatementNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLJumpStatementNode.DeadCodeType">
            <summary>
                The type of dead code that this statement is considered to be, if it is dead
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLJumpStatementNode.LabelName">
            <summary>
                The name of the label that the jump statement jumps to.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLJumpStatementNode.ParentScopeId">
            <summary>
                Represents an ID number for the scope this code statement is in, they are unique per-function/event handler.
                this is not the scopes level.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLJumpStatementNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLJumpStatementNode.SourceRangeJumpKeyword">
            <summary>
                The source code range of the 'jump' keyword in the jump statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLJumpStatementNode.SourceRangeLabelName">
            <summary>
                The source code range of the target label name in the jump statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLJumpStatementNode.SourceRangeSemicolon">
            <summary>
                The source code range of the semi-colon that follows the jump statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLLabelStatementNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLLabelStatementNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLLabelStatementNode.#ctor(System.String)">
            <summary>
                Creates a <see cref="T:LibLSLCC.CodeValidator.LSLLabelStatementNode" /> with the given <see cref="P:LibLSLCC.CodeValidator.LSLLabelStatementNode.ParentScopeId" /> and <see cref="P:LibLSLCC.CodeValidator.LSLLabelStatementNode.LabelName" />.
            </summary>
            <param name="labelName">The <see cref="P:LibLSLCC.CodeValidator.LSLLabelStatementNode.LabelName" /></param>
            <exception cref="T:System.ArgumentNullException"><paramref name="labelName" /> is <c>null</c>.</exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException"><paramref name="labelName" /> contained characters not allowed in an LSL ID token.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLLabelStatementNode.JumpsToHere">
            <summary>
                A list of all jump statement nodes in the syntax tree that jump to this label node, or an empty list.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLLabelStatementNode.DeadCodeType">
            <summary>
                The type of dead code that this statement is considered to be, if it is dead
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLLabelStatementNode.LabelName">
            <summary>
                The name of the label.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLLabelStatementNode.ParentScopeId">
            <summary>
                Represents an ID number for the scope this code statement is in, they are unique per-function/event handler.
                this is not the scopes level.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLLabelStatementNode.SourceRangeLabelPrefix">
            <summary>
                The source code range of the '@' symbol that prefixes the label name.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLLabelStatementNode.SourceRangeLabelName">
            <summary>
                The source code range of the label's name.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLLabelStatementNode.SourceRangeSemicolon">
            <summary>
                The source code range of the semi-colon that follows the label definition.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLLabelStatementNode.AddJumpToHere(LibLSLCC.CodeValidator.LSLJumpStatementNode)">
            <summary>
                Adds a <see cref="P:LibLSLCC.CodeValidator.LSLLabelStatementNode.JumpsToHere" /> reference from a given <see cref="T:LibLSLCC.CodeValidator.LSLJumpStatementNode" />
            </summary>
            <param name="jump"></param>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLLabelStatementNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLLabelStatementNode.InsideSingleStatementScope">
            <summary>
                True if this statement belongs to a single statement code scope.
                A single statement code scope is a braceless code scope that can be used in control or loop statements.
            </summary>
            <remarks>label statements can be inside of braceless code scopes in LSL.  It is pointless, but they can be.</remarks>
            <seealso cref="P:LibLSLCC.CodeValidator.ILSLCodeScopeNode.IsSingleStatementScope" />
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLLabelStatementNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLLabelStatementNode.StatementIndex">
            <summary>
                The index of this statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLLabelStatementNode.HasReturnPath">
            <summary>
                True if the node represents a return path out of its ILSLCodeScopeNode parent, False otherwise.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLLabelStatementNode.IsLastStatementInScope">
            <summary>
                Is this statement the last statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLLabelStatementNode.IsDeadCode">
            <summary>
                Is this statement dead code
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLLabelStatementNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLLabelStatementNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLLabelStatementNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLLabelStatementNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLLabelStatementNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLParameterListNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLParameterListNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParameterListNode.#ctor">
            <summary>
                Construct an empty <see cref="T:LibLSLCC.CodeValidator.LSLParameterListNode" />.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParameterListNode.#ctor(System.Collections.Generic.IEnumerable{LibLSLCC.CodeValidator.LSLParameterNode})">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLParameterListNode" /> with the parameter nodes in <paramref name="parameters" />.
            </summary>
            <param name="parameters">The parameters to fill this parameter list node with.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="parameters" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">
                If two parameters with the same name exist in <paramref name="parameters" />.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParameterListNode.#ctor(LibLSLCC.CodeValidator.LSLParameterNode[])">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLParameterListNode" /> with the parameter nodes in <paramref name="parameters" />.
            </summary>
            <param name="parameters">The parameters to fill this parameter list node with.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="parameters" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">
                If two parameters with the same name exist in <paramref name="parameters" />.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParameterListNode.#ctor(LibLSLCC.CodeValidator.LSLParameterListNode)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLParameterListNode" /> by cloning from another.
            </summary>
            <param name="other">The other node to clone from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParameterListNode.Parameters">
            <summary>
                A list of parameter definition nodes that this parameter list node contains, or an empty list. <para/>
                This will never be <c>null</c>.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParameterListNode.SourceRangeCommaList">
            <summary>
                The source code range for each comma separator that appears in the parameter list in order, or an empty list. <para/>
                This will never be <c>null</c>.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParameterListNode.ParameterListType">
            <summary>
                The parameter list type;  FunctionParameters or EventParameters.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParameterListNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParameterListNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLParameterListNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParameterListNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParameterListNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParameterListNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParameterListNode.Clone">
            <summary>
                Deep clones the syntax tree node.  It should clone the node and all of its children and cloneable properties,
                except the parent.
                When cloned, the parent node reference should be left <c>null</c>.
            </summary>
            <returns>A deep clone of this syntax tree node.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParameterListNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParameterListNode.BuildFromParserContext(LibLSLCC.AntlrParser.LSLParser.OptionalParameterListContext,LibLSLCC.CodeValidator.LSLParameterListType,LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies)">
            <summary>
                Builds a parameter list node directly from a parser context, checking for duplicates and reporting
                duplicate parameter errors via a validator strategies object. <see cref="T:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies" />.
            </summary>
            <param name="context">The context to build from</param>
            <param name="validatorStrategies">The validator strategies object to use for reporting errors or warnings</param>
            <param name="parameterListType">The parameter list type.</param>
            <returns>the created parameter list node</returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="context" /> or <paramref name="validatorStrategies" /> is
                <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParameterListNode.Add(LibLSLCC.CodeValidator.LSLParameterNode)">
            <summary>
                Add a parameter definition node to this parameter list node.
            </summary>
            <param name="node">The parameter definition node to add.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if the 'node' parameter is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">
                If a parameter with the same name already exists.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParameterListNode.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="T:LibLSLCC.CodeValidator.ILSLParameterNode"/>'s in this parameter list.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParameterListNode.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLParameterNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLParameterNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParameterNode.#ctor(LibLSLCC.CodeValidator.LSLType,System.String)">
            <summary>
                Construct a <see cref="T:LibLSLCC.CodeValidator.LSLParameterNode" /> with the given <see cref="P:LibLSLCC.CodeValidator.LSLParameterNode.Type" /> and <see cref="P:LibLSLCC.CodeValidator.LSLParameterNode.Name" />.
            </summary>
            <param name="type">The <see cref="P:LibLSLCC.CodeValidator.LSLParameterNode.Type" />.</param>
            <param name="parameterName">The <see cref="P:LibLSLCC.CodeValidator.LSLParameterNode.Name" />.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="parameterName" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">
                if <paramref name="type" /> is <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" /> or
            </exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException"><paramref name="parameterName" /> contains characters that are invalid in an LSL ID token.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParameterNode.#ctor(LibLSLCC.AntlrParser.LSLParser.ParameterDefinitionContext)">
            <exception cref="T:System.ArgumentNullException"><paramref name="context" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParameterNode.#ctor(LibLSLCC.CodeValidator.ILSLParameterNode)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLParameterNode" /> by cloning from another.
            </summary>
            <param name="other">The other node to clone from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParameterNode.Name">
            <summary>
                The name of the parameter.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParameterNode.Type">
            <summary>
                The <see cref="T:LibLSLCC.CodeValidator.LSLType" /> associated with the parameter.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParameterNode.TypeName">
            <summary>
                The string representation of the <see cref="T:LibLSLCC.CodeValidator.LSLType" /> for the parameter, taken from the source code.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParameterNode.ParameterIndex">
            <summary>
                The zero based index of the parameter definition in its parent <see cref="T:LibLSLCC.CodeValidator.ILSLParameterListNode" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParameterNode.SourceRangeName">
            <summary>
                The source code range of the parameter name.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParameterNode.SourceRangeType">
            <summary>
                The source code range of the parameter type specifier.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParameterNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLParameterNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParameterNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParameterNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParameterNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLParameterNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParameterNode.Clone">
            <summary>
                Deep clones the syntax tree node.  It should clone the node and all of its children and cloneable properties,
                except the parent.
                When cloned, the parent node reference should be left <c>null</c>.
            </summary>
            <returns>A deep clone of this syntax tree node.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLParameterNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLReturnStatementNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLReturnStatementNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLReturnStatementNode.#ctor(LibLSLCC.CodeValidator.ILSLExprNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLReturnStatementNode" /> with a given return expression and <see cref="P:LibLSLCC.CodeValidator.LSLReturnStatementNode.ParentScopeId" /> of
                zero.
            </summary>
            <param name="returnExpression">The <see cref="P:LibLSLCC.CodeValidator.LSLReturnStatementNode.ReturnExpression" />.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="returnExpression" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLReturnStatementNode.#ctor">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLReturnStatementNode" /> with a <see cref="P:LibLSLCC.CodeValidator.LSLReturnStatementNode.ParentScopeId" /> of zero and no return expression.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLReturnStatementNode.#ctor(LibLSLCC.CodeValidator.LSLReturnStatementNode)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLReturnStatementNode" /> by cloning from another.
            </summary>
            <param name="other">The other node to clone from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLReturnStatementNode.#ctor(LibLSLCC.AntlrParser.LSLParser.ReturnStatementContext,LibLSLCC.CodeValidator.ILSLExprNode)">
            <exception cref="T:System.ArgumentNullException">
                <paramref name="context" /> or <paramref name="returnExpression" /> is
                <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLReturnStatementNode.#ctor(LibLSLCC.AntlrParser.LSLParser.ReturnStatementContext)">
            <exception cref="T:System.ArgumentNullException"><paramref name="context" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLReturnStatementNode.ReturnExpression">
            <summary>
                The expression node that represents the returned expression, or null if no expression was used with the return
                statement.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLReturnStatementNode.DeadCodeType">
            <summary>
                The type of dead code that this statement is considered to be, if it is dead
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLReturnStatementNode.HasReturnExpression">
            <summary>
                True if the return statement uses a return expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLReturnStatementNode.ParentScopeId">
            <summary>
                Represents an ID number for the scope this code statement is in, they are unique per-function/event handler.
                this is not the scopes level.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLReturnStatementNode.SourceRangeReturnKeyword">
            <summary>
                The source code range of the 'return' keyword in the return statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLReturnStatementNode.SourceRangeSemicolon">
            <summary>
                The source code range of the semi-colon that ends the return statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLReturnStatementNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLReturnStatementNode.InsideSingleStatementScope">
            <summary>
                True if this statement belongs to a single statement code scope.
                A single statement code scope is a braceless code scope that can be used in control or loop statements.
            </summary>
            <seealso cref="P:LibLSLCC.CodeValidator.ILSLCodeScopeNode.IsSingleStatementScope" />
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLReturnStatementNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLReturnStatementNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLReturnStatementNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLReturnStatementNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLReturnStatementNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLReturnStatementNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLReturnStatementNode.Clone">
            <summary>
                Deep clones the node.  It should clone the node and all of its children and cloneable properties, except the
                parent.
                When cloned, the parent node reference should be left <c>null</c>.
            </summary>
            <returns>A deep clone of this statement tree node.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLReturnStatementNode.StatementIndex">
            <summary>
                The index of this statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLReturnStatementNode.IsLastStatementInScope">
            <summary>
                Is this statement the last statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLReturnStatementNode.IsDeadCode">
            <summary>
                Is this statement dead code
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLReturnStatementNode.HasReturnPath">
            <summary>
                True if the node represents a return path out of its ILSLCodeScopeNode parent, False otherwise.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLSemicolonStatement">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLSemicolonStatement" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLSemicolonStatement.#ctor">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLSemicolonStatement" /> with a <see cref="P:LibLSLCC.CodeValidator.LSLSemicolonStatement.ParentScopeId" /> of zero.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLSemicolonStatement.#ctor(LibLSLCC.AntlrParser.LSLParser.CodeStatementContext)">
            <exception cref="T:System.ArgumentNullException"><paramref name="context" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLSemicolonStatement.#ctor(LibLSLCC.CodeValidator.LSLSemicolonStatement)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLSemicolonStatement" /> by cloning from another.
            </summary>
            <param name="other">The other node to clone from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSemicolonStatement.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSemicolonStatement.InsideSingleStatementScope">
            <summary>
                True if this statement belongs to a single statement code scope.
                A single statement code scope is a braceless code scope that can be used in control or loop statements.
            </summary>
            <seealso cref="P:LibLSLCC.CodeValidator.ILSLCodeScopeNode.IsSingleStatementScope" />
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSemicolonStatement.DeadCodeType">
            <summary>
                The type of dead code that this statement is considered to be, if it is dead
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSemicolonStatement.ParentScopeId">
            <summary>
                Represents an ID number for the scope this code statement is in, they are unique per-function/event handler.
                this is not the scopes level.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSemicolonStatement.IsDeadCode">
            <summary>
                Is this statement dead code
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSemicolonStatement.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLSemicolonStatement.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSemicolonStatement.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSemicolonStatement.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLSemicolonStatement.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSemicolonStatement.HasReturnPath">
            <summary>
                True if the node represents a return path out of its ILSLCodeScopeNode parent, False otherwise.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSemicolonStatement.StatementIndex">
            <summary>
                The index of this statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLSemicolonStatement.IsLastStatementInScope">
            <summary>
                Is this statement the last statement in its scope
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLSemicolonStatement.Clone">
            <summary>
                Deep clones the node.  It should clone the node and all of its children and cloneable properties, except the
                parent.
                When cloned, the parent node reference should be left <c>null</c>.
            </summary>
            <returns>A deep clone of this statement tree node.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLStateChangeStatementNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLStateChangeStatementNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStateChangeStatementNode.#ctor(LibLSLCC.CodeValidator.ILSLStateScopeNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLStateChangeStatementNode" /> that changes state to the state node specified by
                <paramref name="state" />.
                <see cref="P:LibLSLCC.CodeValidator.LSLStateChangeStatementNode.ParentScopeId" /> will be set to zero.
            </summary>
            <param name="state">The state node representing the state to change to.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="state" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStateChangeStatementNode.#ctor(LibLSLCC.AntlrParser.LSLParser.StateChangeStatementContext)">
            <exception cref="T:System.ArgumentNullException"><paramref name="context" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStateChangeStatementNode.#ctor(LibLSLCC.CodeValidator.LSLStateChangeStatementNode)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLStateChangeStatementNode" /> by cloning from another.
            </summary>
            <param name="other">The other node to clone from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateChangeStatementNode.DeadCodeType">
            <summary>
                The type of dead code that this statement is considered to be, if it is dead
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateChangeStatementNode.ParentScopeId">
            <summary>
                Represents an ID number for the scope this code statement is in, they are unique per-function/event handler.
                this is not the scopes level.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateChangeStatementNode.SourceRangeStateKeyword">
            <summary>
                The source code range of the 'state' keyword in the state change statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateChangeStatementNode.SourceRangeStateName">
            <summary>
                The source code range of the target state name in the state change statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateChangeStatementNode.SourceRangeSemicolon">
            <summary>
                The source code range of the semi-colon that ends the state change statement.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStateChangeStatementNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateChangeStatementNode.InsideSingleStatementScope">
            <summary>
                True if this statement belongs to a single statement code scope.
                A single statement code scope is a braceless code scope that can be used in control or loop statements.
            </summary>
            <seealso cref="P:LibLSLCC.CodeValidator.ILSLCodeScopeNode.IsSingleStatementScope" />
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateChangeStatementNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateChangeStatementNode.StateTargetName">
            <summary>
                The name of the state that this state change statement jumps to.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateChangeStatementNode.StatementIndex">
            <summary>
                The index of this statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateChangeStatementNode.HasReturnPath">
            <summary>
                True if the node represents a return path out of its ILSLCodeScopeNode parent, False otherwise.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateChangeStatementNode.IsLastStatementInScope">
            <summary>
                Is this statement the last statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateChangeStatementNode.IsDeadCode">
            <summary>
                Is this statement dead code
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateChangeStatementNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLStateChangeStatementNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateChangeStatementNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLStateChangeStatementNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStateChangeStatementNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLStateChangeStatementNode.Clone">
            <summary>
                Deep clones the node.  It should clone the node and all of its children and cloneable properties, except the
                parent.
                When cloned, the parent node reference should be left <c>null</c>.
            </summary>
            <returns>A deep clone of this statement tree node.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLVariableDeclarationNode">
            <summary>
                Default <see cref="T:LibLSLCC.CodeValidator.ILSLVariableDeclarationNode" /> implementation used by <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.#ctor(LibLSLCC.CodeValidator.LSLVariableDeclarationNode)">
            <summary>
                Create an <see cref="T:LibLSLCC.CodeValidator.LSLVariableDeclarationNode" /> by cloning from another.
            </summary>
            <param name="other">The other node to clone from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.VariableNode">
            <summary>
                The variable node that was created upon construction of
                this variable declaration
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.DeclarationExpression">
            <summary>
                The expression used to initialize this variable declaration, this will be null if 'HasDeclarationExpression' is
                false.
                If neither 'IsLocal' or 'IsGlobal' are true, than this property will always be null.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.References">
            <summary>
                A list of variable nodes representing references to this variable declaration in the source code.  Or an empty
                list.
                ILSLVariableNodes are used to represent a reference to a declared variable, and are present in the syntax tree at
                the site of reference.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.DeadCodeType">
            <summary>
                The type of dead code that this statement is considered to be, if it is dead
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.Name">
            <summary>
                The name of the variable.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.Type">
            <summary>
                The variable type.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.TypeName">
            <summary>
                The raw type string representing the variable type, taken from the source code.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.HasDeclarationExpression">
            <summary>
                True if an expression was used to initialize this variable declaration node when it was defined.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.IsLocal">
            <summary>
                True if this variable declaration is local to a function or event handler.  False if it is a global variable,
                parameter definition, or library constant.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.IsGlobal">
            <summary>
                True if this variable declaration is in the global program scope.  False if it is a local variable, parameter
                definition, or library constant.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.IsParameter">
            <summary>
                True if this variable declaration represents a local function/event handler parameter.  False if it is a local
                variable, global variable, or library constant.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.IsLibraryConstant">
            <summary>
                True if this variable declaration represents a library defined constant.  False if it is a local variable, global
                variable, or parameter definition.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.ParentScopeId">
            <summary>
                Represents an ID number for the scope this code statement is in, they are unique per-function/event handler.
                this is not the scopes level.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.GetError(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Returns a version of this node type that represents its error state;  in case of a syntax error
                in the node that prevents the node from being even partially built.
            </summary>
            <param name="sourceRange">The source code range of the error.</param>
            <returns>A version of this node type in its undefined/error state.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.CreateReference(Antlr4.Runtime.IToken)">
            <summary>
                Creates a reference to VariableNode by cloning and setting its <see cref="P:LibLSLCC.CodeValidator.LSLVariableNode.SourceRange" />
                to that of <paramref name="referenceToken" />
            </summary>
            <param name="referenceToken">The variable reference token from the parser</param>
            <returns>VariableNode cloned, with its <see cref="P:LibLSLCC.CodeValidator.LSLVariableNode.SourceRange" /> set</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="referenceToken" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.CreateReference(LibLSLCC.CodeValidator.LSLSourceCodeRange)">
            <summary>
                Creates a reference to <see cref="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.VariableNode" /> by cloning and setting its
                <see cref="P:LibLSLCC.CodeValidator.LSLVariableNode.SourceRange" />
                to that of <paramref name="range" />
            </summary>
            <param name="range">The source-code range of the variable token from the parser</param>
            <returns>VariableNode cloned, with its <see cref="P:LibLSLCC.CodeValidator.LSLVariableNode.SourceRange" /> set</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="range" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.CreateReference">
            <summary>
                Creates a reference to this variable declaration by cloning <see cref="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.VariableNode" />.
            </summary>
            <returns>A clone of <see cref="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.VariableNode" />.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.CreateGlobalVar(LibLSLCC.CodeValidator.LSLType,System.String)">
            <summary>
                Creates a global variable declaration node with the given <see cref="T:LibLSLCC.CodeValidator.LSLType" /> and name, without a declaration expression.
            </summary>
            <param name="type">The type of the global variable.</param>
            <param name="variableName">The name of the global variable.</param>
            <returns>The created variable declaration node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="variableName" /> is <c>null</c>.</exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException">
                <paramref name="variableName" /> contained characters not allowed in an LSL ID
                token.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.CreateLocalVar(LibLSLCC.CodeValidator.LSLType,System.String)">
            <summary>
                Creates a local variable declaration node with the given <see cref="T:LibLSLCC.CodeValidator.LSLType" /> and name, without a declaration expression.
            </summary>
            <param name="type">The type of the local variable.</param>
            <param name="variableName">The name of the local variable.</param>
            <returns>The created variable declaration node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="variableName" /> is <c>null</c>.</exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException">
                <paramref name="variableName" /> contained characters not allowed in an LSL ID
                token.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.CreateLocalVar(LibLSLCC.CodeValidator.LSLType,System.String,LibLSLCC.CodeValidator.ILSLExprNode)">
            <summary>
                Creates a local variable declaration node with the given <see cref="T:LibLSLCC.CodeValidator.LSLType" />, name, and declaration expression.
            </summary>
            <param name="type">The type of the local variable.</param>
            <param name="variableName">The name of the local variable.</param>
            <param name="declarationExpression">The declaration expression used in the local variables definition.</param>
            <returns>The created variable declaration node.</returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="variableName" /> or <paramref name="declarationExpression" />
                is <c>null</c>.
            </exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException">
                <paramref name="variableName" /> contained characters not allowed in an LSL ID token.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.CreateGlobalVar(LibLSLCC.CodeValidator.LSLType,System.String,LibLSLCC.CodeValidator.ILSLExprNode)">
            <summary>
                Creates a global variable declaration node with the given <see cref="T:LibLSLCC.CodeValidator.LSLType" />, name, and declaration expression.
            </summary>
            <param name="type">The type of the global variable.</param>
            <param name="variableName">The name of the global variable.</param>
            <param name="declarationExpression">The declaration expression used in the global variables definition.</param>
            <returns>The created variable declaration node.</returns>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="variableName" /> or <paramref name="declarationExpression" />
                is <c>null</c>.
            </exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException">
                <paramref name="variableName" /> contained characters not allowed in an LSL ID token.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.CreateLibraryConstant(LibLSLCC.CodeValidator.LSLType,System.String)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLVariableDeclarationNode" /> that references a library constant.
            </summary>
            <param name="type">The type of the library constant.</param>
            <param name="constantName">The name of the library constant.</param>
            <returns>The created variable declaration node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="constantName" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="type" /> is <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" /> or
                <paramref name="constantName" /> is contains characters that are invalid in an LSL ID token.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.CreateParameter(LibLSLCC.CodeValidator.ILSLParameterNode)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLVariableDeclarationNode" /> that represents a parameter.
            </summary>
            <returns>The created variable declaration node.</returns>
            <param name="declarationNode">A parameter node that declares the parameter variable.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="declarationNode"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.CreateVar(LibLSLCC.AntlrParser.LSLParser.GlobalVariableDeclarationContext)">
            <exception cref="T:System.ArgumentNullException"><paramref name="context" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.CreateVar(LibLSLCC.AntlrParser.LSLParser.GlobalVariableDeclarationContext,LibLSLCC.CodeValidator.ILSLExprNode)">
            <exception cref="T:System.ArgumentNullException">
                <paramref name="context" /> or <paramref name="declarationExpression" /> is
                <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.CreateVar(LibLSLCC.AntlrParser.LSLParser.LocalVariableDeclarationContext,LibLSLCC.CodeValidator.ILSLExprNode)">
            <exception cref="T:System.ArgumentNullException">
                <paramref name="context" /> or <paramref name="declarationExpression" /> is
                <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.CreateVar(LibLSLCC.AntlrParser.LSLParser.LocalVariableDeclarationContext)">
            <exception cref="T:System.ArgumentNullException"><paramref name="context" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.InsideSingleStatementScope">
            <summary>
                Always <c>false</c> for <see cref="T:LibLSLCC.CodeValidator.LSLVariableDeclarationNode" />.
            </summary>
            <seealso cref="P:LibLSLCC.CodeValidator.ILSLCodeScopeNode.IsSingleStatementScope" />
            <exception cref="T:System.NotSupportedException" accessor="set">if <c>value</c> is <c>true</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.Parent">
            <summary>
                The parent node of this syntax tree node.
            </summary>
            <exception cref="T:System.InvalidOperationException" accessor="set">If Parent has already been set.</exception>
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.StatementIndex">
            <summary>
                The index of this statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.HasReturnPath">
            <summary>
                True if the node represents a return path out of its ILSLCodeScopeNode parent, False otherwise.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.IsLastStatementInScope">
            <summary>
                Is this statement the last statement in its scope
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.IsDeadCode">
            <summary>
                Is this statement dead code
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.HasErrors">
            <summary>
                True if this syntax tree node contains syntax errors. <para/>
                <see cref="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.SourceRange"/> should point to a more specific error location when this is <c>true</c>. <para/>
                Other source ranges will not be available.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.SourceRange">
            <summary>
                The source code range that this syntax tree node occupies.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.SourceRangesAvailable">
            <summary>
                Should return true if source code ranges are available/set to meaningful values for this node.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.SourceRangeType">
            <summary>
                The source code range of the type specifier for the variable declaration.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.SourceRangeName">
            <summary>
                The source code range that encompasses the variables name in the declaration.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.SourceRangeOperator">
            <summary>
                The source code range of the assignment operator in the declaration expression if one was used.
                This value is only meaningful if either 'IsLocal' or 'IsGlobal' are true, and 'HasDeclarationExpression' is also
                true.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.SourceRangesAvailable" /> is <c>false</c> this property will be
                <c>null</c>.
            </remarks>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.AcceptVisitor``1(LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor{``0})">
            <summary>
                Accept a visit from an implementor of <see cref="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1" />
            </summary>
            <typeparam name="T">The visitors return type.</typeparam>
            <param name="visitor">The visitor instance.</param>
            <returns>The value returned from this method in the visitor used to visit this node.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="visitor"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.Clone">
            <summary>
                Deep clones the node.  It should clone the node and all of its children and cloneable properties, except the parent.
                When cloned, the parent node reference should be left <c>null</c>.
                The <see cref="P:LibLSLCC.CodeValidator.LSLVariableDeclarationNode.References"/> collection is not cloned.
            </summary>
            <returns>A deep clone of this statement tree node.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1">
            <summary>
                Default visitor base class for LSL Syntax tree visitors.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitBinaryExpression(LibLSLCC.CodeValidator.ILSLBinaryExpressionNode)">
            <summary>
                Visits a binary expression node in an LSL syntax tree during tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitListLiteralInitializerList(LibLSLCC.CodeValidator.ILSLExpressionListNode)">
            <summary>
                Visits an expression list node inside of a list literal initializer during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitExpressionList(LibLSLCC.CodeValidator.ILSLExpressionListNode)">
                VisitListLiteralInitializerList makes a call to the
                method seen here.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitFunctionCallArguments(LibLSLCC.CodeValidator.ILSLExpressionListNode)">
            <summary>
                Visits an expression list node representing a function calls parameters during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitExpressionList(LibLSLCC.CodeValidator.ILSLExpressionListNode)">
                VisitListLiteralInitializerList makes a call to the
                method seen here.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitForLoopAfterthoughts(LibLSLCC.CodeValidator.ILSLExpressionListNode)">
            <summary>
                Visits an expression list node representing a for loops afterthought expressions during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitExpressionList(LibLSLCC.CodeValidator.ILSLExpressionListNode)">
                VisitForLoopAfterthoughts makes a call to the method
                seen here.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitForLoopInitExpressions(LibLSLCC.CodeValidator.ILSLExpressionListNode)">
            <summary>
                Visits an expression list node representing a for loops initializer expressions during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitExpressionList(LibLSLCC.CodeValidator.ILSLExpressionListNode)">
                VisitForLoopInitExpressions makes a call to the method
                seen here.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitFloatLiteral(LibLSLCC.CodeValidator.ILSLFloatLiteralNode)">
            <summary>
                Visits a float literal token node during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitFunctionCall(LibLSLCC.CodeValidator.ILSLFunctionCallNode)">
            <summary>
                Visits a function call node during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitLibraryFunctionCall(LibLSLCC.CodeValidator.ILSLFunctionCallNode)">VisitLibraryFunctionCall calls this method.</seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitUserFunctionCall(LibLSLCC.CodeValidator.ILSLFunctionCallNode)">VisitUserFunctionCall calls this method.</seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitIntegerLiteral(LibLSLCC.CodeValidator.ILSLIntegerLiteralNode)">
            <summary>
                Visits an integer literal token node during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitListLiteral(LibLSLCC.CodeValidator.ILSLListLiteralNode)">
            <summary>
                Visits a list literal expression during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitParenthesizedExpression(LibLSLCC.CodeValidator.ILSLParenthesizedExpressionNode)">
            <summary>
                Visits a parenthesized expression during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitPostfixOperation(LibLSLCC.CodeValidator.ILSLPostfixOperationNode)">
            <summary>
                Visits a postfix operation expression during a syntax tree traversal.
                This occurs for the postfix increment and decrement operators.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitPrefixOperation(LibLSLCC.CodeValidator.ILSLPrefixOperationNode)">
            <summary>
                Visits a prefix operation expression during a syntax tree traversal.
                This includes the standard prefix decrement/increment operators, as well as negation/positive specification
                and the bitwise/logical NOT prefix operators.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitRotationLiteral(LibLSLCC.CodeValidator.ILSLRotationLiteralNode)">
            <summary>
                Visits a rotation literal expression node during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitStringLiteral(LibLSLCC.CodeValidator.ILSLStringLiteralNode)">
            <summary>
                Visits a string literal token node during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitTypecastExpression(LibLSLCC.CodeValidator.ILSLTypecastExprNode)">
            <summary>
                Visits a typecast expression node during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">
            <summary>
                Visits a variable reference node during syntax tree traversal.
                This occurs for: parameters, local/global variables and library constants.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitLocalVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">VisitLocalVariableReference calls this method.</seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitGlobalVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">VisitGlobalVariableReference calls this method.</seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitLibraryConstantVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">
                VisitLibraryConstantVariableReference
                calls this method.
            </seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitParameterVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">
                VisitParameterVariableReference calls this
                method.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitVecRotAccessor(LibLSLCC.CodeValidator.ILSLTupleAccessorNode)">
            <summary>
                Visit a dot operator (member access) expression used on a vector or rotation.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitVectorLiteral(LibLSLCC.CodeValidator.ILSLVectorLiteralNode)">
            <summary>
                Visits a vector literal expression node during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitDoLoop(LibLSLCC.CodeValidator.ILSLDoLoopNode)">
            <summary>
                Visits a do-loop statement node during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitForLoop(LibLSLCC.CodeValidator.ILSLForLoopNode)">
            <summary>
                Visits a for-loop statement node during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitWhileLoop(LibLSLCC.CodeValidator.ILSLWhileLoopNode)">
            <summary>
                Visits a while-loop statement node during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitCodeScope(LibLSLCC.CodeValidator.ILSLCodeScopeNode)">
            <summary>
                Visits a code scope node during syntax tree traversal.
                This should occur for all types of code scope.
                This includes: function/event handler code body's,  control/loop statement body's that either have or lack braces,
                and anonymous code scopes declared inside of a parent code scope.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitMultiStatementCodeScope(LibLSLCC.CodeValidator.ILSLCodeScopeNode)">VisitMultiStatementCodeScope calls this method.</seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitSingleStatementCodeScope(LibLSLCC.CodeValidator.ILSLCodeScopeNode)">
                VisitMultiStatementCodeScope calls this
                method.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitCompilationUnit(LibLSLCC.CodeValidator.ILSLCompilationUnitNode)">
            <summary>
                Visits the top level of an LSL compilation unit node during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitEventHandler(LibLSLCC.CodeValidator.ILSLEventHandlerNode)">
            <summary>
                Visits and event handler usage node during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitFunctionDeclaration(LibLSLCC.CodeValidator.ILSLFunctionDeclarationNode)">
            <summary>
                Visits the declaration node of a user defined function during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitDefaultState(LibLSLCC.CodeValidator.ILSLStateScopeNode)">
            <summary>
                Visits the default script state node during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitDefinedState(LibLSLCC.CodeValidator.ILSLStateScopeNode)">
            <summary>
                Visits user defined script states during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitParameterDefinition(LibLSLCC.CodeValidator.ILSLParameterNode)">
            <summary>
                Visits a parameter definition of either a user defined function or event handler during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitParameterDefinitionList(LibLSLCC.CodeValidator.ILSLParameterListNode)">
                VisitParameterDefinitionList calls this method
                while visiting its children.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitParameterDefinitionList(LibLSLCC.CodeValidator.ILSLParameterListNode)">
            <summary>
                Visits a parameter list node of either a user defined function or event handler during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitParameterDefinition(LibLSLCC.CodeValidator.ILSLParameterNode)">
                VisitParameterDefinition is a child call of this
                visitor method.
            </seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitEventHandler(LibLSLCC.CodeValidator.ILSLEventHandlerNode)">
                VisitEventHandler calls this method while visiting its
                parameters.
            </seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitFunctionDeclaration(LibLSLCC.CodeValidator.ILSLFunctionDeclarationNode)">
                VisitFunctionDeclaration calls this method while
                visiting its parameters.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitReturnStatement(LibLSLCC.CodeValidator.ILSLReturnStatementNode)">
            <summary>
                Visits a return statement inside of a user defined event or event handler during syntax tree traversal.
                If the return statement returns an expression, that is visited to.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitSemicolonStatement(LibLSLCC.CodeValidator.ILSLSemicolonStatement)">
            <summary>
                Visits a (vestigial) semi-colon statement during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitStateChangeStatement(LibLSLCC.CodeValidator.ILSLStateChangeStatementNode)">
            <summary>
                Visits a state change statement during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitJumpStatement(LibLSLCC.CodeValidator.ILSLJumpStatementNode)">
            <summary>
                Visits a jump statement during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitLabelStatement(LibLSLCC.CodeValidator.ILSLLabelStatementNode)">
            <summary>
                Visits a label statement during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitControlStatement(LibLSLCC.CodeValidator.ILSLControlStatementNode)">
            <summary>
                Visits the top level of a control statement chain during a syntax tree traversal.
                <see cref="T:LibLSLCC.CodeValidator.ILSLControlStatementNode" /> contains IF, ELSE-IF, and ELSE nodes as its children.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitIfStatement(LibLSLCC.CodeValidator.ILSLIfStatementNode)">VisitIfStatement is a child call of this visitor method.</seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitElseIfStatement(LibLSLCC.CodeValidator.ILSLElseIfStatementNode)">
                VisitElseIfStatement is a child call of this visitor
                method.
            </seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitElseStatement(LibLSLCC.CodeValidator.ILSLElseStatementNode)">
                VisitElseStatement is a child call of this visitor
                method.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitIfStatement(LibLSLCC.CodeValidator.ILSLIfStatementNode)">
            <summary>
                Visits an if statement node during a syntax tree traversal.
                If statement nodes are children of <see cref="T:LibLSLCC.CodeValidator.ILSLControlStatementNode" /> instances.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitControlStatement(LibLSLCC.CodeValidator.ILSLControlStatementNode)">
                VisitControlStatement should call this function while
                visiting its children.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitElseIfStatement(LibLSLCC.CodeValidator.ILSLElseIfStatementNode)">
            <summary>
                Visits an else-if statement node during a syntax tree traversal.
                Else-If statement nodes are children of <see cref="T:LibLSLCC.CodeValidator.ILSLControlStatementNode" /> instances.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitControlStatement(LibLSLCC.CodeValidator.ILSLControlStatementNode)">
                VisitControlStatement should call this function while
                visiting its children.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitElseStatement(LibLSLCC.CodeValidator.ILSLElseStatementNode)">
            <summary>
                Visits an else statement node during a syntax tree traversal.
                Else statement nodes are children of <see cref="T:LibLSLCC.CodeValidator.ILSLControlStatementNode" /> instances.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitControlStatement(LibLSLCC.CodeValidator.ILSLControlStatementNode)">
                VisitControlStatement should call this function while
                visiting its children.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitExpressionStatement(LibLSLCC.CodeValidator.ILSLExpressionStatementNode)">
            <summary>
                Visits an expression statement node during a syntax tree traversal.
                Expression statement nodes are the individual statements that occur sequentially inside of a code scope.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.Visit(LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode)">
            <summary>
                The generic visit function for the syntax tree visitor.  It should delegate to treeNode.AcceptVisitor(this).
            </summary>
            <param name="treeNode">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitGlobalVariableDeclaration(LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
            <summary>
                Visits a global variable declaration during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitVariableDeclaration(LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
                VisitGlobalVariableDeclaration makes a call to the
                method seen here.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitLocalVariableDeclaration(LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
            <summary>
                Visits a local variable declaration inside of a user defined function or event handler during a syntax tree
                traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitVariableDeclaration(LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
                VisitLocalVariableDeclaration makes a call to the
                method seen here.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitSingleStatementCodeScope(LibLSLCC.CodeValidator.ILSLCodeScopeNode)">
            <summary>
                Visits a brace-less code scope during a syntax tree traversal.
                Brace-less code scopes can occur as the code body for if/else-if and else statements, as well for all types of loop
                statements. (for/while/do-while).
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitCodeScope(LibLSLCC.CodeValidator.ILSLCodeScopeNode)">
                VisitSingleStatementCodeScope makes a call to the method seen
                here.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitMultiStatementCodeScope(LibLSLCC.CodeValidator.ILSLCodeScopeNode)">
            <summary>
                Visit a standard multi-statement code scope during a syntax tree traversal.
                Multi-statement code scopes will always be: a function/event handler code body, the body of a control/loop
                statement, or an anonymous code scope declared inside of a parent code scope.
            </summary>
            <param name="codeScopeNode">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitCodeScope(LibLSLCC.CodeValidator.ILSLCodeScopeNode)">
                VisitMultiStatementCodeScope makes a call to the method seen
                here.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitHexLiteral(LibLSLCC.CodeValidator.ILSLHexLiteralNode)">
            <summary>
                Visits a hex literal token node during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitLibraryFunctionCallParameters(LibLSLCC.CodeValidator.ILSLExpressionListNode)">
            <summary>
                Visits the function call parameter list node used for a call to a library defined function during a syntax tree
                traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitFunctionCallArguments(LibLSLCC.CodeValidator.ILSLExpressionListNode)">
                VisitLibraryFunctionCallParameters makes a call
                to the method seen here.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitUserFunctionCallParameters(LibLSLCC.CodeValidator.ILSLExpressionListNode)">
            <summary>
                Visits the function call parameter list node used for a call to a user defined function during a syntax tree
                traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitFunctionCallArguments(LibLSLCC.CodeValidator.ILSLExpressionListNode)">
                VisitUserFunctionCallParameters makes a call to
                the method seen here.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitGlobalVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">
            <summary>
                Visits a variable node representing a reference to a global variable during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">
                VisitGlobalVariableReference makes a call to the
                method seen here.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitLocalVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">
            <summary>
                Visits a variable node representing a reference to a local variable during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">
                VisitLocalVariableReference makes a call to the
                method seen here.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitParameterVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">
            <summary>
                Visits a variable node representing a reference to a locally defined function or event handler parameter during a
                syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">
                VisitParameterVariableReference makes a call to the
                method seen here.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitLibraryConstantVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">
            <summary>
                Visits a variable node representing a reference to a library defined constant during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">
                VisitLibraryConstantVariableReference makes a call to
                the method seen here.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitLibraryFunctionCall(LibLSLCC.CodeValidator.ILSLFunctionCallNode)">
            <summary>
                Visits a function call node representing a call to a library defined function during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitFunctionCall(LibLSLCC.CodeValidator.ILSLFunctionCallNode)">
                VisitLibraryFunctionCall makes a call to the method seen
                here.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitUserFunctionCall(LibLSLCC.CodeValidator.ILSLFunctionCallNode)">
            <summary>
                Visits a function call node representing a call to a user defined function during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitFunctionCall(LibLSLCC.CodeValidator.ILSLFunctionCallNode)">
                VisitUserFunctionCall makes a call to the method seen
                here.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitExpressionList(LibLSLCC.CodeValidator.ILSLExpressionListNode)">
            <summary>
                Visit an expression list node during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitFunctionCallArguments(LibLSLCC.CodeValidator.ILSLExpressionListNode)">VisitFunctionCallParameters calls this method.</seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitListLiteralInitializerList(LibLSLCC.CodeValidator.ILSLExpressionListNode)">
                VisitListLiteralInitializerList calls this
                method.
            </seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitForLoopInitExpressions(LibLSLCC.CodeValidator.ILSLExpressionListNode)">VisitForLoopInitExpressions calls this method.</seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitForLoopAfterthoughts(LibLSLCC.CodeValidator.ILSLExpressionListNode)">VisitForLoopAfterthoughts calls this method.</seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitState(LibLSLCC.CodeValidator.ILSLStateScopeNode)">
            <summary>
                Visit a code state definition node during a syntax tree traversal.
            </summary>
            <param name="stateNode">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitDefaultState(LibLSLCC.CodeValidator.ILSLStateScopeNode)">VisitDefaultState calls this method.</seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitDefinedState(LibLSLCC.CodeValidator.ILSLStateScopeNode)">VisitDefinedState calls this method.</seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitVariableDeclaration(LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
            <summary>
                Visit a variable declaration node during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitGlobalVariableDeclaration(LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
                VisitGlobalVariableDeclaration calls this
                method.
            </seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitLocalVariableDeclaration(LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
                VisitLocalVariableDeclaration calls this
                method.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1">
            <summary>
                Interface for LSL Syntax tree visitors.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitBinaryExpression(LibLSLCC.CodeValidator.ILSLBinaryExpressionNode)">
            <summary>
                Visits a binary expression node in an LSL syntax tree during tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitListLiteralInitializerList(LibLSLCC.CodeValidator.ILSLExpressionListNode)">
            <summary>
                Visits an expression list node inside of a list literal initializer during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitExpressionList(LibLSLCC.CodeValidator.ILSLExpressionListNode)">VisitListLiteralInitializerList calls this method.</seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitFunctionCallArguments(LibLSLCC.CodeValidator.ILSLExpressionListNode)">
            <summary>
                Visits an expression list node representing a function calls parameters during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitExpressionList(LibLSLCC.CodeValidator.ILSLExpressionListNode)">VisitListLiteralInitializerList calls this method.</seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitForLoopAfterthoughts(LibLSLCC.CodeValidator.ILSLExpressionListNode)">
            <summary>
                Visits an expression list node representing a for loops afterthought expressions during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitExpressionList(LibLSLCC.CodeValidator.ILSLExpressionListNode)">VisitForLoopAfterthoughts calls this method.</seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitForLoopInitExpressions(LibLSLCC.CodeValidator.ILSLExpressionListNode)">
            <summary>
                Visits an expression list node representing a for loops initializer expressions during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitExpressionList(LibLSLCC.CodeValidator.ILSLExpressionListNode)">VisitForLoopInitExpressions calls this method.</seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitFloatLiteral(LibLSLCC.CodeValidator.ILSLFloatLiteralNode)">
            <summary>
                Visits a float literal token node during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitFunctionCall(LibLSLCC.CodeValidator.ILSLFunctionCallNode)">
            <summary>
                Visits a function call node during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitLibraryFunctionCall(LibLSLCC.CodeValidator.ILSLFunctionCallNode)">VisitLibraryFunctionCall calls this method.</seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitUserFunctionCall(LibLSLCC.CodeValidator.ILSLFunctionCallNode)">VisitUserFunctionCall calls this method.</seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitIntegerLiteral(LibLSLCC.CodeValidator.ILSLIntegerLiteralNode)">
            <summary>
                Visits an integer literal token node during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitListLiteral(LibLSLCC.CodeValidator.ILSLListLiteralNode)">
            <summary>
                Visits a list literal expression during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitParenthesizedExpression(LibLSLCC.CodeValidator.ILSLParenthesizedExpressionNode)">
            <summary>
                Visits a parenthesized expression during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitPostfixOperation(LibLSLCC.CodeValidator.ILSLPostfixOperationNode)">
            <summary>
                Visits a postfix operation expression during a syntax tree traversal.
                This occurs for the postfix increment and decrement operators.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitPrefixOperation(LibLSLCC.CodeValidator.ILSLPrefixOperationNode)">
            <summary>
                Visits a prefix operation expression during a syntax tree traversal.
                This includes the standard prefix decrement/increment operators, as well as negation/positive specification
                and the bitwise/logical NOT prefix operators.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitRotationLiteral(LibLSLCC.CodeValidator.ILSLRotationLiteralNode)">
            <summary>
                Visits a rotation literal expression node during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitStringLiteral(LibLSLCC.CodeValidator.ILSLStringLiteralNode)">
            <summary>
                Visits a string literal token node during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitTypecastExpression(LibLSLCC.CodeValidator.ILSLTypecastExprNode)">
            <summary>
                Visits a typecast expression node during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">
            <summary>
                Visits a variable reference node during syntax tree traversal.
                This occurs for: parameters, local/global variables and library constants.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitLocalVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">VisitLocalVariableReference calls this method.</seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitGlobalVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">VisitGlobalVariableReference calls this method.</seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitLibraryConstantVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">
                VisitLibraryConstantVariableReference
                calls this method.
            </seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitParameterVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">
                VisitParameterVariableReference calls this
                method.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitVecRotAccessor(LibLSLCC.CodeValidator.ILSLTupleAccessorNode)">
            <summary>
                Visit a dot operator (member access) expression used on a vector or rotation.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitVectorLiteral(LibLSLCC.CodeValidator.ILSLVectorLiteralNode)">
            <summary>
                Visits a vector literal expression node during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitDoLoop(LibLSLCC.CodeValidator.ILSLDoLoopNode)">
            <summary>
                Visits a do-loop statement node during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitForLoop(LibLSLCC.CodeValidator.ILSLForLoopNode)">
            <summary>
                Visits a for-loop statement node during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitWhileLoop(LibLSLCC.CodeValidator.ILSLWhileLoopNode)">
            <summary>
                Visits a while-loop statement node during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitCodeScope(LibLSLCC.CodeValidator.ILSLCodeScopeNode)">
            <summary>
                Visits a code scope node during syntax tree traversal.
                This should occur for all types of code scope.
                This includes: function/event handler code body's,  control/loop statement body's that either have or lack braces,
                and anonymous code scopes declared inside of a parent code scope.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitMultiStatementCodeScope(LibLSLCC.CodeValidator.ILSLCodeScopeNode)">VisitMultiStatementCodeScope calls this method.</seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitSingleStatementCodeScope(LibLSLCC.CodeValidator.ILSLCodeScopeNode)">
                VisitMultiStatementCodeScope calls this
                method.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitCompilationUnit(LibLSLCC.CodeValidator.ILSLCompilationUnitNode)">
            <summary>
                Visits the top level of an LSL compilation unit node during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitEventHandler(LibLSLCC.CodeValidator.ILSLEventHandlerNode)">
            <summary>
                Visits and event handler usage node during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitFunctionDeclaration(LibLSLCC.CodeValidator.ILSLFunctionDeclarationNode)">
            <summary>
                Visits the declaration node of a user defined function during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitDefaultState(LibLSLCC.CodeValidator.ILSLStateScopeNode)">
            <summary>
                Visits the default script state node during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitDefinedState(LibLSLCC.CodeValidator.ILSLStateScopeNode)">
            <summary>
                Visits user defined script states during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitParameterDefinition(LibLSLCC.CodeValidator.ILSLParameterNode)">
            <summary>
                Visits a parameter definition of either a user defined function or event handler during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitParameterDefinitionList(LibLSLCC.CodeValidator.ILSLParameterListNode)">
                VisitParameterDefinitionList calls this method
                while visiting its children.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitParameterDefinitionList(LibLSLCC.CodeValidator.ILSLParameterListNode)">
            <summary>
                Visits a parameter list node of either a user defined function or event handler during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitParameterDefinition(LibLSLCC.CodeValidator.ILSLParameterNode)">
                VisitParameterDefinition is a child call of this
                visitor method.
            </seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitEventHandler(LibLSLCC.CodeValidator.ILSLEventHandlerNode)">
                VisitEventHandler calls this method while visiting its
                parameters.
            </seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitFunctionDeclaration(LibLSLCC.CodeValidator.ILSLFunctionDeclarationNode)">
                VisitFunctionDeclaration calls this method while
                visiting its parameters.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitReturnStatement(LibLSLCC.CodeValidator.ILSLReturnStatementNode)">
            <summary>
                Visits a return statement inside of a user defined event or event handler during syntax tree traversal.
                If the return statement returns an expression, that is visited to.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitSemicolonStatement(LibLSLCC.CodeValidator.ILSLSemicolonStatement)">
            <summary>
                Visits a (vestigial) semi-colon statement during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitStateChangeStatement(LibLSLCC.CodeValidator.ILSLStateChangeStatementNode)">
            <summary>
                Visits a state change statement during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitJumpStatement(LibLSLCC.CodeValidator.ILSLJumpStatementNode)">
            <summary>
                Visits a jump statement during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitLabelStatement(LibLSLCC.CodeValidator.ILSLLabelStatementNode)">
            <summary>
                Visits a label statement during syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitControlStatement(LibLSLCC.CodeValidator.ILSLControlStatementNode)">
            <summary>
                Visits the top level of a control statement chain during a syntax tree traversal.
                <see cref="T:LibLSLCC.CodeValidator.ILSLControlStatementNode" /> contains IF, ELSE-IF, and ELSE nodes as its children.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitIfStatement(LibLSLCC.CodeValidator.ILSLIfStatementNode)">VisitIfStatement is a child call of this visitor method.</seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitElseIfStatement(LibLSLCC.CodeValidator.ILSLElseIfStatementNode)">
                VisitElseIfStatement is a child call of this visitor
                method.
            </seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitElseStatement(LibLSLCC.CodeValidator.ILSLElseStatementNode)">
                VisitElseStatement is a child call of this visitor
                method.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitIfStatement(LibLSLCC.CodeValidator.ILSLIfStatementNode)">
            <summary>
                Visits an if statement node during a syntax tree traversal.
                If statement nodes are children of <see cref="T:LibLSLCC.CodeValidator.ILSLControlStatementNode" /> instances.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitControlStatement(LibLSLCC.CodeValidator.ILSLControlStatementNode)">
                VisitControlStatement should call this function while
                visiting its children.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitElseIfStatement(LibLSLCC.CodeValidator.ILSLElseIfStatementNode)">
            <summary>
                Visits an else-if statement node during a syntax tree traversal.
                Else-If statement nodes are children of <see cref="T:LibLSLCC.CodeValidator.ILSLControlStatementNode" /> instances.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitControlStatement(LibLSLCC.CodeValidator.ILSLControlStatementNode)">
                VisitControlStatement should call this function while
                visiting its children.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitElseStatement(LibLSLCC.CodeValidator.ILSLElseStatementNode)">
            <summary>
                Visits an else statement node during a syntax tree traversal.
                Else statement nodes are children of <see cref="T:LibLSLCC.CodeValidator.ILSLControlStatementNode" /> instances.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitControlStatement(LibLSLCC.CodeValidator.ILSLControlStatementNode)">
                VisitControlStatement should call this function while
                visiting its children.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitExpressionStatement(LibLSLCC.CodeValidator.ILSLExpressionStatementNode)">
            <summary>
                Visits an expression statement node during a syntax tree traversal.
                Expression statement nodes are the individual statements that occur sequentially inside of a code scope.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.Visit(LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode)">
            <summary>
                The generic visit function for the syntax tree visitor.  It should delegate to treeNode.AcceptVisitor(this).
            </summary>
            <param name="treeNode">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitGlobalVariableDeclaration(LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
            <summary>
                Visits a global variable declaration during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitVariableDeclaration(LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">VisitGlobalVariableDeclaration calls this method.</seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitLocalVariableDeclaration(LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
            <summary>
                Visits a local variable declaration inside of a user defined function or event handler during a syntax tree
                traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitVariableDeclaration(LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">VisitLocalVariableDeclaration calls this method.</seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitSingleStatementCodeScope(LibLSLCC.CodeValidator.ILSLCodeScopeNode)">
            <summary>
                Visits a brace-less code scope during a syntax tree traversal.
                Brace-less code scopes can occur as the code body for if/else-if and else statements, as well for all types of loop
                statements. (for/while/do-while).
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitCodeScope(LibLSLCC.CodeValidator.ILSLCodeScopeNode)">VisitSingleStatementCodeScope calls this method.</seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitMultiStatementCodeScope(LibLSLCC.CodeValidator.ILSLCodeScopeNode)">
            <summary>
                Visit a standard multi-statement code scope during a syntax tree traversal.
                Multi-statement code scopes will always be: a function/event handler code body, the body of a control/loop
                statement, or an anonymous code scope declared inside of a parent code scope.
            </summary>
            <param name="codeScopeNode">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitCodeScope(LibLSLCC.CodeValidator.ILSLCodeScopeNode)">VisitMultiStatementCodeScope calls this method.</seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitHexLiteral(LibLSLCC.CodeValidator.ILSLHexLiteralNode)">
            <summary>
                Visits a hex literal token node during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitLibraryFunctionCallParameters(LibLSLCC.CodeValidator.ILSLExpressionListNode)">
            <summary>
                Visits the function call parameter list node used for a call to a library defined function during a syntax tree
                traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitFunctionCallArguments(LibLSLCC.CodeValidator.ILSLExpressionListNode)">
                VisitLibraryFunctionCallParameters calls this
                method.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitUserFunctionCallParameters(LibLSLCC.CodeValidator.ILSLExpressionListNode)">
            <summary>
                Visits the function call parameter list node used for a call to a user defined function during a syntax tree
                traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitFunctionCallArguments(LibLSLCC.CodeValidator.ILSLExpressionListNode)">
                VisitUserFunctionCallParameters calls this
                method.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitGlobalVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">
            <summary>
                Visits a variable node representing a reference to a global variable during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">VisitGlobalVariableReference calls this method.</seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitLocalVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">
            <summary>
                Visits a variable node representing a reference to a local variable during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">VisitLocalVariableReference calls this method.</seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitParameterVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">
            <summary>
                Visits a variable node representing a reference to a locally defined function or event handler parameter during a
                syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">VisitParameterVariableReference calls this method.</seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitLibraryConstantVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">
            <summary>
                Visits a variable node representing a reference to a library defined constant during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitVariableReference(LibLSLCC.CodeValidator.ILSLVariableNode)">
                VisitLibraryConstantVariableReference calls this
                method.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitLibraryFunctionCall(LibLSLCC.CodeValidator.ILSLFunctionCallNode)">
            <summary>
                Visits a function call node representing a call to a library defined function during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitFunctionCall(LibLSLCC.CodeValidator.ILSLFunctionCallNode)">VisitLibraryFunctionCall calls this method.</seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitUserFunctionCall(LibLSLCC.CodeValidator.ILSLFunctionCallNode)">
            <summary>
                Visits a function call node representing a call to a user defined function during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitFunctionCall(LibLSLCC.CodeValidator.ILSLFunctionCallNode)">VisitUserFunctionCall calls this method.</seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitExpressionList(LibLSLCC.CodeValidator.ILSLExpressionListNode)">
            <summary>
                Visit an expression list node during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitFunctionCallArguments(LibLSLCC.CodeValidator.ILSLExpressionListNode)">VisitFunctionCallParameters calls this method.</seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitListLiteralInitializerList(LibLSLCC.CodeValidator.ILSLExpressionListNode)">
                VisitListLiteralInitializerList calls this
                method.
            </seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitForLoopInitExpressions(LibLSLCC.CodeValidator.ILSLExpressionListNode)">VisitForLoopInitExpressions calls this method.</seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitForLoopAfterthoughts(LibLSLCC.CodeValidator.ILSLExpressionListNode)">VisitForLoopAfterthoughts calls this method.</seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitState(LibLSLCC.CodeValidator.ILSLStateScopeNode)">
            <summary>
                Visit a code state definition node during a syntax tree traversal.
            </summary>
            <param name="stateNode">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitDefaultState(LibLSLCC.CodeValidator.ILSLStateScopeNode)">VisitDefaultState calls this method.</seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitDefinedState(LibLSLCC.CodeValidator.ILSLStateScopeNode)">VisitDefinedState calls this method.</seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="M:LibLSLCC.CodeValidator.ILSLValidatorNodeVisitor`1.VisitVariableDeclaration(LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
            <summary>
                Visit a variable declaration node during a syntax tree traversal.
            </summary>
            <param name="node">The Syntax Tree Node.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitGlobalVariableDeclaration(LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
                VisitGlobalVariableDeclaration calls this
                method.
            </seealso>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLValidatorNodeVisitor`1.VisitLocalVariableDeclaration(LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
                VisitLocalVariableDeclaration calls this
                method.
            </seealso>
            <returns>An object of type (T) from the visitor implementation of this function.</returns>
        </member>
        <member name="T:LibLSLCC.CodeValidator.LSLCodeValidator">
            <summary>
                <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" /> is responsible for building an abstracted LSL syntax tree with
                <see cref="T:LibLSLCC.CodeValidator.ILSLCompilationUnitNode" /> as the top node.
                <para>
                    <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" /> preforms full front end syntax checking of the source code as the tree is
                    built.
                    It delegates syntax errors and syntax warning invocations/information to the
                    <see cref="P:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies.SyntaxErrorListener" /> and
                    <see cref="P:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies.SyntaxWarningListener" /> instances of the
                    <see cref="T:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies" /> object
                    assigned to the <see cref="P:LibLSLCC.CodeValidator.LSLCodeValidator.ValidatorStrategies" /> property.
                </para>
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidator.#ctor(LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies)">
            <summary>
                Constructs an LSLCodeValidator using the given <see cref="T:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies" />.
            </summary>
            <see cref="T:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies" />
            <param name="validatorStrategies">The <see cref="T:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies" /> to use.</param>
            <exception cref="T:System.ArgumentException">
                If one or more of <paramref name="validatorStrategies" /> properties are
                <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="validatorStrategies" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidator.#ctor">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" /> using <see cref="M:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies.Default" /> to initialize
                the <see cref="P:LibLSLCC.CodeValidator.LSLCodeValidator.ValidatorStrategies" /> property.
            </summary>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies.Default"/>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidator.#ctor(LibLSLCC.CodeValidator.ILSLBasicLibraryDataProvider)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" /> using <see cref="M:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies.Default(LibLSLCC.CodeValidator.ILSLBasicLibraryDataProvider)" /> to initialize
                the <see cref="P:LibLSLCC.CodeValidator.LSLCodeValidator.ValidatorStrategies" /> property.
            </summary>
            <param name="libraryDataProvider">The library data provider to use.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies.Default"/>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidator.#ctor(LibLSLCC.CodeValidator.ILSLBasicLibraryDataProvider,LibLSLCC.CodeValidator.ILSLSyntaxErrorListener,LibLSLCC.CodeValidator.ILSLSyntaxWarningListener)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" /> using <see cref="M:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies.Default(LibLSLCC.CodeValidator.ILSLBasicLibraryDataProvider,LibLSLCC.CodeValidator.ILSLSyntaxErrorListener,LibLSLCC.CodeValidator.ILSLSyntaxWarningListener)" /> to initialize
                the <see cref="P:LibLSLCC.CodeValidator.LSLCodeValidator.ValidatorStrategies" /> property.
            </summary>
            <param name="libraryDataProvider">The library data provider to use.</param>
            <param name="errorListener">The syntax error listener to use.</param>
            <param name="warningListener">The warning error listener to use.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies.Default"/>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidator.#ctor(LibLSLCC.CodeValidator.ILSLSyntaxErrorListener,LibLSLCC.CodeValidator.ILSLSyntaxWarningListener)">
            <summary>
                Construct an <see cref="T:LibLSLCC.CodeValidator.LSLCodeValidator" /> using <see cref="M:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies.Default(LibLSLCC.CodeValidator.ILSLSyntaxErrorListener,LibLSLCC.CodeValidator.ILSLSyntaxWarningListener)" /> to initialize
                the <see cref="P:LibLSLCC.CodeValidator.LSLCodeValidator.ValidatorStrategies" /> property.
            </summary>
            <param name="errorListener">The syntax error listener to use.</param>
            <param name="warningListener">The warning error listener to use.</param>
            <seealso cref="M:LibLSLCC.CodeValidator.LSLCodeValidatorStrategies.Default"/>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeValidator.ValidatorStrategies">
            <summary>
                <see cref="T:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies" /> that provides several components to the validator.
                Among them are the <see cref="P:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies.SyntaxErrorListener" /> and
                <see cref="P:LibLSLCC.CodeValidator.ILSLCodeValidatorStrategies.SyntaxWarningListener" /> implementations.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeValidator.HasSyntaxWarnings">
            <summary>
                Set to true if the last call to <see cref="M:LibLSLCC.CodeValidator.LSLCodeValidator.Validate(System.IO.TextReader)"/> generated syntax warnings.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeValidator.LSLCodeValidator.HasSyntaxErrors">
            <summary>
                Set to <c>true</c> if the last call to <see cref="M:LibLSLCC.CodeValidator.LSLCodeValidator.Validate(System.IO.TextReader)"/> generated syntax errors.
                <see cref="M:LibLSLCC.CodeValidator.LSLCodeValidator.Validate(System.IO.TextReader)"/> will return <c>null</c> upon encountering syntax errors as well.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeValidator.LSLCodeValidator.Validate(System.IO.TextReader)">
            <summary>
                Validates the code content of a TextReader and returns the top of the compilation unit syntax tree.
                If parsing resulted in syntax errors the result will be <c>null</c>.
            </summary>
            <param name="stream">The TextReader to parse code from.</param>
            <returns>Top level node of an LSL syntax tree.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="stream"/> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.Collections.CloneableExtensions">
            <summary>
                Extensions related to the <see cref="T:System.ICloneable" /> interface.
            </summary>
        </member>
        <member name="M:LibLSLCC.Collections.CloneableExtensions.CloneAll``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Clones all elements of an <see cref="T:System.Collections.Generic.IEnumerable`1" /> that enumerates objects implementing
                <see cref="T:System.ICloneable" />
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable">The enumerable of <see cref="T:System.ICloneable" /> implementors.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that enumerates over clones of every item in <paramref name="enumerable" />.</returns>
        </member>
        <member name="T:LibLSLCC.Collections.IObservableHashSetItem">
            <summary>
                Interface that allows IObservableHashSet to check if an item has had a property that is
                important to the generation of the items hash code change, and throw an exception when that happens.
            </summary>
        </member>
        <member name="P:LibLSLCC.Collections.IObservableHashSetItem.HashEqualityPropertyNames">
            <summary>
                The set of property names that are involved with generating the hash code for an object.
            </summary>
        </member>
        <member name="T:LibLSLCC.Collections.ObservableDictionary`2">
            <summary>
                Observable and bindable dictionary implementation.
            </summary>
            <typeparam name="TKey">The key type.</typeparam>
            <typeparam name="TValue">The value type.</typeparam>
        </member>
        <member name="M:LibLSLCC.Collections.ObservableDictionary`2.#ctor">
            <summary>
                Construct an empty ObservableDictionary.
            </summary>
        </member>
        <member name="M:LibLSLCC.Collections.ObservableDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
                Construct an observable dictionary from an existing dictionary.
            </summary>
            <param name="other">The other dictionary.</param>
        </member>
        <member name="M:LibLSLCC.Collections.ObservableDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
                Construct an observable dictionary from an existing dictionary and a key comparer.
            </summary>
            <param name="other">The other dictionary.</param>
            <param name="comparer">A comparer.</param>
        </member>
        <member name="P:LibLSLCC.Collections.ObservableDictionary`2.IsReadOnly">
            <summary>
                Whether or not this collection is read only.  (<c>false</c>)
            </summary>
        </member>
        <member name="P:LibLSLCC.Collections.ObservableDictionary`2.Keys">
            <summary>
                The keys currently in use in this dictionary.
            </summary>
        </member>
        <member name="P:LibLSLCC.Collections.ObservableDictionary`2.Values">
            <summary>
                The values currently in use in this dictionary
            </summary>
        </member>
        <member name="M:LibLSLCC.Collections.ObservableDictionary`2.GetEnumerator">
            <summary>
                Returns an enumerator over the key value pairs in this dictionary.
            </summary>
            <returns>An enumerator over the key value pairs in this dictionary.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.ObservableDictionary`2.Clear">
            <summary>
                Clear the dictionary.
            </summary>
        </member>
        <member name="M:LibLSLCC.Collections.ObservableDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
                Check if this dictionary contains a specific key value pair.
            </summary>
            <param name="item">The pair to check for.</param>
            <returns><c>true</c> if this dictionary contains the specified pair.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.ObservableDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
                Copies the key value pairs in this dictionary to an array starting at <paramref name="arrayIndex" />.
            </summary>
            <param name="array">The array to copy to.</param>
            <param name="arrayIndex">The index in <paramref name="arrayIndex" /> at which to start copying</param>
        </member>
        <member name="P:LibLSLCC.Collections.ObservableDictionary`2.Count">
            <summary>
                The number of items currently in this dictionary.
            </summary>
        </member>
        <member name="M:LibLSLCC.Collections.ObservableDictionary`2.ContainsKey(`0)">
            <summary>
                Check if this dictionary contains the specified key.
            </summary>
            <param name="key">The key to check for.</param>
            <returns><c>true</c> if this dictionary contains the specified key.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.ObservableDictionary`2.Add(`0,`1)">
            <summary>
                Add a value with the given key to this dictionary.
            </summary>
            <param name="key">The key to use.</param>
            <param name="value">The value to associate with the key.</param>
        </member>
        <member name="M:LibLSLCC.Collections.ObservableDictionary`2.Remove(`0)">
            <summary>
                Remove a value from this dictionary given its key.
            </summary>
            <param name="key">The key the value is associated with.</param>
            <returns><c>true</c> if the key value pair was removed, <c>false</c> if the key was not found.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.ObservableDictionary`2.TryGetValue(`0,`1@)">
            <summary>
                Attempt to get the value associated with a given key.
            </summary>
            <param name="key">The key to try to get the value for.</param>
            <param name="value">The found value is put here, otherwise this 'out' variable is assigned <c>null</c>.</param>
            <returns><c>true</c> if the key existed and the value was found.</returns>
        </member>
        <member name="P:LibLSLCC.Collections.ObservableDictionary`2.Item(`0)">
            <summary>
                Return a given value by its key.
            </summary>
            <param name="key">The key that is associated with the value.</param>
            <returns>The value if it exists.</returns>
        </member>
        <member name="E:LibLSLCC.Collections.ObservableDictionary`2.CollectionChanged">
            <summary>
                This event is raised when this dictionary's item collection is changed.
            </summary>
        </member>
        <member name="E:LibLSLCC.Collections.ObservableDictionary`2.PropertyChanged">
            <summary>
                This event is raised when a property of this dictionary changes. (such as Count, Item[], Values, or Keys)
            </summary>
        </member>
        <member name="M:LibLSLCC.Collections.ObservableDictionary`2.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>
                This event is raised when this dictionary's item collection is changed.
            </summary>
            <param name="e">The collection changed event arguments.</param>
        </member>
        <member name="M:LibLSLCC.Collections.ObservableDictionary`2.OnPropertyChanged(System.String)">
            <summary>
                This event is raised when a property of this dictionary changes. (such as Count, Item[], Values, or Keys)
            </summary>
            <param name="propertyName">The name of the property that changed.</param>
        </member>
        <member name="T:LibLSLCC.Collections.ObservableHashSet`1">
            <summary>
                Observable and bindable HashSet
            </summary>
            <seealso cref="T:LibLSLCC.Collections.IObservableHashSetItem" />
            <typeparam name="T">The item type the hash set holds.</typeparam>
        </member>
        <member name="M:LibLSLCC.Collections.ObservableHashSet`1.#ctor">
            <summary>
                Construct an empty ObservableHashSet
            </summary>
        </member>
        <member name="M:LibLSLCC.Collections.ObservableHashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Construct an ObservableHashSet using the elements from an <see cref="T:System.Collections.Generic.IEnumerable`1" />
            </summary>
            <param name="collection">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> to draw elements from.</param>
        </member>
        <member name="M:LibLSLCC.Collections.ObservableHashSet`1.Clone">
            <summary>
                Creates a shallow copy of this <see cref="T:LibLSLCC.Collections.ObservableHashSet`1"/>.
            </summary>
            <returns>A shallow copy of this <see cref="T:LibLSLCC.Collections.ObservableHashSet`1"/>.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.ObservableHashSet`1.ClearItems">
            <summary>
                Removes all items from the collection.
            </summary>
        </member>
        <member name="M:LibLSLCC.Collections.ObservableHashSet`1.RemoveItem(System.Int32)">
            <summary>
                Removes the item at the specified index of the collection.
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
        </member>
        <member name="M:LibLSLCC.Collections.ObservableHashSet`1.InsertItem(System.Int32,`0)">
            <summary>
                Inserts an item into the collection at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
            <param name="item">The object to insert.</param>
        </member>
        <member name="M:LibLSLCC.Collections.ObservableHashSet`1.SetItem(System.Int32,`0)">
            <summary>
                Replaces the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to replace.</param>
            <param name="item">The new value for the element at the specified index.</param>
        </member>
        <member name="T:LibLSLCC.Collections.EnumerableExtensions">
            <summary>
                <see cref="T:System.Collections.Generic.IEnumerable`1" /> extensions.
            </summary>
        </member>
        <member name="M:LibLSLCC.Collections.EnumerableExtensions.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
                Find the minimum object in an <see cref="T:System.Collections.Generic.IEnumerable`1" /> using a selection key.
            </summary>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> source.</param>
            <param name="selector">The key selector function.</param>
            <typeparam name="TSource">The type <see cref="T:System.Collections.Generic.IEnumerable`1" /> enumerates over.</typeparam>
            <typeparam name="TKey">The key type used in the MinBy comparison.</typeparam>
            <returns>The smallest element found.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.EnumerableExtensions.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
                Find the minimum object in an <see cref="T:System.Collections.Generic.IEnumerable`1" /> using a selection key.
            </summary>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> source.</param>
            <param name="selector">The key selector function.</param>
            <param name="comparer">The comparer used to compare keys.</param>
            <typeparam name="TSource">The type <see cref="T:System.Collections.Generic.IEnumerable`1" /> enumerates over.</typeparam>
            <typeparam name="TKey">The key type used in the MinBy comparison.</typeparam>
            <returns>The smallest element found.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.EnumerableExtensions.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
                Find the maximum object in an <see cref="T:System.Collections.Generic.IEnumerable`1" /> using a selection key.
            </summary>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> source.</param>
            <param name="selector">The key selector function.</param>
            <typeparam name="TSource">The type <see cref="T:System.Collections.Generic.IEnumerable`1" /> enumerates over.</typeparam>
            <typeparam name="TKey">The key type used in the MaxBy comparison.</typeparam>
            <returns>The largest element found.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.EnumerableExtensions.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
                Find the maximum object in an <see cref="T:System.Collections.Generic.IEnumerable`1" /> using a selection key.
            </summary>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> source.</param>
            <param name="selector">The key selector function.</param>
            <param name="comparer">The comparer used to compare keys.</param>
            <typeparam name="TSource">The type <see cref="T:System.Collections.Generic.IEnumerable`1" /> enumerates over.</typeparam>
            <typeparam name="TKey">The key type used in the MaxBy comparison.</typeparam>
            <returns>The largest element found.</returns>
        </member>
        <member name="T:LibLSLCC.Collections.GenericArray`1">
            <summary>
                Generic Array class, it is equivalent to <see cref="T:System.Collections.Generic.List`1" />.
            </summary>
            <remarks>
                This class supports a read only covariant interface in NET 4.0 via <see cref="T:LibLSLCC.Collections.IReadOnlyGenericArray`1" />.
            </remarks>
            <typeparam name="T">The type contained by the <see cref="T:LibLSLCC.Collections.GenericArray`1" /></typeparam>
        </member>
        <member name="M:LibLSLCC.Collections.GenericArray`1.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Collections.GenericArray`1" /> class.
            </summary>
        </member>
        <member name="M:LibLSLCC.Collections.GenericArray`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Collections.GenericArray`1" /> class by wrapping an <see cref="T:System.Collections.Generic.IList`1" />.
            </summary>
            <param name="list">The list.</param>
        </member>
        <member name="M:LibLSLCC.Collections.GenericArray`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Collections.GenericArray`1" /> class.
            </summary>
            <param name="list">The list.</param>
        </member>
        <member name="M:LibLSLCC.Collections.GenericArray`1.#ctor(System.Int32)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Collections.GenericArray`1" /> class.
            </summary>
            <param name="capacity">The capacity.</param>
        </member>
        <member name="P:LibLSLCC.Collections.GenericArray`1.Count">
            <summary>
                Gets the number of items in the array.
            </summary>
            <value>
                The number of items in the array.
            </value>
        </member>
        <member name="P:LibLSLCC.Collections.GenericArray`1.Item(System.Int32)">
            <summary>
                Get element at <paramref name="index" />
            </summary>
            <param name="index">The index to retrieve the element from.</param>
            <returns>The element at index.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.GenericArray`1.Clone">
            <summary>
                Returns a shallow copy of this array.
            </summary>
            <returns>A shallow copy of this array.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.GenericArray`1.Add(`0)">
            <summary>
                Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
            <exception cref="T:System.NotSupportedException">
                The <see cref="T:System.Collections.Generic.ICollection`1" /> is
                read-only.
            </exception>
        </member>
        <member name="M:LibLSLCC.Collections.GenericArray`1.Clear">
            <summary>
                Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
            <exception cref="T:System.NotSupportedException">
                The <see cref="T:System.Collections.Generic.ICollection`1" /> is
                read-only.
            </exception>
        </member>
        <member name="M:LibLSLCC.Collections.GenericArray`1.Contains(`0)">
            <summary>
                Determines whether the <see cref="T:System.Collections.Generic.ICollection`1" /> contains a specific value.
            </summary>
            <returns>
                true if <paramref name="item" /> is found in the <see cref="T:System.Collections.Generic.ICollection`1" />;
                otherwise, false.
            </returns>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
        </member>
        <member name="M:LibLSLCC.Collections.GenericArray`1.CopyTo(`0[],System.Int32)">
            <summary>
                Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1" /> to an
                <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
            <param name="array">
                The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied
                from <see cref="T:System.Collections.Generic.ICollection`1" />. The <see cref="T:System.Array" /> must have
                zero-based indexing.
            </param>
            <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> is less than 0.</exception>
            <exception cref="T:System.ArgumentException">
                The number of elements in the source
                <see cref="T:System.Collections.Generic.ICollection`1" /> is greater than the available space from
                <paramref name="arrayIndex" /> to the end of the destination <paramref name="array" />.
            </exception>
        </member>
        <member name="M:LibLSLCC.Collections.GenericArray`1.Remove(`0)">
            <summary>
                Removes the first occurrence of a specific object from the
                <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
            <returns>
                true if <paramref name="item" /> was successfully removed from the
                <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false. This method also returns false if
                <paramref name="item" /> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1" />.
            </returns>
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
            <exception cref="T:System.NotSupportedException">
                The <see cref="T:System.Collections.Generic.ICollection`1" /> is
                read-only.
            </exception>
        </member>
        <member name="P:LibLSLCC.Collections.GenericArray`1.IsReadOnly">
            <summary>
                Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.
            </summary>
            <returns>
                true if the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only; otherwise, false.
            </returns>
        </member>
        <member name="M:LibLSLCC.Collections.GenericArray`1.IndexOf(`0)">
            <summary>
                Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1" />.
            </summary>
            <returns>
                The index of <paramref name="item" /> if found in the list; otherwise, -1.
            </returns>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1" />.</param>
        </member>
        <member name="M:LibLSLCC.Collections.GenericArray`1.Insert(System.Int32,`0)">
            <summary>
                Inserts an item to the <see cref="T:System.Collections.Generic.IList`1" /> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
            <param name="item">The object to insert into the <see cref="T:System.Collections.Generic.IList`1" />.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="index" /> is not a valid index in the
                <see cref="T:System.Collections.Generic.IList`1" />.
            </exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1" /> is read-only.</exception>
        </member>
        <member name="M:LibLSLCC.Collections.GenericArray`1.RemoveAt(System.Int32)">
            <summary>
                Removes the <see cref="T:System.Collections.Generic.IList`1" /> item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="index" /> is not a valid index in the
                <see cref="T:System.Collections.Generic.IList`1" />.
            </exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1" /> is read-only.</exception>
        </member>
        <member name="M:LibLSLCC.Collections.GenericArray`1.GetEnumerator">
            <summary>
                Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
                A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:LibLSLCC.Collections.GenericArray`1.CreateWrapper(System.Collections.Generic.IList{`0})">
            <summary>
                Create a new instance of an <see cref="T:LibLSLCC.Collections.GenericArray`1" /> class by wrapping an <see cref="T:System.Collections.Generic.IList`1" />.
            </summary>
            <param name="list">The list.</param>
            <returns>A <see cref="T:LibLSLCC.Collections.GenericArray`1" /> wrapper around <paramref name="list"/>.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.GenericArray`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Adds a range of elements to the array from an <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            </summary>
            <param name="items">The items to add.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="items"/> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.Collections.GenericArrayExtensions">
            <summary>
                Extensions for The <seealso cref="T:LibLSLCC.Collections.GenericArray`1" /> collection.
            </summary>
        </member>
        <member name="M:LibLSLCC.Collections.GenericArrayExtensions.ToGenericArray``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                Converts an <see cref="T:System.Collections.Generic.IEnumerable`1" /> to a <seealso cref="T:LibLSLCC.Collections.GenericArray`1" /> object.
            </summary>
            <param name="enumerable">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> to convert.</param>
            <typeparam name="T">The type contained in the <see cref="T:System.Collections.Generic.IEnumerable`1" /> object.</typeparam>
            <returns>A <see cref="T:LibLSLCC.Collections.GenericArray`1" /> object filled with the contents of the given <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.GenericArrayExtensions.WrapWithGenericArray``1(System.Collections.Generic.IList{``0})">
            <summary>
                Converts an <see cref="T:System.Collections.Generic.IList`1" /> to a <seealso cref="T:LibLSLCC.Collections.GenericArray`1" /> object by wrapping it.
            </summary>
            <param name="list">The <see cref="T:System.Collections.Generic.IList`1" /> to convert.</param>
            <typeparam name="T">The type contained in the <see cref="T:System.Collections.Generic.IList`1" /> object.</typeparam>
            <returns>A <see cref="T:LibLSLCC.Collections.GenericArray`1" /> object filled with the contents of the given <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
        </member>
        <member name="T:LibLSLCC.Collections.HashMapExtensions">
            <summary>
                Extensions for <see cref="T:LibLSLCC.Collections.HashMap`2" /> objects.
            </summary>
        </member>
        <member name="M:LibLSLCC.Collections.HashMapExtensions.ToHashMap``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
                Converts an <see cref="T:System.Collections.Generic.IEnumerable`1" /> object into a <see cref="T:LibLSLCC.Collections.HashMap`2" />
            </summary>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> to convert.</param>
            <param name="keySelector">The key selector function.</param>
            <typeparam name="TSource"> </typeparam>
            <typeparam name="TKey"></typeparam>
            <returns>The generated <see cref="T:LibLSLCC.Collections.HashMap`2" /> object.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.HashMapExtensions.ToHashMap``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>
                Converts an <see cref="T:System.Collections.Generic.IEnumerable`1" /> object into a <see cref="T:LibLSLCC.Collections.HashMap`2" />
            </summary>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> to convert.</param>
            <param name="keySelector">The key selector function.</param>
            <param name="elementSelector">The element selector function.</param>
            <typeparam name="TSource"> </typeparam>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TElement"></typeparam>
            <returns>The generated <see cref="T:LibLSLCC.Collections.HashMap`2" /> object.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.HashMapExtensions.ToHashMap``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
                Converts an <see cref="T:System.Collections.Generic.IEnumerable`1" /> object into a <see cref="T:LibLSLCC.Collections.HashMap`2" />
            </summary>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> to convert.</param>
            <param name="keySelector">The key selector function.</param>
            <param name="comparer">The key comparer function.</param>
            <typeparam name="TSource"> </typeparam>
            <typeparam name="TKey"></typeparam>
            <returns>The generated <see cref="T:LibLSLCC.Collections.HashMap`2" /> object.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.HashMapExtensions.ToHashMap``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
                Converts an <see cref="T:System.Collections.Generic.IEnumerable`1" /> object into a <see cref="T:LibLSLCC.Collections.HashMap`2" />
            </summary>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> to convert.</param>
            <param name="keySelector">The key selector function.</param>
            <param name="elementSelector">The element selector function.</param>
            <param name="comparer">The key comparer function.</param>
            <typeparam name="TSource"> </typeparam>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TElement"></typeparam>
            <returns>The generated <see cref="T:LibLSLCC.Collections.HashMap`2" /> object.</returns>
        </member>
        <member name="T:LibLSLCC.Collections.IReadOnlyContainer`1">
            <summary>
                Interface for read only collections/containers.
            </summary>
            <remarks>
                This interface supports covariance.
            </remarks>
            <typeparam name="T">The type contained by the container.</typeparam>
        </member>
        <member name="P:LibLSLCC.Collections.IReadOnlyContainer`1.Count">
            <summary>
                Gets the number of elements contained in the container.
            </summary>
        </member>
        <member name="T:LibLSLCC.Collections.IReadOnlyGenericArray`1">
            <summary>
                Interface for read only Generic Arrays, used by <see cref="T:LibLSLCC.Collections.GenericArray`1" />.
            </summary>
            <remarks>
                This interface supports covariance.
            </remarks>
            <typeparam name="T">The type contained in the Generic Array.</typeparam>
        </member>
        <member name="P:LibLSLCC.Collections.IReadOnlyGenericArray`1.Count">
            <summary>
                Gets the number of items in the array.
            </summary>
            <value>
                The number of items in the array.
            </value>
        </member>
        <member name="P:LibLSLCC.Collections.IReadOnlyGenericArray`1.Item(System.Int32)">
            <summary>
                Gets the array element at the specified index.
            </summary>
            <value>
                The array element at the specified index.
            </value>
            <param name="index">The index to retrieve the array element from.</param>
            <returns>The array element at the specified index.</returns>
        </member>
        <member name="T:LibLSLCC.Collections.IReadOnlyHashMap`2">
            <summary>
                Read only HashMap interface, used by <see cref="T:LibLSLCC.Collections.HashMap`2" />
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="P:LibLSLCC.Collections.IReadOnlyHashMap`2.Item(`0)">
            <summary>
                Gets the value associated with the specified key.
            </summary>
            <value>
                The value associated with the given key.
            </value>
            <param name="key">The key.</param>
            <returns>The value associated with the specified key</returns>
        </member>
        <member name="P:LibLSLCC.Collections.IReadOnlyHashMap`2.Keys">
            <summary>
                Gets the keys this <see cref="T:LibLSLCC.Collections.HashMap`2" /> contains.
            </summary>
            <value>
                The keys.
            </value>
        </member>
        <member name="P:LibLSLCC.Collections.IReadOnlyHashMap`2.Values">
            <summary>
                Gets the values this <see cref="T:LibLSLCC.Collections.HashMap`2" /> contains.
            </summary>
            <value>
                The values.
            </value>
        </member>
        <member name="M:LibLSLCC.Collections.IReadOnlyHashMap`2.ContainsKey(`0)">
            <summary>
                Determines whether this <see cref="T:LibLSLCC.Collections.HashMap`2" /> contains the specified key.
            </summary>
            <param name="key">The key.</param>
            <returns><c>true</c> if this <see cref="T:LibLSLCC.Collections.HashMap`2" /> contains the specified <paramref name="key"/>; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.IReadOnlyHashMap`2.TryGetValue(`0,`1@)">
            <summary>
                Tries to put the value associated with a given key into the out <paramref name="value" /> parameter.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value output location.</param>
            <returns>True if the value was found and retrieved, false if it did not exist.</returns>
        </member>
        <member name="T:LibLSLCC.Collections.IReadOnlyHashedSet`1">
            <summary>
                Read only Hashed Set interface, used by <see cref="T:LibLSLCC.Collections.HashedSet`1" />.
            </summary>
            <typeparam name="T">The type the set is to contain.</typeparam>
        </member>
        <member name="P:LibLSLCC.Collections.IReadOnlyHashedSet`1.IsReadOnly">
            <summary>
                Determines if this ICollection is read only.
            </summary>
        </member>
        <member name="M:LibLSLCC.Collections.IReadOnlyHashedSet`1.GetEnumerator">
            <summary>
                Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
                An enumerator that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:LibLSLCC.Collections.IReadOnlyHashedSet`1.Contains(`0)">
            <summary>
                Determine if the set contains the given object.
            </summary>
            <param name="item">The item to look for.</param>
            <returns>True if the set contains the given item.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.IReadOnlyHashedSet`1.CopyTo(`0[],System.Int32)">
            <summary>
                Copies the elements of the <see cref="T:LibLSLCC.Collections.IReadOnlyHashedSet`1" /> to an array, starting at arrayIndex in the target
                array.
            </summary>
            <param name="array">The array to copy the items to.</param>
            <param name="arrayIndex">The array index to start at in the target array.</param>
        </member>
        <member name="M:LibLSLCC.Collections.IReadOnlyHashedSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Determines whether a set is a subset of a specified collection.
            </summary>
            <param name="other">The other collection.</param>
            <returns>True if this set is a subset of the other collection.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.IReadOnlyHashedSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Determines whether the current set is a superset of the specified collection.
            </summary>
            <param name="other">The other collection.</param>
            <returns>True if this set is a superset of the specified collection.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.IReadOnlyHashedSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Determines whether the current set is a proper (strict) superset of a specified collection.
            </summary>
            <param name="other">The other collection.</param>
            <returns>True if the current set is a proper (string) superset of a specified collection.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.IReadOnlyHashedSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Determines whether the current set is a proper (strict) subset of a specified collection.
            </summary>
            <param name="other">The other collection.</param>
            <returns>True if the current set is a proper (string) subset of a specified collection.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.IReadOnlyHashedSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Determines whether the current set overlaps with the specified collection.
            </summary>
            <param name="other">The other collection.</param>
            <returns>True if the current set overlaps with the specified collection.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.IReadOnlyHashedSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Determines whether the current set and the specified collection contain the same elements.
            </summary>
            <param name="other">The other collection.</param>
            <returns>True if the current set and the specified collection contain the same elements.</returns>
        </member>
        <member name="T:LibLSLCC.Collections.PriorityQueue`2">
            <summary>
                Priority queue based on binary heap,
                Elements with minimum priority dequeued first
            </summary>
            <typeparam name="TPriority">Type of priorities</typeparam>
            <typeparam name="TValue">Type of values</typeparam>
        </member>
        <member name="M:LibLSLCC.Collections.PriorityQueue`2.Clone">
            <summary>
                Create a shallow clone of this priority queue.
            </summary>
            <returns>A shallow clone of this priority queue.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.PriorityQueue`2.#ctor">
            <summary>
                Initializes a new instance of priority queue with default initial capacity and default priority comparer
            </summary>
        </member>
        <member name="M:LibLSLCC.Collections.PriorityQueue`2.#ctor(System.Int32)">
            <summary>
                Initializes a new instance of priority queue with specified initial capacity and default priority comparer
            </summary>
            <param name="capacity">initial capacity</param>
        </member>
        <member name="M:LibLSLCC.Collections.PriorityQueue`2.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
                Initializes a new instance of priority queue with specified initial capacity and specified priority comparer
            </summary>
            <param name="capacity">initial capacity</param>
            <param name="comparer">priority comparer</param>
        </member>
        <member name="M:LibLSLCC.Collections.PriorityQueue`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
                Initializes a new instance of priority queue with default initial capacity and specified priority comparer
            </summary>
            <param name="comparer">priority comparer</param>
        </member>
        <member name="M:LibLSLCC.Collections.PriorityQueue`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
                Initializes a new instance of priority queue with specified data and default priority comparer
            </summary>
            <param name="data">data to be inserted into priority queue</param>
        </member>
        <member name="M:LibLSLCC.Collections.PriorityQueue`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IComparer{`0})">
            <summary>
                Initializes a new instance of priority queue with specified data and specified priority comparer
            </summary>
            <param name="data">data to be inserted into priority queue</param>
            <param name="comparer">priority comparer</param>
        </member>
        <member name="M:LibLSLCC.Collections.PriorityQueue`2.MergeQueues(LibLSLCC.Collections.PriorityQueue{`0,`1},LibLSLCC.Collections.PriorityQueue{`0,`1})">
            <summary>
                Merges two priority queues
            </summary>
            <param name="pq1">first priority queue</param>
            <param name="pq2">second priority queue</param>
            <returns>resultant priority queue</returns>
            <remarks>
                source priority queues must have equal comparers,
                otherwise <see cref="T:System.InvalidOperationException" /> will be thrown
            </remarks>
        </member>
        <member name="M:LibLSLCC.Collections.PriorityQueue`2.MergeQueues(LibLSLCC.Collections.PriorityQueue{`0,`1},LibLSLCC.Collections.PriorityQueue{`0,`1},System.Collections.Generic.IComparer{`0})">
            <summary>
                Merges two priority queues and sets specified comparer for resultant priority queue
            </summary>
            <param name="pq1">first priority queue</param>
            <param name="pq2">second priority queue</param>
            <param name="comparer">comparer for resultant priority queue</param>
            <returns>resultant priority queue</returns>
        </member>
        <member name="P:LibLSLCC.Collections.PriorityQueue`2.IsEmpty">
            <summary>
                Gets whether priority queue is empty
            </summary>
        </member>
        <member name="M:LibLSLCC.Collections.PriorityQueue`2.Enqueue(`0,`1)">
            <summary>
                Enqueues element into priority queue
            </summary>
            <param name="priority">element priority</param>
            <param name="value">element value</param>
        </member>
        <member name="M:LibLSLCC.Collections.PriorityQueue`2.Dequeue">
            <summary>
                Dequeues element with minimum priority and return its priority and value as
                <see cref="T:System.Collections.Generic.KeyValuePair`2" />
            </summary>
            <returns>priority and value of the dequeued element</returns>
            <remarks>
                Method throws <see cref="T:System.InvalidOperationException" /> if priority queue is empty
            </remarks>
        </member>
        <member name="M:LibLSLCC.Collections.PriorityQueue`2.DequeueValue">
            <summary>
                Dequeues element with minimum priority and return its value
            </summary>
            <returns>value of the dequeued element</returns>
            <remarks>
                Method throws <see cref="T:System.InvalidOperationException" /> if priority queue is empty
            </remarks>
        </member>
        <member name="M:LibLSLCC.Collections.PriorityQueue`2.Peek">
            <summary>
                Returns priority and value of the element with minimum priority, without removing it from the queue
            </summary>
            <returns>priority and value of the element with minimum priority</returns>
            <remarks>
                Method throws <see cref="T:System.InvalidOperationException" /> if priority queue is empty
            </remarks>
        </member>
        <member name="M:LibLSLCC.Collections.PriorityQueue`2.PeekValue">
            <summary>
                Returns value of the element with minimum priority, without removing it from the queue
            </summary>
            <returns>value of the element with minimum priority</returns>
            <remarks>
                Method throws <see cref="T:System.InvalidOperationException" /> if priority queue is empty
            </remarks>
        </member>
        <member name="M:LibLSLCC.Collections.PriorityQueue`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
                Enqueues element into priority queue
            </summary>
            <param name="item">element to add</param>
        </member>
        <member name="M:LibLSLCC.Collections.PriorityQueue`2.Clear">
            <summary>
                Clears the collection
            </summary>
        </member>
        <member name="M:LibLSLCC.Collections.PriorityQueue`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
                Determines whether the priority queue contains a specific element
            </summary>
            <param name="item">The object to locate in the priority queue</param>
            <returns><c>true</c> if item is found in the priority queue; otherwise, <c>false.</c> </returns>
        </member>
        <member name="P:LibLSLCC.Collections.PriorityQueue`2.Count">
            <summary>
                Gets number of elements in the priority queue
            </summary>
        </member>
        <member name="M:LibLSLCC.Collections.PriorityQueue`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
                Copies the elements of the priority queue to an Array, starting at a particular Array index.
            </summary>
            <param name="array">
                The one-dimensional Array that is the destination of the elements copied from the priority queue.
                The Array must have zero-based indexing.
            </param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <remarks>
                It is not guaranteed that items will be copied in the sorted order.
            </remarks>
        </member>
        <member name="P:LibLSLCC.Collections.PriorityQueue`2.IsReadOnly">
            <summary>
                Gets a value indicating whether the collection is read-only.
            </summary>
            <remarks>
                For priority queue this property returns <c>false</c>.
            </remarks>
        </member>
        <member name="M:LibLSLCC.Collections.PriorityQueue`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
                Removes the first occurrence of a specific object from the priority queue.
            </summary>
            <param name="item">The object to remove from the ICollection </param>
            <returns>
                <c>true</c> if item was successfully removed from the priority queue.
                This method returns false if item is not found in the collection.
            </returns>
        </member>
        <member name="M:LibLSLCC.Collections.PriorityQueue`2.GetEnumerator">
            <summary>
                Returns an enumerator that iterates through the collection.
            </summary>
            <returns>Enumerator</returns>
            <remarks>
                Returned enumerator does not iterate elements in sorted order.
            </remarks>
        </member>
        <member name="M:LibLSLCC.Collections.PriorityQueue`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
                Returns an enumerator that iterates through the collection.
            </summary>
            <returns>Enumerator</returns>
            <remarks>
                Returned enumerator does not iterate elements in sorted order.
            </remarks>
        </member>
        <member name="T:LibLSLCC.Collections.HashMap`2">
            <summary>
                Generic HashMap class, it is equivalent to <see cref="T:System.Collections.Generic.Dictionary`2" />.
            </summary>
            <remarks>
                This class supports a read only interface in NET 4.0 via <see cref="T:LibLSLCC.Collections.IReadOnlyHashMap`2" />.
            </remarks>
            <typeparam name="TKey">The key type for the <see cref="T:LibLSLCC.Collections.HashMap`2" />.</typeparam>
            <typeparam name="TValue">The value type for the <see cref="T:LibLSLCC.Collections.HashMap`2" />.</typeparam>
        </member>
        <member name="M:LibLSLCC.Collections.HashMap`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Collections.HashMap`2" /> class by wrapping an
                <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </summary>
            <param name="items">The items.</param>
        </member>
        <member name="M:LibLSLCC.Collections.HashMap`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Collections.HashMap`2" /> class.
            </summary>
            <param name="items">The items.</param>
            <param name="comparer">The comparer.</param>
        </member>
        <member name="M:LibLSLCC.Collections.HashMap`2.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Collections.HashMap`2" /> class.
            </summary>
        </member>
        <member name="M:LibLSLCC.Collections.HashMap`2.#ctor(System.Int32)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Collections.HashMap`2" /> class.
            </summary>
            <param name="capacity">The capacity.</param>
        </member>
        <member name="M:LibLSLCC.Collections.HashMap`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Collections.HashMap`2" /> class.
            </summary>
            <param name="capacity">The capacity.</param>
            <param name="comparer">The comparer.</param>
        </member>
        <member name="M:LibLSLCC.Collections.HashMap`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Collections.HashMap`2" /> class.
            </summary>
            <param name="comparer">The comparer.</param>
        </member>
        <member name="M:LibLSLCC.Collections.HashMap`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Collections.HashMap`2" /> class.
            </summary>
            <param name="info">The information.</param>
            <param name="context">The context.</param>
        </member>
        <member name="M:LibLSLCC.Collections.HashMap`2.Clone">
            <summary>
                Create a shallow copy of this hash map.
            </summary>
            <returns>A shallow copy of this hash map.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.HashMap`2.OnDeserialization(System.Object)">
            <summary>
                Runs when the entire object graph has been deserialized.
            </summary>
            <param name="sender">
                The object that initiated the callback. The functionality for this parameter is not currently
                implemented.
            </param>
        </member>
        <member name="P:LibLSLCC.Collections.HashMap`2.IsReadOnly">
            <summary>
                Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.
            </summary>
            <returns>
                true if the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only; otherwise, false.
            </returns>
        </member>
        <member name="P:LibLSLCC.Collections.HashMap`2.Keys">
            <summary>
                Gets an <see cref="T:System.Collections.Generic.ICollection`1" /> containing the keys of the
                <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </summary>
            <returns>
                An <see cref="T:System.Collections.Generic.ICollection`1" /> containing the keys of the object that implements
                <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </returns>
        </member>
        <member name="P:LibLSLCC.Collections.HashMap`2.Values">
            <summary>
                Gets an <see cref="T:System.Collections.Generic.ICollection`1" /> containing the values in the
                <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </summary>
            <returns>
                An <see cref="T:System.Collections.Generic.ICollection`1" /> containing the values in the object that implements
                <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </returns>
        </member>
        <member name="M:LibLSLCC.Collections.HashMap`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
                Removes the first occurrence of a specific object from the
                <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
            <returns>
                true if <paramref name="item" /> was successfully removed from the
                <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false. This method also returns false if
                <paramref name="item" /> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1" />.
            </returns>
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
            <exception cref="T:System.NotSupportedException">
                The <see cref="T:System.Collections.Generic.ICollection`1" /> is
                read-only.
            </exception>
        </member>
        <member name="M:LibLSLCC.Collections.HashMap`2.Add(`0,`1)">
            <summary>
                Adds an element with the provided key and value to the <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </summary>
            <param name="key">The object to use as the key of the element to add.</param>
            <param name="value">The object to use as the value of the element to add.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">
                An element with the same key already exists in the
                <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </exception>
            <exception cref="T:System.NotSupportedException">
                The <see cref="T:System.Collections.Generic.IDictionary`2" /> is
                read-only.
            </exception>
        </member>
        <member name="M:LibLSLCC.Collections.HashMap`2.Remove(`0)">
            <summary>
                Removes the element with the specified key from the <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </summary>
            <returns>
                true if the element is successfully removed; otherwise, false.  This method also returns false if
                <paramref name="key" /> was not found in the original <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </returns>
            <param name="key">The key of the element to remove.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key" /> is <c>null</c>.</exception>
            <exception cref="T:System.NotSupportedException">
                The <see cref="T:System.Collections.Generic.IDictionary`2" /> is
                read-only.
            </exception>
        </member>
        <member name="M:LibLSLCC.Collections.HashMap`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
                Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
            <exception cref="T:System.NotSupportedException">
                The <see cref="T:System.Collections.Generic.ICollection`1" /> is
                read-only.
            </exception>
        </member>
        <member name="M:LibLSLCC.Collections.HashMap`2.Clear">
            <summary>
                Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
            <exception cref="T:System.NotSupportedException">
                The <see cref="T:System.Collections.Generic.ICollection`1" /> is
                read-only.
            </exception>
        </member>
        <member name="M:LibLSLCC.Collections.HashMap`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
                Determines whether the <see cref="T:System.Collections.Generic.ICollection`1" /> contains a specific value.
            </summary>
            <returns>
                true if <paramref name="item" /> is found in the <see cref="T:System.Collections.Generic.ICollection`1" />;
                otherwise, false.
            </returns>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
        </member>
        <member name="M:LibLSLCC.Collections.HashMap`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
                Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1" /> to an
                <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
            <param name="array">
                The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied
                from <see cref="T:System.Collections.Generic.ICollection`1" />. The <see cref="T:System.Array" /> must have
                zero-based indexing.
            </param>
            <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> is less than 0.</exception>
            <exception cref="T:System.ArgumentException">
                The number of elements in the source
                <see cref="T:System.Collections.Generic.ICollection`1" /> is greater than the available space from
                <paramref name="arrayIndex" /> to the end of the destination <paramref name="array" />.
            </exception>
        </member>
        <member name="M:LibLSLCC.Collections.HashMap`2.GetEnumerator">
            <summary>
                Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
                A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:LibLSLCC.Collections.HashMap`2.Count">
            <summary>
                Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
            <returns>
                The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </returns>
        </member>
        <member name="M:LibLSLCC.Collections.HashMap`2.ContainsKey(`0)">
            <summary>
                Determines whether the <see cref="T:System.Collections.Generic.IDictionary`2" /> contains an element with the
                specified key.
            </summary>
            <returns>
                true if the <see cref="T:System.Collections.Generic.IDictionary`2" /> contains an element with the key; otherwise,
                false.
            </returns>
            <param name="key">The key to locate in the <see cref="T:System.Collections.Generic.IDictionary`2" />.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.Collections.HashMap`2.TryGetValue(`0,`1@)">
            <summary>
                Gets the value associated with the specified key.
            </summary>
            <returns>
                true if the object that implements <see cref="T:System.Collections.Generic.IDictionary`2" /> contains an element
                with the specified key; otherwise, false.
            </returns>
            <param name="key">The key whose value to get.</param>
            <param name="value">
                When this method returns, the value associated with the specified key, if the key is found;
                otherwise, the default value for the type of the <paramref name="value" /> parameter. This parameter is passed
                uninitialized.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.Collections.HashMap`2.Item(`0)">
            <summary>
                Gets the value associated with the specified key.
            </summary>
            <value>
                The value associated with the given key.
            </value>
            <param name="key">The key.</param>
            <returns>The value associated with the specified key</returns>
        </member>
        <member name="M:LibLSLCC.Collections.HashMap`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with the data needed to serialize the
                target object.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> to populate with data. </param>
            <param name="context">
                The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext" />) for this
                serialization.
            </param>
            <exception cref="T:System.Security.SecurityException">The caller does not have the required permission. </exception>
        </member>
        <member name="M:LibLSLCC.Collections.HashMap`2.CreateWrapper(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
                Create a new instance of an <see cref="T:LibLSLCC.Collections.HashMap`2" /> class by wrapping an
                <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </summary>
            <param name="items">The items.</param>
            <returns>A <see cref="T:LibLSLCC.Collections.HashMap`2" /> wrapper around <paramref name="items"/>.</returns>
        </member>
        <member name="T:LibLSLCC.Collections.HashedSet`1">
            <summary>
                A hashed set collection meant to contain unique items.  It is equivalent to <see cref="T:System.Collections.Generic.HashSet`1" />
            </summary>
            <remarks>
                This collection supports a read only interface in NET 4.0 via <see cref="T:LibLSLCC.Collections.IReadOnlyHashedSet`1" />.
            </remarks>
            <typeparam name="T">The type of object(s) that the <see cref="T:System.Collections.Generic.HashSet`1" /> can contain.</typeparam>
        </member>
        <member name="M:LibLSLCC.Collections.HashedSet`1.#ctor(System.Collections.Generic.ISet{`0})">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Collections.HashedSet`1" /> classby wrapping an <see cref="T:System.Collections.Generic.ISet`1" />.
            </summary>
            <param name="items">The items.</param>
        </member>
        <member name="M:LibLSLCC.Collections.HashedSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Collections.HashedSet`1" /> class.
            </summary>
            <param name="items">The items.</param>
            <param name="comparer">The comparer.</param>
        </member>
        <member name="M:LibLSLCC.Collections.HashedSet`1.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Collections.HashedSet`1" /> class.
            </summary>
        </member>
        <member name="M:LibLSLCC.Collections.HashedSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Collections.HashedSet`1" /> class.
            </summary>
            <param name="comparer">The comparer.</param>
        </member>
        <member name="M:LibLSLCC.Collections.HashedSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Collections.HashedSet`1" /> class.
            </summary>
            <param name="items">The items.</param>
        </member>
        <member name="M:LibLSLCC.Collections.HashedSet`1.Clone">
            <summary>
                Returns a shallow copy of this hashed set.
            </summary>
            <returns>A shallow copy of this hashed set.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.HashedSet`1.GetEnumerator">
            <summary>
                Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
                An enumerator that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:LibLSLCC.Collections.HashedSet`1.Contains(`0)">
            <summary>
                Determine if the set contains the given object.
            </summary>
            <param name="item">The item to look for.</param>
            <returns>True if the set contains the given item.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.HashedSet`1.CopyTo(`0[],System.Int32)">
            <summary>
                Copies the elements of the <see cref="T:LibLSLCC.Collections.IReadOnlyHashedSet`1" /> to an array, starting at arrayIndex in the target
                array.
            </summary>
            <param name="array">The array to copy the items to.</param>
            <param name="arrayIndex">The array index to start at in the target array.</param>
        </member>
        <member name="P:LibLSLCC.Collections.HashedSet`1.Count">
            <summary>
                Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
            <returns>
                The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </returns>
        </member>
        <member name="P:LibLSLCC.Collections.HashedSet`1.IsReadOnly">
            <summary>
                Determines if this ICollection is read only.
            </summary>
        </member>
        <member name="M:LibLSLCC.Collections.HashedSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Determines whether a set is a subset of a specified collection.
            </summary>
            <param name="other">The other collection.</param>
            <returns>True if this set is a subset of the other collection.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.HashedSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Determines whether the current set is a superset of the specified collection.
            </summary>
            <param name="other">The other collection.</param>
            <returns>True if this set is a superset of the specified collection.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.HashedSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Determines whether the current set is a proper (strict) superset of a specified collection.
            </summary>
            <param name="other">The other collection.</param>
            <returns>True if the current set is a proper (string) superset of a specified collection.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.HashedSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Determines whether the current set is a proper (strict) subset of a specified collection.
            </summary>
            <param name="other">The other collection.</param>
            <returns>True if the current set is a proper (string) subset of a specified collection.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.HashedSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Determines whether the current set overlaps with the specified collection.
            </summary>
            <param name="other">The other collection.</param>
            <returns>True if the current set overlaps with the specified collection.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.HashedSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Determines whether the current set and the specified collection contain the same elements.
            </summary>
            <param name="other">The other collection.</param>
            <returns>True if the current set and the specified collection contain the same elements.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.HashedSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Modifies the current set so that it contains all elements that are present in both the current set and in the
                specified collection.
            </summary>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.Collections.HashedSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Modifies the current set so that it contains only elements that are also in a specified collection.
            </summary>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.Collections.HashedSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Removes all elements in the specified collection from the current set.
            </summary>
            <param name="other">The collection of items to remove from the set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.Collections.HashedSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Modifies the current set so that it contains only elements that are present either in the current set or in the
                specified collection, but not both.
            </summary>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.Collections.HashedSet`1.Clear">
            <summary>
                Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
            <exception cref="T:System.NotSupportedException">
                The <see cref="T:System.Collections.Generic.ICollection`1" /> is
                read-only.
            </exception>
        </member>
        <member name="M:LibLSLCC.Collections.HashedSet`1.Remove(`0)">
            <summary>
                Removes the first occurrence of a specific object from the
                <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
            <returns>
                true if <paramref name="item" /> was successfully removed from the
                <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false. This method also returns false if
                <paramref name="item" /> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1" />.
            </returns>
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
            <exception cref="T:System.NotSupportedException">
                The <see cref="T:System.Collections.Generic.ICollection`1" /> is
                read-only.
            </exception>
        </member>
        <member name="M:LibLSLCC.Collections.HashedSet`1.CreateWrapper(System.Collections.Generic.ISet{`0})">
            <summary>
                Create a new instance of an <see cref="T:LibLSLCC.Collections.HashedSet`1" /> class by wrapping an <see cref="T:System.Collections.Generic.ISet`1" />.
            </summary>
            <param name="items">The items.</param>
            <returns>A <see cref="T:LibLSLCC.Collections.HashedSet`1" /> wrapper around <paramref name="items"/>.</returns>
        </member>
        <member name="M:LibLSLCC.Collections.HashedSet`1.Add(`0)">
            <summary>
                Add and item to this hashed set.
            </summary>
            <param name="item">The item to add.</param>
            <returns><c>true</c> if the item was added, <c>false</c> if it already existed in the hashed set.</returns>
        </member>
        <member name="T:LibLSLCC.CSharp.ClassAccessibilityLevel">
            <summary>
                Represents the accessibility level of a CSharp class.
            </summary>
        </member>
        <member name="F:LibLSLCC.CSharp.ClassAccessibilityLevel.Default">
            <summary>
                default accessibility
            </summary>
        </member>
        <member name="F:LibLSLCC.CSharp.ClassAccessibilityLevel.Internal">
            <summary>
                internal accessibility
            </summary>
        </member>
        <member name="F:LibLSLCC.CSharp.ClassAccessibilityLevel.Public">
            <summary>
                public accessibility
            </summary>
        </member>
        <member name="T:LibLSLCC.CSharp.ClassAccessibilityLevelExtensions">
            <summary>
                Extension methods for <see cref="T:LibLSLCC.CSharp.ClassAccessibilityLevel" />.
            </summary>
        </member>
        <member name="M:LibLSLCC.CSharp.ClassAccessibilityLevelExtensions.ToCSharpKeyword(LibLSLCC.CSharp.ClassAccessibilityLevel,System.Boolean)">
            <summary>
                Converts <see cref="T:LibLSLCC.CSharp.ClassAccessibilityLevel" /> to its corresponding CSharp keyword.
            </summary>
            <param name="value">The <see cref="T:LibLSLCC.CSharp.ClassAccessibilityLevel" /> to convert.</param>
            <param name="addTrailingSpace">if set to <c>true</c>, add a trailing space to the converted string when its not empty.</param>
            <returns><paramref name="value"/>'s corresponding CSharp keyword.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
                If the given enum value is not convertible to a string (will not
                occur).
            </exception>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpFunctionCallValidationResult">
            <summary>
                Result object for <see cref="M:LibLSLCC.CSharp.CSharpFunctionCallValidator.Validate(System.String)" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpFunctionCallValidationResult.Success">
            <summary>
                <c>true</c> if the function call was succesfully parsed.
            </summary>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpFunctionCallValidationResult.ErrorDescription">
            <summary>
                An error description if <see cref="P:LibLSLCC.CSharp.CSharpFunctionCallValidationResult.Success" /> is <c>false</c>
            </summary>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpFunctionCallValidationResult.ErrorIndex">
            <summary>
                The index in the parsed string at which an error was detected if <see cref="P:LibLSLCC.CSharp.CSharpFunctionCallValidationResult.Success" /> is <c>false</c>.
            </summary>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpFunctionCallValidationResult.ExplicitGenericParameters">
            <summary>
                The explicit generic parameters specified if any.
            </summary>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpFunctionCallValidationResult.Parameters">
            <summary>
                The parsed function call parameters.
            </summary>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpFunctionCallValidationResult.MethodName">
            <summary>
                The parsed method name from the function call signature.
            </summary>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpParameterModifier">
            <summary>
                Represents the possible parameter modifiers of a CSharp function call.
            </summary>
        </member>
        <member name="F:LibLSLCC.CSharp.CSharpParameterModifier.None">
            <summary>
                no modifiers
            </summary>
        </member>
        <member name="F:LibLSLCC.CSharp.CSharpParameterModifier.Out">
            <summary>
                the out modifier.
            </summary>
        </member>
        <member name="F:LibLSLCC.CSharp.CSharpParameterModifier.Ref">
            <summary>
                the pass by reference modifier.
            </summary>
        </member>
        <member name="F:LibLSLCC.CSharp.CSharpParameterModifier.New">
            <summary>
                this means that the parameter passed was a brand new object, which was created directly in the parameter slot.
            </summary>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpParameterSignature">
            <summary>
                Represents the signature of a parameter passed to a CSharp function method call.
            </summary>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpParameterSignature.Modifier">
            <summary>
                The modifier that appears in front of the parameter
            </summary>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpParameterSignature.ParameterText">
            <summary>
                The text that represents the parsed parameter, after the modifier if one is present.
            </summary>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpParameterSignature.GetHashCode">
            <summary>
                Calculate a hash for the parameter signature using <see cref="P:LibLSLCC.CSharp.CSharpParameterSignature.ParameterText" /> and <see cref="P:LibLSLCC.CSharp.CSharpParameterSignature.Modifier" />
            </summary>
            <returns>The generated hash code.</returns>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpParameterSignature.Equals(System.Object)">
            <summary>
                Test equality using <see cref="P:LibLSLCC.CSharp.CSharpParameterSignature.ParameterText" /> and <see cref="P:LibLSLCC.CSharp.CSharpParameterSignature.Modifier" /> <para/>
                If <paramref name="obj"/> is not a <see cref="T:LibLSLCC.CSharp.CSharpParameterSignature"/> the result will be false.
            </summary>
            <param name="obj">The other <see cref="T:LibLSLCC.CSharp.CSharpParameterSignature"/> to test for equality with.</param>
            <returns><c>true</c> if <paramref name="obj"/> is an <see cref="T:LibLSLCC.CSharp.CSharpParameterSignature"/> that is equal to this object; otherwise <c>false</c>.</returns>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpFunctionCallValidator">
            <summary>
                Static class containing utilities for validating a CSharp method call signature.
            </summary>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpFunctionCallValidator.Validate(System.String)">
            <summary>
                Parses and validates a string as a CSharp method call.
            </summary>
            <param name="signature">The method call signature, without a semi-colon at the end.</param>
            <returns>A parse/validation results object.  <see cref="T:LibLSLCC.CSharp.CSharpFunctionCallValidationResult" /></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="signature"/> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpClassDeclarationName">
            <summary>
                Abstracts a CSharp class declaration name/name signature string, providing validation through parsing.
            </summary>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpClassDeclarationName.#ctor">
            <summary>
                Parameterless constructor used by <see cref="T:LibLSLCC.Settings.SettingsBaseClass`1" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpClassDeclarationName.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.CSharp.CSharpClassDeclarationName" /> class.
            </summary>
            <param name="fullSignature">The full signature.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="fullSignature" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">
                Thrown if <paramref name="fullSignature" /> is whitespace.
                or
                If <paramref name="fullSignature" /> does not pass validation using
                <see cref="M:LibLSLCC.CSharp.CSharpClassNameValidator.ValidateDeclaration(System.String)" />.
            </exception>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpClassDeclarationName.BaseName">
            <summary>
                Gets the BaseName of the parsed type, excluding generic arguments.  This is the last name in a qualified type name,
                if the type is qualified.
            </summary>
            <value>
                This is the last name in a qualified type name, if the type is qualified;  otherwise, simply the full given name.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpClassDeclarationName.QualifiedName">
            <summary>
                Gets the qualified name of the parsed type, excluding generic arguments.
            </summary>
            <value>
                The qualified name of the parsed type, excluding generic arguments.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpClassDeclarationName.ValidatedSignature">
            <summary>
                Gets the parsing/validation results of the class/type signature string.
            </summary>
            <value>
                The parsing/validation results of the class/type signature string.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpClassDeclarationName.FullSignature">
            <summary>
                Gets or sets the full class/type signature.  Parsing and validation is done when this property is set.
            </summary>
            <value>
                The full class/type signature.
            </value>
            <exception cref="T:System.ArgumentNullException">Thrown if you set a <c>null</c> value.</exception>
            <exception cref="T:System.ArgumentException">
                Thrown if you set a value that is whitespace.
                or
                If you set a value that does not pass validation using <see cref="M:LibLSLCC.CSharp.CSharpClassNameValidator.ValidateDeclaration(System.String)" />.
            </exception>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpClassDeclarationName.op_Implicit(System.String)~LibLSLCC.CSharp.CSharpClassDeclarationName">
            <summary>
                Implicitly converts a string into a <see cref="T:LibLSLCC.CSharp.CSharpClassDeclarationName" /> by parsing it.
            </summary>
            <param name="fullSignature">The string representing the full signature of the class declaration name.</param>
            <returns>The newly created <see cref="T:LibLSLCC.CSharp.CSharpClassDeclarationName" /> from the string.</returns>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpClassDeclarationName.ToString">
            <summary>
                Returns <see cref="P:LibLSLCC.CSharp.CSharpClassDeclarationName.FullSignature" />.
            </summary>
            <returns>
                <see cref="P:LibLSLCC.CSharp.CSharpClassDeclarationName.FullSignature" />.
            </returns>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpClassDeclarationName.GetHashCode">
            <summary>
                Returns the hash code of <see cref="P:LibLSLCC.CSharp.CSharpClassDeclarationName.FullSignature" />.
            </summary>
            <returns>
                Returns the hash code of <see cref="P:LibLSLCC.CSharp.CSharpClassDeclarationName.FullSignature" />.
            </returns>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpClassDeclarationName.Equals(System.Object)">
            <summary>
                Compares using <see cref="P:LibLSLCC.CSharp.CSharpClassDeclarationName.FullSignature" />.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
                <c>true</c> if the specified <see cref="T:System.Object" /> is a <see cref="T:LibLSLCC.CSharp.CSharpClassDeclarationName" /> with an
                equal <see cref="P:LibLSLCC.CSharp.CSharpClassDeclarationName.FullSignature" /> value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpConstructorSignature">
            <summary>
                Abstracts a CSharp constructor signature in the form: () | (Type param, ..) | (...) : base(...) | (...) : this(...)
                If an invalid CSharp constructor signature string is used to construct this object, an
                <see cref="T:System.ArgumentException" /> will be thrown.
            </summary>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpConstructorSignature.#ctor">
            <summary>
                Parameterless constructor used by <see cref="T:LibLSLCC.Settings.SettingsBaseClass`1" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpConstructorSignature.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.CSharp.CSharpConstructorSignature" /> class.
            </summary>
            <param name="fullSignature">The full signature.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="fullSignature" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">
                Thrown if <paramref name="fullSignature" /> is whitespace.
                or
                If <see cref="M:LibLSLCC.CSharp.CSharpConstructorSignatureValidator.Validate(System.String,LibLSLCC.CSharp.CSharpParsedTypeValidateTypeCallback)" /> returns an unsuccessful parse result.
            </exception>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpConstructorSignature.FullSignature">
            <summary>
                Gets or sets the full constructor signature.  Parsing and validation takes place when this property is set.
            </summary>
            <value>
                The full constructor signature.
            </value>
            <exception cref="T:System.ArgumentNullException">Thrown if the value is set to <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">
                Thrown if you set a value that is whitespace.
                or
                If <see cref="M:LibLSLCC.CSharp.CSharpConstructorSignatureValidator.Validate(System.String,LibLSLCC.CSharp.CSharpParsedTypeValidateTypeCallback)" /> returns an unsuccessful parse result when setting a
                value.
            </exception>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpConstructorSignature.ValidatedSignature">
            <summary>
                Gets the parsing/validation results of the constructor signature string.
            </summary>
            <value>
                The parsing/validation results of the constructor signature string.
            </value>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpConstructorSignature.op_Implicit(System.String)~LibLSLCC.CSharp.CSharpConstructorSignature">
            <summary>
                Implicitly converts a string into a <see cref="T:LibLSLCC.CSharp.CSharpConstructorSignature" /> by parsing it.
            </summary>
            <param name="fullSignature">The string representing the full constructor signature.</param>
            <returns>The newly created <see cref="T:LibLSLCC.CSharp.CSharpConstructorSignature" /> from the string.</returns>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpConstructorSignature.ToString">
            <summary>
                Returns <see cref="P:LibLSLCC.CSharp.CSharpConstructorSignature.FullSignature" />.
            </summary>
            <returns>
                <see cref="P:LibLSLCC.CSharp.CSharpConstructorSignature.FullSignature" />.
            </returns>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpConstructorSignature.GetHashCode">
            <summary>
                Returns the hash code of <see cref="P:LibLSLCC.CSharp.CSharpConstructorSignature.FullSignature" />.
            </summary>
            <returns>
                Returns the hash code of <see cref="P:LibLSLCC.CSharp.CSharpConstructorSignature.FullSignature" />.
            </returns>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpConstructorSignature.Equals(System.Object)">
            <summary>
                Compares using <see cref="P:LibLSLCC.CSharp.CSharpConstructorSignature.FullSignature" />.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
                <c>true</c> if the specified <see cref="T:System.Object" /> is a <see cref="T:LibLSLCC.CSharp.CSharpConstructorSignature" /> with an
                equal <see cref="P:LibLSLCC.CSharp.CSharpConstructorSignature.FullSignature" /> value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpConstructorParameterForwarding">
            <summary>
                Represents the ways parameters can be forwarded in a CSharp constructor.
            </summary>
        </member>
        <member name="F:LibLSLCC.CSharp.CSharpConstructorParameterForwarding.None">
            <summary>
                No parameter forwarding.
            </summary>
        </member>
        <member name="F:LibLSLCC.CSharp.CSharpConstructorParameterForwarding.Base">
            <summary>
                Parameters are forwarded to the base class.
            </summary>
        </member>
        <member name="F:LibLSLCC.CSharp.CSharpConstructorParameterForwarding.This">
            <summary>
                Parameters are forwarded to another constructor in 'this' object.
            </summary>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpConstructorSignatureValidationResult">
            <summary>
                Constructor signature parsing results returned by <see cref="M:LibLSLCC.CSharp.CSharpConstructorSignatureValidator.Validate(System.String,LibLSLCC.CSharp.CSharpParsedTypeValidateTypeCallback)" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpConstructorSignatureValidationResult.Success">
            <summary>
                Gets a value indicating whether the constructor signature parse was successful.
            </summary>
            <value>
                <c>true</c> if success; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpConstructorSignatureValidationResult.ErrorDescription">
            <summary>
                Will contain a syntax error description if <see cref="P:LibLSLCC.CSharp.CSharpConstructorSignatureValidationResult.Success" /> is <c>false</c>
            </summary>
            <value>
                The error description.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpConstructorSignatureValidationResult.ErrorIndex">
            <summary>
                Gets the index at which a syntax error was detected when <see cref="P:LibLSLCC.CSharp.CSharpConstructorSignatureValidationResult.Success" /> is <c>false</c>
            </summary>
            <value>
                The index of the syntax error.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpConstructorSignatureValidationResult.ParameterTypes">
            <summary>
                Gets the class name validation/parsing results for each parameter type.
            </summary>
            <value>
                The parsing results for each parameter type.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpConstructorSignatureValidationResult.ParameterNames">
            <summary>
                Gets the parameter names.
            </summary>
            <value>
                The parameter names.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpConstructorSignatureValidationResult.ParameterForwarding">
            <summary>
                Gets the parameter forwarding type, if any.  IE, what the constructor signature forwarded its parameter's to (base,
                this or none)
            </summary>
            <value>
                The parameter forwarding type.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpConstructorSignatureValidationResult.ForwardedParameters">
            <summary>
                Gets the names of any forwarded parameters.
            </summary>
            <value>
                The forwarded parameter names.
            </value>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpConstructorSignatureValidator">
            <summary>
                Static functions for parsing basic CSharp constructor signatures from strings.
            </summary>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpConstructorSignatureValidator.Validate(System.String,LibLSLCC.CSharp.CSharpParsedTypeValidateTypeCallback)">
            <summary>
                Validates the specified constructor signature string.
                It expects a constructor signature string which starts at the first parenthesis after the constructor's name
                identifier.
            </summary>
            <param name="input">The constructor signature string.</param>
            <param name="validateTypeCallback">
                The validate type callback, used for additional custom validation of parameter types
                in the constructor signature.
            </param>
            <returns>A parse/validation results object.  <see cref="T:LibLSLCC.CSharp.CSharpConstructorSignatureValidationResult" /></returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="input" /> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpFunctionCall">
            <summary>
                Abstraction that provides parsing and validation for CSharp inheritance list strings.
            </summary>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpFunctionCall.#ctor">
            <summary>
                Parameterless constructor used by <see cref="T:LibLSLCC.Settings.SettingsBaseClass`1" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpFunctionCall.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.CSharp.CSharpFunctionCall" /> class by parsing a function call from
                <paramref name="callString" />
            </summary>
            <param name="callString">The full call signature to parse.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="callString" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">
                Thrown if <see cref="M:LibLSLCC.CSharp.CSharpFunctionCallValidator.Validate(System.String)" /> fails to
                successfully parse <paramref name="callString" />.
            </exception>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpFunctionCall.FullSignature">
            <summary>
                Gets or sets the full signature of the function call.  Parsing and validation occurs when this property is set.
            </summary>
            <value>
                The full function call signature.
            </value>
            <exception cref="T:System.ArgumentNullException">Thrown if the value is set to <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">
                Thrown if <see cref="M:LibLSLCC.CSharp.CSharpFunctionCallValidator.Validate(System.String)" /> fails to
                successfully parse a value set to this property.
            </exception>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpFunctionCall.ValidatedSignature">
            <summary>
                Gets the parsing/validation results of the function call string.
            </summary>
            <value>
                The parsing/validation results of the function call string.
            </value>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpFunctionCall.op_Implicit(System.String)~LibLSLCC.CSharp.CSharpFunctionCall">
            <summary>
                Implicitly converts a string into a <see cref="T:LibLSLCC.CSharp.CSharpFunctionCall" /> by parsing it.
            </summary>
            <param name="fullSignature">The string representing the full signature of the function call.</param>
            <returns>The newly created <see cref="T:LibLSLCC.CSharp.CSharpFunctionCall" /> from the string.</returns>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpFunctionCall.ToString">
            <summary>
                Returns <see cref="P:LibLSLCC.CSharp.CSharpFunctionCall.FullSignature" />.
            </summary>
            <returns>
                <see cref="P:LibLSLCC.CSharp.CSharpFunctionCall.FullSignature" />.
            </returns>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpFunctionCall.GetHashCode">
            <summary>
                Returns the hash code of <see cref="P:LibLSLCC.CSharp.CSharpFunctionCall.FullSignature" />.
            </summary>
            <returns>
                Returns the hash code of <see cref="P:LibLSLCC.CSharp.CSharpFunctionCall.FullSignature" />.
            </returns>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpFunctionCall.Equals(System.Object)">
            <summary>
                Compares using <see cref="P:LibLSLCC.CSharp.CSharpFunctionCall.FullSignature" />.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
                <c>true</c> if the specified <see cref="T:System.Object" /> is a <see cref="T:LibLSLCC.CSharp.CSharpFunctionCall" /> with an equal
                <see cref="P:LibLSLCC.CSharp.CSharpFunctionCall.FullSignature" /> value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpIDValidator">
            <summary>
                Tools for validating the syntactic correctness of CSharp ID tokens.
            </summary>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpIDValidator.IsStartingCharacter(System.Char)">
            <summary>
            Returns <c>true</c> if <paramref name="c"/> is a character that is valid at the begining of a CSharp ID token.
            </summary>
            <param name="c">the character to test.</param>
            <returns><c>true</c> if <paramref name="c"/> is a character that is valid at the begining of a CSharp ID token.</returns>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpIDValidator.IsTrailingCharacter(System.Char)">
            <summary>
            Returns <c>true</c> if <paramref name="c"/> is a character that is valid after the first character of a CSharp ID token.
            </summary>
            <param name="c">the character to test.</param>
            <returns><c>true</c> if <paramref name="c"/> is a character that is valid after the first character of a CSharp ID token.</returns>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpIDValidator.IsValidIdentifier(System.String)">
            <summary>
            Returns <c>true</c> if <c>str</c> represents a valid (non keyword) CSharp ID token.
            </summary>
            <param name="str">the string to test.</param>
            <returns><c>true</c> if <c>str</c> represents a valid (non keyword) CSharp ID token.</returns>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpInheritanceList">
            <summary>
                Abstraction that provides parsing and validation for CSharp inheritance list strings.
            </summary>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpInheritanceList.#ctor">
            <summary>
                Parameterless constructor used by <see cref="T:LibLSLCC.Settings.SettingsBaseClass`1" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpInheritanceList.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.CSharp.CSharpInheritanceList" /> class by parsing a class inheritance list
                from <paramref name="fullSignature" />
            </summary>
            <param name="fullSignature">The full signature.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="fullSignature" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">
                Thrown if <see cref="M:LibLSLCC.CSharp.CSharpInheritanceListValidator.Validate(System.String)" /> fails to
                successfully parse <paramref name="fullSignature" />.
            </exception>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpInheritanceList.FullSignature">
            <summary>
                Gets or sets the full signature of the inheritance list.  Parsing and validation occurs when this property is set.
            </summary>
            <value>
                The full inheritance list signature.
            </value>
            <exception cref="T:System.ArgumentNullException">Thrown if the value is set to <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">
                Thrown if <see cref="M:LibLSLCC.CSharp.CSharpInheritanceListValidator.Validate(System.String)" /> fails to
                successfully parse a value set to this property.
            </exception>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpInheritanceList.ValidatedSignature">
            <summary>
                Gets the parsing/validation results of the class/type signature string.
            </summary>
            <value>
                The parsing/validation results of the class/type signature string.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpInheritanceList.ListWithColonIfNecessary">
            <summary>
                Gets a formated version of the inheritance list with an added colon character at the front if one is necessary.
            </summary>
            <value>
                The formated inheritance list with and added colon prefix if necessary.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpInheritanceList.IsEmpty">
            <summary>
                Is true if the inheritance list is completely empty, IE.. there are no inherited classes or type constraints.
            </summary>
            <value>
                <c>true</c> if the inheritance list is empty; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpInheritanceList.op_Implicit(System.String)~LibLSLCC.CSharp.CSharpInheritanceList">
            <summary>
                Implicitly converts a string into a <see cref="T:LibLSLCC.CSharp.CSharpInheritanceList" /> by parsing it.
            </summary>
            <param name="fullSignature">The string representing the full inheritance list.</param>
            <returns>The newly created <see cref="T:LibLSLCC.CSharp.CSharpInheritanceList" /> from the string.</returns>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpInheritanceList.ToString">
            <summary>
                Returns <see cref="P:LibLSLCC.CSharp.CSharpInheritanceList.FullSignature" />.
            </summary>
            <returns>
                <see cref="P:LibLSLCC.CSharp.CSharpInheritanceList.FullSignature" />.
            </returns>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpInheritanceList.GetHashCode">
            <summary>
                Returns the hash code of <see cref="P:LibLSLCC.CSharp.CSharpInheritanceList.FullSignature" />.
            </summary>
            <returns>
                Returns the hash code of <see cref="P:LibLSLCC.CSharp.CSharpInheritanceList.FullSignature" />.
            </returns>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpInheritanceList.Equals(System.Object)">
            <summary>
                Compares using <see cref="P:LibLSLCC.CSharp.CSharpInheritanceList.FullSignature" />.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
                <c>true</c> if the specified <see cref="T:System.Object" /> is a <see cref="T:LibLSLCC.CSharp.CSharpInheritanceList" /> with an equal
                <see cref="P:LibLSLCC.CSharp.CSharpInheritanceList.FullSignature" /> value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpInheritanceListValidationResult">
            <summary>
                Parse/validation result returned by <see cref="M:LibLSLCC.CSharp.CSharpInheritanceListValidator.Validate(System.String)" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpInheritanceListValidationResult.Success">
            <summary>
                Gets a value indicating whether the inheritance list signature parse was successful.
            </summary>
            <value>
                <c>true</c> if success; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpInheritanceListValidationResult.ErrorDescription">
            <summary>
                Will contain a syntax error description if <see cref="P:LibLSLCC.CSharp.CSharpInheritanceListValidationResult.Success" /> is <c>false</c>
            </summary>
            <value>
                The error description.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpInheritanceListValidationResult.ErrorIndex">
            <summary>
                Gets the index at which a syntax error was detected when <see cref="P:LibLSLCC.CSharp.CSharpInheritanceListValidationResult.Success" /> is <c>false</c>
            </summary>
            <value>
                The index of the syntax error.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpInheritanceListValidationResult.InheritedTypes">
            <summary>
                Gets the parsing results inherited types in the inheritance list.
            </summary>
            <value>
                The parsing results for the inherited types in the inheritance list.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpInheritanceListValidationResult.ConstrainedTypeParameters">
            <summary>
                Gets a list of constrained parameter names that were given constraints with the 'where' keyword.
            </summary>
            <value>
                The constrained type parameter names.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpInheritanceListValidationResult.ParameterConstraints">
            <summary>
                Gets a multi-dimensional array of parameter constraint descriptions that directly
                correspond to the names in <see cref="P:LibLSLCC.CSharp.CSharpInheritanceListValidationResult.ConstrainedTypeParameters" />.
                All type constraints applied to <see cref="P:LibLSLCC.CSharp.CSharpInheritanceListValidationResult.ConstrainedTypeParameters" />[i] can be found using
                <see cref="P:LibLSLCC.CSharp.CSharpInheritanceListValidationResult.ParameterConstraints" />[i].
            </summary>
            <value>
                The parameter constraints associated with the generic parameter names in <see cref="P:LibLSLCC.CSharp.CSharpInheritanceListValidationResult.ConstrainedTypeParameters" />.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpInheritanceListValidationResult.Fullsignature">
            <summary>
                Gets the full formated signature of the parsed inheritance list.
            </summary>
            <value>
                The full formated signature of the parsed inheritance list.
            </value>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpTypeConstraintType">
            <summary>
                Represents an inheritance list generic type constraint.
            </summary>
        </member>
        <member name="F:LibLSLCC.CSharp.CSharpTypeConstraintType.New">
            <summary>
                Generic type is constrained with 'new()'
            </summary>
        </member>
        <member name="F:LibLSLCC.CSharp.CSharpTypeConstraintType.Struct">
            <summary>
                Generic type is constrained with 'struct'
            </summary>
        </member>
        <member name="F:LibLSLCC.CSharp.CSharpTypeConstraintType.Class">
            <summary>
                Generic type is constrained with 'class'
            </summary>
        </member>
        <member name="F:LibLSLCC.CSharp.CSharpTypeConstraintType.Type">
            <summary>
                Generic type is constrained with an interface or class type.
            </summary>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpTypeConstraintValidationResult">
            <summary>
                Represents a parsed type constraint in an inheritance list signature.
            </summary>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpTypeConstraintValidationResult.ConstraintType">
            <summary>
                The type of generic constraint used.
            </summary>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpTypeConstraintValidationResult.TypeSignature">
            <summary>
                The type signature used in the constraint, if <see cref="P:LibLSLCC.CSharp.CSharpTypeConstraintValidationResult.ConstraintType" /> is
                <see cref="F:LibLSLCC.CSharp.CSharpTypeConstraintType.Type" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpTypeConstraintValidationResult.ConstraintString">
            <summary>
                Gets the string representation of the type constraint.
            </summary>
            <remarks>
                When the type constraint is an interface or class name, the full formated signature of the parsed interface/class
                name is returned.
            </remarks>
            <value>
                The type constraint string.
            </value>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpTypeConstraintValidationResult.Equals(System.Object)">
            <summary>
                Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
                The given object must firstly be a <see cref="T:LibLSLCC.CSharp.CSharpTypeConstraintValidationResult" /> in order to be considered
                equal at all.
                <see cref="P:LibLSLCC.CSharp.CSharpTypeConstraintValidationResult.ConstraintType" /> and <see cref="P:LibLSLCC.CSharp.CSharpTypeConstraintValidationResult.TypeSignature" /> must be equal in order for this to return true.
            </summary>
            <param name="obj">
                The <see cref="T:System.Object" /> (<see cref="T:LibLSLCC.CSharp.CSharpTypeConstraintValidationResult" />) to compare
                with this instance.
            </param>
            <returns>
                <c>true</c> if the specified <see cref="T:System.Object" /> (<see cref="T:LibLSLCC.CSharp.CSharpTypeConstraintValidationResult" />) is
                equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpTypeConstraintValidationResult.GetHashCode">
            <summary>
                Returns a hash code for this instance, based off <see cref="P:LibLSLCC.CSharp.CSharpTypeConstraintValidationResult.ConstraintType" /> and <see cref="P:LibLSLCC.CSharp.CSharpTypeConstraintValidationResult.TypeSignature" /> if
                it is not null.
            </summary>
            <returns>
                A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
            </returns>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpTypeConstraintValidationResult.ToString">
            <summary>
                Returns <see cref="P:LibLSLCC.CSharp.CSharpTypeConstraintValidationResult.ConstraintString" />.
            </summary>
            <returns>
                <see cref="P:LibLSLCC.CSharp.CSharpTypeConstraintValidationResult.ConstraintString" />.
            </returns>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpInheritanceListValidator">
            <summary>
                Static class containing utilities for validating a CSharp inheritance list string.
            </summary>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpInheritanceListValidator.Validate(System.String)">
            <summary>
                Validates/parses the specified CSharp inheritance list given in <paramref name="input" />.
                The parser supports 'where' type constraints on generic parameters.
                The signature given should be the source content immediately after a classes declared name, without the separating
                colon if there is one.
            </summary>
            <param name="input">The inheritance list signature to parse.</param>
            <returns>A parse/validation results object.  <see cref="T:LibLSLCC.CSharp.CSharpInheritanceListValidationResult" /></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="input"/> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpKeywords">
            <summary>
                Static class with utilities for identifying and dealing with CSharp keywords
            </summary>
        </member>
        <member name="F:LibLSLCC.CSharp.CSharpKeywords.BuiltInTypeMap">
            <summary>
                A map of built in type names to their corresponding <see cref="T:System.Type" />.
            </summary>
        </member>
        <member name="F:LibLSLCC.CSharp.CSharpKeywords.NonContextualKeywordSet">
            <summary>
                A hashed set of non contextual CSharp keywords/reserved words.
            </summary>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpKeywords.KeywordTypetoType(System.String)">
            <summary>
                Converts a CSharp type alias such as 'int', 'float' or object (etc..) to its corresponding <see cref="T:System.Type" />.
            </summary>
            <param name="keywordTypeName">The keyword type alias to convert to an actual <see cref="T:System.Type" />.</param>
            <returns>The type if there is a corresponding <see cref="T:System.Type" />, otherwise <c>null</c>.</returns>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpKeywords.IsTypeAliasKeyword(System.String)">
            <summary>
                Determines if a string is a built in type alias reference such as int.
            </summary>
            <param name="str">The string.</param>
            <returns><c>true</c> if the given string contains a built in type alias name; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpKeywords.IsNonContextualKeyword(System.String)">
            <summary>
                Determines whether a string is a non contextual CSharp keyword/reserved word.
            </summary>
            <param name="str">The string.</param>
            <returns><c>true</c> if <paramref name="str"/> is a non contextual CSharp keyword.</returns>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpNamespace">
            <summary>
                Abstraction that provides parsing and validation for CSharp namespace strings.
            </summary>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpNamespace.#ctor">
            <summary>
                Parameterless constructor used by <see cref="T:LibLSLCC.Settings.SettingsBaseClass`1" />
            </summary>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpNamespace.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.CSharp.CSharpNamespace" /> class by parsing a namespace string.
            </summary>
            <param name="name">The namespace string to parse.</param>
            <exception cref="T:System.ArgumentException">
                Thrown if <paramref name="name" /> is <c>null</c>.
                or
                If <paramref name="name" /> does not pass validation by <see cref="M:LibLSLCC.CSharp.CSharpNamespaceNameValidator.Validate(System.String)" />.
            </exception>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpNamespace.FullSignature">
            <summary>
                Gets or sets the full signature of the namespace.
            </summary>
            <value>
                The full namespace signature.
            </value>
            <exception cref="T:System.ArgumentException">
                Thrown if the value is set to <c>null</c>.
                or
                If the set value does not pass validation by <see cref="M:LibLSLCC.CSharp.CSharpNamespaceNameValidator.Validate(System.String)" />.
            </exception>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpNamespace.op_Implicit(System.String)~LibLSLCC.CSharp.CSharpNamespace">
            <summary>
                Implicitly converts a string into a CSharpNamespace.
            </summary>
            <param name="name">The name string to convert from.</param>
            <returns>A new <see cref="T:LibLSLCC.CSharp.CSharpNamespace"/> implicitly converted from a string.</returns>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpNamespace.GetHashCode">
            <summary>
                Returns the hash code of <see cref="P:LibLSLCC.CSharp.CSharpNamespace.FullSignature" />.
            </summary>
            <returns>
                Returns the hash code of <see cref="P:LibLSLCC.CSharp.CSharpNamespace.FullSignature" />.
            </returns>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpNamespace.Equals(System.Object)">
            <summary>
                Compares using <see cref="P:LibLSLCC.CSharp.CSharpNamespace.FullSignature" />.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
                <c>true</c> if the specified <see cref="T:System.Object" /> is a <see cref="T:LibLSLCC.CSharp.CSharpNamespace" /> with an equal
                <see cref="P:LibLSLCC.CSharp.CSharpNamespace.FullSignature" /> value; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpNamespace.ToString">
            <summary>
                Returns <see cref="P:LibLSLCC.CSharp.CSharpNamespace.FullSignature" />.
            </summary>
            <returns>
                <see cref="P:LibLSLCC.CSharp.CSharpNamespace.FullSignature" />.
            </returns>
        </member>
        <member name="T:LibLSLCC.CSharp.MemberAccessibilityLevel">
            <summary>
                Represents the accessibility level of a CSharp class member.
            </summary>
        </member>
        <member name="F:LibLSLCC.CSharp.MemberAccessibilityLevel.Public">
            <summary>
                public accessibility
            </summary>
        </member>
        <member name="F:LibLSLCC.CSharp.MemberAccessibilityLevel.Default">
            <summary>
                default accessibility
            </summary>
        </member>
        <member name="F:LibLSLCC.CSharp.MemberAccessibilityLevel.Private">
            <summary>
                private accessibility
            </summary>
        </member>
        <member name="F:LibLSLCC.CSharp.MemberAccessibilityLevel.Internal">
            <summary>
                internal accessibility
            </summary>
        </member>
        <member name="F:LibLSLCC.CSharp.MemberAccessibilityLevel.Protected">
            <summary>
                protected accessibility
            </summary>
        </member>
        <member name="F:LibLSLCC.CSharp.MemberAccessibilityLevel.ProtectedInternal">
            <summary>
                protected internal accessibility
            </summary>
        </member>
        <member name="T:LibLSLCC.CSharp.MemberAccessibilityLevelExtensions">
            <summary>
                Extension methods for <see cref="T:LibLSLCC.CSharp.MemberAccessibilityLevel" />.
            </summary>
        </member>
        <member name="M:LibLSLCC.CSharp.MemberAccessibilityLevelExtensions.ToCSharpKeyword(LibLSLCC.CSharp.MemberAccessibilityLevel,System.Boolean)">
            <summary>
                Converts <see cref="T:LibLSLCC.CSharp.MemberAccessibilityLevel" /> to its corresponding CSharp keyword.
            </summary>
            <param name="value">The <see cref="T:LibLSLCC.CSharp.MemberAccessibilityLevel" /> to convert.</param>
            <param name="addTrailingSpace">if set to <c>true</c>, add a trailing space to the converted string when its not empty.</param>
            <returns><paramref name="value"/>'s corresponding CSharp keyword.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
                If the given enum value is not convertible to a string (will not
                occur).
            </exception>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpParsedTypeValidationResult">
            <summary>
                Returned by <see cref="T:LibLSLCC.CSharp.CSharpParsedTypeValidateTypeCallback" />, a delegate which
                allows the user to preform additional validation on a parsed class name.
            </summary>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpParsedTypeValidationResult.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.CSharp.CSharpParsedTypeValidationResult" /> class with <see cref="P:LibLSLCC.CSharp.CSharpParsedTypeValidationResult.IsValid" />
                set to <c>true</c>.
            </summary>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpParsedTypeValidationResult.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.CSharp.CSharpParsedTypeValidationResult" /> class with <see cref="P:LibLSLCC.CSharp.CSharpParsedTypeValidationResult.IsValid" />
                set to <c>false</c>.
            </summary>
            <param name="errorMessage">The user provided error message to set <see cref="P:LibLSLCC.CSharp.CSharpParsedTypeValidationResult.ErrorMessage" /> with.</param>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpParsedTypeValidationResult.IsValid">
            <summary>
                Gets a value indicating whether additional user validation was successful.
            </summary>
            <value>
                <c>true</c> if the additional user validation succeeded; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpParsedTypeValidationResult.ErrorMessage">
            <summary>
                Gets the error message provided by the user if their extra validation failed.
            </summary>
            <value>
                The user provided error message.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpParsedTypeValidationResult.Tag">
            <summary>
                Gets or sets the tag, this can be anything the user wants it to be.
            </summary>
            <value>
                The object tag.
            </value>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpParsedTypeValidateTypeCallback">
            <summary>
                A delegate for injecting additional user validation into the class name parser.
            </summary>
            <param name="parsedTypeDescription">
                The <see cref="T:LibLSLCC.CSharp.CSharpParsedTypeValidationResult" /> which represents the results of the user validation callback
                for the parsed type.
            </param>
            <returns></returns>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpClassNameValidationResult">
            <summary>
                Class name validation result's produced by <see cref="M:LibLSLCC.CSharp.CSharpClassNameValidator.ValidateDeclaration(System.String)" />
                and <see cref="M:LibLSLCC.CSharp.CSharpClassNameValidator.ValidateInitialization(System.String,System.Boolean,LibLSLCC.CSharp.CSharpParsedTypeValidateTypeCallback)" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpClassNameValidationResult.Success">
            <summary>
                Gets a value indicating whether the given string passed to
                <see cref="M:LibLSLCC.CSharp.CSharpClassNameValidator.ValidateDeclaration(System.String)" />
                or <see cref="M:LibLSLCC.CSharp.CSharpClassNameValidator.ValidateInitialization(System.String,System.Boolean,LibLSLCC.CSharp.CSharpParsedTypeValidateTypeCallback)" /> was syntactically valid.
            </summary>
            <value>
                <c>true</c> if parsing success; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpClassNameValidationResult.BaseName">
            <summary>
                Gets the basic class name of the parsed type reference, without any namespace qualification.
                This does not include the generic arguments in the type reference, if there are any.
            </summary>
            <value>
                The base name of the class in the type reference.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpClassNameValidationResult.QualifiedName">
            <summary>
                Gets the fully qualified name of the parsed type reference, with any namespace qualification that was included in
                the string.
                This does not include the generic arguments in the type reference, if there are any.
            </summary>
            <value>
                The fully qualified name of the class in the type reference.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpClassNameValidationResult.IsGeneric">
            <summary>
                Gets a value indicating whether the parsed type reference represented a generic type with generic type arguments.
            </summary>
            <value>
                <c>true</c> if the type reference used generic type arguments; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpClassNameValidationResult.ErrorDescription">
            <summary>
                Gets a user friendly parsing error description when <see cref="P:LibLSLCC.CSharp.CSharpClassNameValidationResult.Success" /> is false, otherwise <c>null</c>.
            </summary>
            <value>
                The parsing error description, if <see cref="P:LibLSLCC.CSharp.CSharpClassNameValidationResult.Success" /> is <c>false</c>; otherwise, <c>null</c>.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpClassNameValidationResult.ErrorIndex">
            <summary>
                Gets an index near where the parsing error occurred when <see cref="P:LibLSLCC.CSharp.CSharpClassNameValidationResult.Success" /> is <c>false</c>, otherwise 0.
            </summary>
            <value>
                The string index of the error.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpClassNameValidationResult.GenericArguments">
            <summary>
                Gets the sub validation results for the generic arguments of the parsed type if it has any.
                The contents of this array will always be empty if <see cref="P:LibLSLCC.CSharp.CSharpClassNameValidationResult.Success" /> is <c>false</c>.
            </summary>
            <value>
                The sub validation results for the generic arguments.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpClassNameValidationResult.TypeValidationResult">
            <summary>
                Gets the type validation result for this parsed type.  This is only ever non <c>null</c> if a callback for type
                validation
                is passed to <see cref="M:LibLSLCC.CSharp.CSharpClassNameValidator.ValidateInitialization(System.String,System.Boolean,LibLSLCC.CSharp.CSharpParsedTypeValidateTypeCallback)" />.
            </summary>
            <value>
                The type validation result for this parsed class name.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpClassNameValidationResult.FullSignature">
            <summary>
                Gets the full signature of the type/class, with spaces that exist in the input stripped out.
            </summary>
            <value>
                The full signature of the parsed type/class.
            </value>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpClassNameValidator">
            <summary>
                Tools to check the validity of raw class type names in strings
            </summary>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpClassNameValidator.ValidateDeclaration(System.String)">
            <summary>
                Validates that the specified input string is syntactically valid C# class definition signature, including generic
                definition.
            </summary>
            <remarks>
                This function will detect misuse of keywords and built in type names the class definition signature used to define
                a type, even generic types.
            </remarks>
            <param name="input">The input string containing the proposed type value.</param>
            <returns>A parse/validation results object.  <see cref="T:LibLSLCC.CSharp.CSharpClassNameValidationResult" /></returns>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpClassNameValidator.ValidateInitialization(System.String,System.Boolean,LibLSLCC.CSharp.CSharpParsedTypeValidateTypeCallback)">
            <summary>
                Validates that the specified input string is syntactically valid C# type initialization signature, including
                generic types.
            </summary>
            <param name="input">The input string containing the proposed type value.</param>
            <param name="validateTypeCallback">
                A call back to allow you to verify the existence of the types in the type signature
                as they are parsed.
            </param>
            <param name="allowBuiltInAliases">Allow built in aliases such as 'int' or 'char' to pass as class names</param>
            <returns>A parse/validation results object.  <see cref="T:LibLSLCC.CSharp.CSharpClassNameValidationResult" /></returns>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpClassNameValidator.ClassSigType">
            <summary>
                Context of a class name signature
            </summary>
        </member>
        <member name="F:LibLSLCC.CSharp.CSharpClassNameValidator.ClassSigType.Declaration">
            <summary>
                The class name signature is used to declare a class, it could be a generic type definition signature.
            </summary>
        </member>
        <member name="F:LibLSLCC.CSharp.CSharpClassNameValidator.ClassSigType.Initialization">
            <summary>
                The class name signature is used to refer to the class in a initialized context such as
                after the new keyword or in a cast, it still might be generic with filled out type parameters.
            </summary>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpNamespaceValidatorResult">
            <summary>
                Validation result created by <see cref="M:LibLSLCC.CSharp.CSharpNamespaceNameValidator.Validate(System.String)" />
            </summary>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpNamespaceValidatorResult.Success">
            <summary>
                Gets a value indicating whether the namespace was successfully parsed.
            </summary>
            <value>
                <c>true</c> if success; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:LibLSLCC.CSharp.CSharpNamespaceValidatorResult.ErrorDescription">
            <summary>
                Gets a user friendly parsing error description when <see cref="P:LibLSLCC.CSharp.CSharpNamespaceValidatorResult.Success" /> is false, otherwise <c>null</c>.
            </summary>
            <value>
                The parsing error description, if <see cref="P:LibLSLCC.CSharp.CSharpNamespaceValidatorResult.Success" /> is <c>false</c>; otherwise, <c>null</c>.
            </value>
        </member>
        <member name="T:LibLSLCC.CSharp.CSharpNamespaceNameValidator">
            <summary>
                Tools to check the syntax validity of raw namespace name string
            </summary>
        </member>
        <member name="M:LibLSLCC.CSharp.CSharpNamespaceNameValidator.Validate(System.String)">
            <summary>
                Parses and validates a given CSharp namespace string.
            </summary>
            <param name="namespaceName">A string representing the namespace.</param>
            <returns>A parse/validation results object.  <see cref="T:LibLSLCC.CSharp.CSharpNamespaceValidatorResult" /></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="namespaceName"/> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.Compilers.LSLOpenSimCompilerSettings">
            <summary>
                Settings for the <see cref="T:LibLSLCC.Compilers.LSLOpenSimCompiler" /> class.
            </summary>
        </member>
        <member name="M:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.#ctor">
            <summary>
                Construct an <see cref="T:LibLSLCC.Compilers.LSLOpenSimCompilerSettings" /> object that uses a given
                <see cref="T:LibLSLCC.LibraryData.ILSLLibraryDataProvider" /> implementation
                to provide library data to the compiler.
            </summary>
        </member>
        <member name="F:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.DefaultCoOpTerminationFunctionCall">
            <summary>
            Default is: "XEngineScript"
            </summary>
        </member>
        <member name="P:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.CoOpTerminationFunctionCall">
            <summary>
                The call signature to use for co-op termination calls when <see cref="P:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.InsertCoOpTerminationCalls"/> is set to <c>true</c>. <para/>
                Note that you should not add a semi-colon to the end of the signature string.  <para/>
                If set to <c>null</c>, <see cref="F:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.DefaultCoOpTerminationFunctionCall"/> is used.
            </summary>
        </member>
        <member name="P:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.InsertCoOpTerminationCalls">
            <summary>
                If this is set to true, the function signature string specified by CoOpTerminationFunctionCall will be inserted
                (called) at the top of user defined functions, state events, for loops, while loops, do while loops and immediately
                after defined labels in generated code.
            </summary>
        </member>
        <member name="P:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.GenerateClass">
            <summary>
                Whether or not to generate a class around the generated code, defaults to <c>false</c>.
            </summary>
        </member>
        <member name="P:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.GeneratedNamespaceImports">
            <summary>
                This set should contain all the namespace's that the generated code should import
            </summary>
        </member>
        <member name="P:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.GeneratedClassNamespace">
            <summary>
                The name of the namespace the class should reside in if <see cref="P:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.GenerateClass"/> is set to <c>true</c>. <para/>
                Set to <c>null</c> if a the generated class should not be put in a namespace.
            </summary>
        </member>
        <member name="F:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.DefaultGeneratedClassName">
            <summary>
            Default is: "XEngineScript"
            </summary>
        </member>
        <member name="P:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.GeneratedClassName">
            <summary>
                The name of the class around the generated code if <see cref="P:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.GenerateClass"/> is set to <c>true</c>. <para/>
                If set to <c>null</c>, <see cref="F:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.DefaultGeneratedClassName"/> will be used.
            </summary>
        </member>
        <member name="P:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.GeneratedInheritanceList">
            <summary>
                The name of the class the generated class should inherit from if <see cref="P:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.GenerateClass"/> is set to <c>true</c>.
                Set to <c>null</c> or <see cref="F:System.String.Empty"/> if the generated class should not derive from anything.
            </summary>
        </member>
        <member name="F:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.DefaultGeneratedConstructorSignature">
            <summary>
            Default is: "(System.Threading.WaitHandle coopSleepHandle) : base(coopSleepHandle)"
            </summary>
        </member>
        <member name="P:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.GeneratedConstructorSignature">
            <summary>
                The constructor signature to be inserted into the generated class if <see cref="P:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.GenerateClass"/> is set to <c>true</c>. <para/>
                Example: "(int parameter) : base(parameter)"  <para/>
                If set to <c>null</c>, <see cref="F:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.DefaultGeneratedConstructorSignature"/> will be used.
            </summary>
        </member>
        <member name="P:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.GeneratedClassAccessibility">
            <summary>
                The accessibility level of the class if <see cref="P:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.GenerateClass"/> is set to <c>true</c>.
                Defaults to <see cref="F:LibLSLCC.CSharp.ClassAccessibilityLevel.Default" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.GeneratedConstructorAccessibility">
            <summary>
                The accessibility level of the constructor in the generated class if <see cref="P:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.GenerateClass"/> is set to <c>true</c>.
                Defaults to <see cref="F:LibLSLCC.CSharp.MemberAccessibilityLevel.Public" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.ScriptHeader">
            <summary>
                String content to be placed at the very beginning of the generated script, use this to place comments. <para/>
                If it's <c>null</c> or empty then the compiler ignores it.
            </summary>
        </member>
        <member name="P:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.KeysAreStrings">
            <summary>
                If <c>true</c>; user defined variables, function/event parameters and function return types of type 'key' will be
                declared as the runtime 'string' type in generated code. <para/>
                
                'key' type expressions will still be boxed to the runtime key type when they are used in the condition area of a branch or loop statement. <para/>
                
                The default value is <c>true</c>.
            </summary>
        </member>
        <member name="P:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.KeyConstantsThatExpandAreStrings">
            <summary>
                If <c>true</c>; library constants that are declared as <see cref="F:LibLSLCC.CodeValidator.LSLType.Key"/> where <see cref="P:LibLSLCC.LibraryData.LSLLibraryConstantSignature.Expand"/> is <c>true</c>
                will expand into the runtime 'string' type instead of the 'key' type. <para/>
            
                The default value is <c>true</c>.
            </summary>
        </member>
        <member name="P:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.KeyElementsInListConstantsThatExpandAreStrings">
            <summary>
                If <c>true</c>; library constants with the type 'list' where <see cref="P:LibLSLCC.LibraryData.LSLLibraryConstantSignature.Expand"/> is <c>true</c> will have 'key' type elements
                expanded to the runtime 'string' type instead of the 'key' type.  <para/>
                
                The default value is <c>true</c>.
            </summary>
        </member>
        <member name="M:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.CreateOpenSimServerSide">
            <summary>
                Create a settings object that targets OpenSim's server side runtime.  The settings object will be setup to generate
                a class named
                "XEngineScript" that derives from "OpenSim.Region.ScriptEngine.XEngine.ScriptBase.XEngineScriptBase" and contains
                all the generated code.
                This class will be put in the namespace "SecondLife" and "OpenSim.Region.ScriptEngine.Shared" will be added to the
                namespace imports.
            </summary>
            <returns>The generated <see cref="T:LibLSLCC.Compilers.LSLOpenSimCompilerSettings" /> settings object.</returns>
        </member>
        <member name="M:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.CreateLibLSLCCRuntime">
            <summary>
                Create a settings object that targets LibLSLCC's LSL Runtime.  (Which is not implemented yet)
                The settings object will be setup to generate a class named "LSLScript" that derives from "LSLScriptBase".
                This class will be put into the namespace "SecondLife" and "LibLSLCC.LSLRuntime" will be added to the namespace
                imports.
            </summary>
            <returns>The generated <see cref="T:LibLSLCC.Compilers.LSLOpenSimCompilerSettings" /> settings object.</returns>
        </member>
        <member name="M:LibLSLCC.Compilers.LSLOpenSimCompilerSettings.CreateOpenSimClientSide">
            <summary>
                Create a settings object that will settings that will make the <see cref="T:LibLSLCC.Compilers.LSLOpenSimCompiler" /> generate code that
                is up-loadable
                to an OpenSim server via the in viewer editor.  (This only works if the OpenSim server has CSharp scripting
                enabled)
            </summary>
            <returns>The generated <see cref="T:LibLSLCC.Compilers.LSLOpenSimCompilerSettings" /> settings object.</returns>
        </member>
        <member name="T:LibLSLCC.Compilers.LSLCompilerInternalException">
            <summary>
                Exception for internal compiler errors.
            </summary>
        </member>
        <member name="M:LibLSLCC.Compilers.LSLCompilerInternalException.#ctor">
            <summary>
                Default exception constructor.
            </summary>
        </member>
        <member name="M:LibLSLCC.Compilers.LSLCompilerInternalException.#ctor(System.String)">
            <summary>
                Construct the exception with a message.
            </summary>
            <param name="message">The message to construct the exception with.</param>
        </member>
        <member name="M:LibLSLCC.Compilers.LSLCompilerInternalException.#ctor(System.String,System.Exception)">
            <summary>
                Construct the exception with a message and inner exception.
            </summary>
            <param name="message">The message to construct the exception with.</param>
            <param name="inner">The inner exception to construct the exception with.</param>
        </member>
        <member name="M:LibLSLCC.Compilers.LSLCompilerInternalException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Serializable constructor.
            </summary>
            <param name="info">SerializationInfo.</param>
            <param name="context">StreamingContext.</param>
        </member>
        <member name="T:LibLSLCC.Compilers.LSLOpenSimCompiler">
            <summary>
                A compiler that converts LSL Syntax trees into CSharp code that is compatible with OpenSim's CSharp LSL runtime.
            </summary>
        </member>
        <member name="M:LibLSLCC.Compilers.LSLOpenSimCompiler.#ctor(LibLSLCC.CodeValidator.ILSLBasicLibraryDataProvider,LibLSLCC.Compilers.LSLOpenSimCompilerSettings)">
            <summary>
                Construct an <see cref="T:LibLSLCC.Compilers.LSLOpenSimCompiler" /> using the provided <see cref="T:LibLSLCC.CodeValidator.ILSLBasicLibraryDataProvider" /> and
                <see cref="T:LibLSLCC.Compilers.LSLOpenSimCompilerSettings" /> object.
            </summary>
            <param name="settings"><see cref="T:LibLSLCC.Compilers.LSLOpenSimCompilerSettings" /> to use.</param>
            <param name="libraryDataProvider">An <see cref="T:LibLSLCC.CodeValidator.ILSLBasicLibraryDataProvider" /> implementation.</param>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="libraryDataProvider" /> or <paramref name="settings" /> is
                <c>null</c>.
            </exception>
        </member>
        <member name="M:LibLSLCC.Compilers.LSLOpenSimCompiler.#ctor(LibLSLCC.CodeValidator.ILSLBasicLibraryDataProvider)">
            <summary>
                Construct an <see cref="T:LibLSLCC.Compilers.LSLOpenSimCompiler" /> using the default settings and the provided
                <see cref="T:LibLSLCC.LibraryData.ILSLLibraryDataProvider" /> object.
            </summary>
            <param name="libraryDataProvider">An <see cref="T:LibLSLCC.CodeValidator.ILSLBasicLibraryDataProvider" /> implementation.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="libraryDataProvider" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.Compilers.LSLOpenSimCompiler.LibraryDataProvider">
            <summary>
                The library data provider the compiler is using to provide modInvoke information.
            </summary>
        </member>
        <member name="P:LibLSLCC.Compilers.LSLOpenSimCompiler.Settings">
            <summary>
                OpenSim CSharp Compiler settings.
            </summary>
            <exception cref="T:System.ArgumentNullException">If the value is set to null.</exception>
        </member>
        <member name="M:LibLSLCC.Compilers.LSLOpenSimCompiler.Compile(LibLSLCC.CodeValidator.ILSLCompilationUnitNode,System.IO.TextWriter,System.Boolean)">
            <summary>
                Compiles a syntax tree into OpenSim compatible CSharp code, writing the output to the specified TextWriter.
            </summary>
            <param name="compilationUnit">
                The top node of an LSL Syntax tree to compile.
                This is returned from <see cref="M:LibLSLCC.CodeValidator.LSLCodeValidator.Validate(System.IO.TextReader)" /> or user implemented Code DOM.
            </param>
            <param name="writer">The text writer to write the generated code to.</param>
            <param name="closeStream">
                Whether or not to close <paramref name="writer" /> once compilation is done.  The default
                value is <c>false</c>.
            </param>
            <exception cref="T:System.ArgumentException">
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.HasErrors" /> is <c>true</c> in
                <paramref name="compilationUnit" />.
            </exception>
            <exception cref="T:System.ArgumentNullException">
                If <paramref name="compilationUnit" /> or <paramref name="writer" /> is
                <c>null</c>.
            </exception>
            <exception cref="T:System.IO.IOException">When an IO Error occurs while writing to <paramref name="writer" />.</exception>
            <exception cref="T:System.ObjectDisposedException">If <paramref name="writer" /> is already disposed.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:LibLSLCC.Compilers.LSLOpenSimCompiler.Settings" /> is <c>null</c>.</exception>
        </member>
        <member name="F:LibLSLCC.Compilers.LSLOpenSimCompilerVisitor.GlobalsContainerClassName">
            <summary>
                Name of the class that will contain global variables
                if the user specifies not to generate a script class.
                Global variables are initialized inside of a container if
                the library user does not specify that a class should be generated.
            </summary>
        </member>
        <member name="F:LibLSLCC.Compilers.LSLOpenSimCompilerVisitor.GlobalContainerFieldName">
            <summary>
                The global container field name that the globals container class
                gets assigned to in the generated script, when not generating a class.
            </summary>
        </member>
        <member name="F:LibLSLCC.Compilers.LSLOpenSimCompilerVisitor.GlobalContainerFieldsNamePrefix">
            <summary>
                The name prefix used when defining global variables inside of the
                global variable container class.
            </summary>
        </member>
        <member name="F:LibLSLCC.Compilers.LSLOpenSimCompilerVisitor.GlobalFieldsNamePrefix">
            <summary>
                The name prefix used when defining global variables inside of the
                script class itself when a class and class constructor is
                generated for the script.
            </summary>
        </member>
        <member name="F:LibLSLCC.Compilers.LSLOpenSimCompilerVisitor.LocalVariableNamePrefix">
            <summary>
                The local variable prefix to mangle local variables with,
                the compiler appends an integral scope ID after this prefix, followed by an underscore.
            </summary>
        </member>
        <member name="F:LibLSLCC.Compilers.LSLOpenSimCompilerVisitor.LocalParameterNamePrefix">
            <summary>
                The name prefix to mangle parameters names in event handlers and function declarations with.
            </summary>
        </member>
        <member name="F:LibLSLCC.Compilers.LSLOpenSimCompilerVisitor.FunctionNamePrefix">
            <summary>
                The name prefix to mangle user defined function names with.
            </summary>
        </member>
        <member name="F:LibLSLCC.Compilers.LSLOpenSimCompilerVisitor._binOpsUsed">
            <summary>
                Keeps track of what binary operations have been used in the script, stubs are dynamically generated for them
                at the end of the class.
                The stubs reverse the order of evaluation for binary operators.
            </summary>
        </member>
        <member name="F:LibLSLCC.Compilers.LSLOpenSimCompilerVisitor._currentLslEventHandlerNode">
            <summary>
                Tracks what event handler node compilation is currently taking place in.
            </summary>
        </member>
        <member name="F:LibLSLCC.Compilers.LSLOpenSimCompilerVisitor._currentLslStateNode">
            <summary>
                Tracks what state body that LSL code generation is taking place in
                use to determine the names of generated event handler functions.
            </summary>
        </member>
        <member name="F:LibLSLCC.Compilers.LSLOpenSimCompilerVisitor._indentLevel">
            <summary>
                The indent level, used to create pretty output
            </summary>
        </member>
        <member name="P:LibLSLCC.Compilers.LSLOpenSimCompilerVisitor.Settings">
            <summary>
                Gets or sets the code generation settings.
                this must not be null, when <see cref="M:LibLSLCC.Compilers.LSLOpenSimCompilerVisitor.WriteAndFlush(LibLSLCC.CodeValidator.ILSLCompilationUnitNode,System.IO.TextWriter,System.Boolean)" /> is called.
            </summary>
            <value>
                The code generation settings.
            </value>
        </member>
        <member name="M:LibLSLCC.Compilers.LSLOpenSimCompilerVisitor.WriteAndFlush(LibLSLCC.CodeValidator.ILSLCompilationUnitNode,System.IO.TextWriter,System.Boolean)">
            <summary>
                Compiles a syntax tree into OpenSim compatible CSharp code, writing the output to the specified TextWriter.
            </summary>
            <param name="compilationUnit">
                The top node of an LSL Syntax tree to compile.
                This is returned from <see cref="M:LibLSLCC.CodeValidator.LSLCodeValidator.Validate(System.IO.TextReader)" /> or user implemented Code DOM.
            </param>
            <param name="writer">The text writer to write the generated code to.</param>
            <param name="closeStream">
                Whether or not to close <paramref name="writer" /> once compilation is done.  The default
                value is <c>false</c>.
            </param>
            <exception cref="T:System.ArgumentException">
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.HasErrors" /> is <c>true</c> in
                <paramref name="compilationUnit" />.
            </exception>
            <exception cref="T:System.ArgumentNullException">
                If <paramref name="compilationUnit" /> or <paramref name="writer" /> is
                <c>null</c>.
            </exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:LibLSLCC.Compilers.LSLOpenSimCompilerVisitor.Settings" /> is <c>null</c>.</exception>
            <exception cref="T:System.IO.IOException">When an IO Error occurs while writing to <paramref name="writer" />.</exception>
            <exception cref="T:System.ObjectDisposedException">If <paramref name="writer" /> is already disposed.</exception>
        </member>
        <member name="M:LibLSLCC.Compilers.LSLOpenSimCompilerVisitor.VisitVariableDeclarationExpression(LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
            <summary>
            This stub is used for both local variable declaration expressions and global variable.
            declaration expressions.
            </summary>
            <param name="declaration">The declaration.</param>
        </member>
        <member name="M:LibLSLCC.Compilers.LSLOpenSimCompilerVisitor.WriteUtilityLibrary">
            <summary>
                need a small utility library compiled in the generated csharp code
                because OpenSim lacks several lsl features like using vectors, rotations, and list in condition statements
            </summary>
        </member>
        <member name="M:LibLSLCC.Compilers.LSLOpenSimCompilerVisitor.VisitFunctionDeclaration(LibLSLCC.CodeValidator.ILSLFunctionDeclarationNode)">
            <summary>
                Default implementation calls Visit(node.ParameterListNode) then Visit(node.FunctionBodyNode)
                and returns default(T)
            </summary>
            <param name="node">An object describing the function declaration</param>
            <returns>default(T)</returns>
        </member>
        <member name="M:LibLSLCC.Compilers.LSLOpenSimCompilerVisitor.SafeToPruneLocalVariableDeclaration(LibLSLCC.CodeValidator.ILSLVariableDeclarationNode)">
            <summary>
                Returns true if a given variable declaration node has no references to it later in the source code, and
                its declaration contains no expressions that could modify program state.
            </summary>
            <param name="declarationNode">The declaration node to test.</param>
            <returns></returns>
        </member>
        <member name="T:LibLSLCC.CodeFormatter.LSLCodeFormatter">
            <summary>
                Implements a code formatter that can format LibLSLCC syntax tree nodes.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeFormatter.LSLCodeFormatter.#ctor(LibLSLCC.CodeFormatter.LSLCodeFormatterSettings)">
            <summary>
                Construct a new <see cref="T:LibLSLCC.CodeFormatter.LSLCodeFormatter"/> with the given settings object.
            </summary>
            <param name="settings">The <see cref="T:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings"/> object to use for the formatter.</param>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="settings" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeFormatter.LSLCodeFormatter.#ctor">
            <summary>
                Construct a new <see cref="T:LibLSLCC.CodeFormatter.LSLCodeFormatter"/>.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatter.Settings">
            <summary>
                The code formatter settings.
            </summary>
            <exception cref="T:System.ArgumentNullException">Thrown if <see cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatter.Settings" /> is set to <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeFormatter.LSLCodeFormatter.Format(LibLSLCC.CodeValidator.ILSLCompilationUnitNode,System.IO.TextWriter,System.Boolean)">
            <summary>
                Formats an <see cref="T:LibLSLCC.CodeValidator.ILSLCompilationUnitNode" /> to an output writer.
            </summary>
            <param name="compilationUnit">A top level compilation unit syntax tree node.</param>
            <param name="writer">The writer to write the formated source code to.</param>
            <param name="closeStream">
                <c>true</c> if this method should close <paramref name="writer" /> when finished.  The
                default value is <c>false</c>.
            </param>
            <exception cref="T:System.ArgumentException">
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.HasErrors" /> is <c>true</c> in
                <paramref name="compilationUnit" />.
            </exception>
            <exception cref="T:System.ArgumentNullException">
                If <paramref name="compilationUnit" /> or <paramref name="writer" /> is
                <c>null</c>.
            </exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatter.Settings" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeFormatter.LSLCodeFormatter.Format(System.String,LibLSLCC.CodeValidator.ILSLCompilationUnitNode,System.IO.TextWriter,System.Boolean)">
            <summary>
                Formats an <see cref="T:LibLSLCC.CodeValidator.ILSLCompilationUnitNode" /> to an output writer, with the ability to provide optional source
                code hint text.
            </summary>
            <param name="sourceCodeHint">
                When provided the formatter can make more intelligent decisions in various places, such as retaining user spacing
                when comments appear on the same line as a statement.
            </param>
            <param name="compilationUnit">A top level compilation unit syntax tree node.</param>
            <param name="writer">The writer to write the formated source code to.</param>
            <param name="closeStream">
                <c>true</c> if this method should close <paramref name="writer" /> when finished.  The
                default value is <c>false</c>.
            </param>
            <exception cref="T:System.ArgumentException">
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.HasErrors" /> is <c>true</c> in
                <paramref name="compilationUnit" />.
            </exception>
            <exception cref="T:System.ArgumentNullException">
                If <paramref name="compilationUnit" /> or <paramref name="writer" /> is
                <c>null</c>.
            </exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatter.Settings" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeFormatter.LSLCodeFormatter.Format(LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode,System.IO.TextWriter,System.Boolean)">
            <summary>
                Formats an <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode" /> to an output writer. <para/>
                Comments are discarded.
            </summary>
            <param name="syntaxTree">Syntax tree node to format to output.</param>
            <param name="writer">The writer to write the formated source code to.</param>
            <param name="closeStream">
                <c>true</c> if this method should close <paramref name="writer" /> when finished.  The
                default value is <c>false</c>.
            </param>
            <exception cref="T:System.ArgumentException">
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.HasErrors" /> is <c>true</c> in
                <paramref name="syntaxTree" />.
            </exception>
            <exception cref="T:System.ArgumentNullException">
                If <paramref name="syntaxTree" /> or <paramref name="writer" /> is
                <c>null</c>.
            </exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatter.Settings" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeFormatter.LSLCodeFormatter.Format(System.Collections.Generic.IEnumerable{LibLSLCC.CodeValidator.LSLComment},LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode,System.IO.TextWriter,System.Boolean)">
            <summary>
                Formats an <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode" /> to an output writer.
            </summary>
            <param name="sourceComments">Source code comments.</param>
            <param name="syntaxTree">Syntax tree node to format to output.</param>
            <param name="writer">The writer to write the formated source code to.</param>
            <param name="closeStream">
                <c>true</c> if this method should close <paramref name="writer" /> when finished.  The
                default value is <c>false</c>.
            </param>
            <exception cref="T:System.ArgumentException">
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.HasErrors" /> is <c>true</c> in
                <paramref name="syntaxTree" />.
            </exception>
            <exception cref="T:System.ArgumentNullException">
                If <paramref name="sourceComments"/> or <paramref name="syntaxTree" /> or <paramref name="writer" /> is
                <c>null</c>.
            </exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatter.Settings" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeFormatter.LSLCodeFormatter.Format(System.String,LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode,System.IO.TextWriter,System.Boolean)">
            <summary>
                Formats an <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode" /> to an output writer, with the ability to provide source code hint text. <para/>
                Comments are discarded.
            </summary>
            <param name="sourceCodeHint">
                When provided the formatter can make more intelligent decisions in various places, such as retaining user spacing
                when comments appear on the same line as a statement.
            </param>
            <param name="syntaxTree">Syntax tree node to format to output.</param>
            <param name="writer">The writer to write the formated source code to.</param>
            <param name="closeStream">
                <c>true</c> if this method should close <paramref name="writer" /> when finished.  The
                default value is <c>false</c>.
            </param>
            <exception cref="T:System.ArgumentException">
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.HasErrors" /> is <c>true</c> in
                <paramref name="syntaxTree" />.
            </exception>
            <exception cref="T:System.ArgumentNullException">
                If <paramref name="sourceCodeHint" /> or <paramref name="syntaxTree" /> or <paramref name="writer" /> is
                <c>null</c>.
            </exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatter.Settings" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.CodeFormatter.LSLCodeFormatter.Format(System.String,System.Collections.Generic.IEnumerable{LibLSLCC.CodeValidator.LSLComment},LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode,System.IO.TextWriter,System.Boolean)">
            <summary>
                Formats an <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode" /> to an output writer, with the ability to provide source code hint text.
            </summary>
            <param name="sourceCodeHint">
                When provided the formatter can make more intelligent decisions in various places, such as retaining user spacing
                when comments appear on the same line as a statement.
            </param>
            <param name="sourceComments">Source code comments.</param>
            <param name="syntaxTree">Syntax tree node to format to output.</param>
            <param name="writer">The writer to write the formated source code to.</param>
            <param name="closeStream">
                <c>true</c> if this method should close <paramref name="writer" /> when finished.  The
                default value is <c>false</c>.
            </param>
            <exception cref="T:System.ArgumentException">
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.HasErrors" /> is <c>true</c> in
                <paramref name="syntaxTree" />.
            </exception>
            <exception cref="T:System.ArgumentNullException">
                If <paramref name="sourceCodeHint" /> or <paramref name="sourceComments"/> or <paramref name="syntaxTree" /> or <paramref name="writer" /> is
                <c>null</c>.
            </exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatter.Settings" /> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings">
            <summary>
                The settings object for <see cref="T:LibLSLCC.CodeFormatter.LSLCodeFormatter" />.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.RemoveComments">
            <summary>
                Whether or not the formatter should strip all comments from the source code.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.NewlineSequence">
            <summary>
                The newline sequence the formatter should use to write newlines with.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.TabString">
            <summary>
                The tab string the formatter should use to indent with.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.DeclarationExpressionWrapping">
            <summary>
                True if the formatter should wrap declaration expressions that exceed wrapping limits.
            </summary>
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.ColumnsBeforeDeclarationExpressionWrap" />
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MinimumExpressionsInDeclarationToWrap" />
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.ColumnsBeforeDeclarationExpressionWrap">
            <summary>
                The number of character columns before the formatter should consider wrapping a declaration expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MinimumExpressionsInDeclarationToWrap">
            <summary>
                The minimum number of binary expressions before the formatter should consider wrapping a declaration expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.StatementExpressionWrapping">
            <summary>
                True if the formatter should wrap statement expressions that exceed wrapping limits.
            </summary>
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.ColumnsBeforeStatementExpressionWrap" />
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MinimumExpressionsInStatementToWrap" />
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.ColumnsBeforeStatementExpressionWrap">
            <summary>
                The number of character columns before the formatter should consider wrapping a statement expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MinimumExpressionsInStatementToWrap">
            <summary>
                The minimum number of binary expressions before the formatter should consider wrapping a statement expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.ReturnExpressionWrapping">
            <summary>
                True if the formatter should wrap return expressions that exceed wrapping limits.
            </summary>
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.ColumnsBeforeReturnExpressionWrap" />
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MinimumExpressionsInReturnToWrap" />
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.ColumnsBeforeReturnExpressionWrap">
            <summary>
                The number of character columns before the formatter should consider wrapping a return expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MinimumExpressionsInReturnToWrap">
            <summary>
                The minimum number of binary expressions before the formatter should consider wrapping a return expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.IfExpressionWrapping">
            <summary>
                True if the formatter should wrap if condition expressions that exceed wrapping limits.
            </summary>
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.ColumnsBeforeIfExpressionWrap" />
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MinimumExpressionsInIfToWrap" />
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.ColumnsBeforeIfExpressionWrap">
            <summary>
                The number of character columns before the formatter should consider wrapping an if condition expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MinimumExpressionsInIfToWrap">
            <summary>
                The minimum number of binary expressions before the formatter should consider wrapping an if condition expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.ElseIfExpressionWrapping">
            <summary>
                True if the formatter should wrap 'if else' condition expressions that exceed wrapping limits.
            </summary>
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.ColumnsBeforeElseIfExpressionWrap" />
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MinimumExpressionsInElseIfToWrap" />
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.ColumnsBeforeElseIfExpressionWrap">
            <summary>
                The number of character columns before the formatter should consider wrapping an 'if else' condition expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MinimumExpressionsInElseIfToWrap">
            <summary>
                The minimum number of binary expressions before the formatter should consider wrapping an 'if else' condition
                expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.WhileExpressionWrapping">
            <summary>
                True if the formatter should wrap while condition expressions that exceed wrapping limits.
            </summary>
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.ColumnsBeforeWhileExpressionWrap" />
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MinimumExpressionsInWhileToWrap" />
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.ColumnsBeforeWhileExpressionWrap">
            <summary>
                The number of character columns before the formatter should consider wrapping a while condition expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MinimumExpressionsInWhileToWrap">
            <summary>
                The minimum number of binary expressions before the formatter should consider wrapping a while condition
                expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.DoWhileExpressionWrapping">
            <summary>
                True if the formatter should wrap 'do while' condition expressions that exceed wrapping limits.
            </summary>
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.ColumnsBeforeDoWhileExpressionWrap" />
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MinimumExpressionsInDoWhileToWrap" />
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.ColumnsBeforeDoWhileExpressionWrap">
            <summary>
                The number of character columns before the formatter should consider wrapping a while condition expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MinimumExpressionsInDoWhileToWrap">
            <summary>
                The minimum number of binary expressions before the formatter should consider wrapping a 'do while' condition
                expression.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.IfStatementBracesOnNewLine">
            <summary>
                whether or not an if statements opening brace should be placed on a new line.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.ElseIfStatementBracesOnNewLine">
            <summary>
                whether or not an 'else if' statements opening brace should be placed on a new line.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.ElseStatementBracesOnNewLine">
            <summary>
                whether or not an 'else' statements opening brace should be placed on a new line.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.StateBracesOnNewLine">
            <summary>
                Whether or not a state blocks opening brace should be placed on a new line.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.EventBracesOnNewLine">
            <summary>
                Whether or not an event handlers opening brace should be placed on a new line.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.FunctionBracesOnNewLine">
            <summary>
                Whether or not a function declarations opening brace should be placed on a new line.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.WhileLoopBracesOnNewLine">
            <summary>
                Whether or not a while loops opening brace should be placed on a new line.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.DoLoopBracesOnNewLine">
            <summary>
                Whether or not a 'do while' loops opening brace should be placed on a new line.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.ForLoopBracesOnNewLine">
            <summary>
                Whether or not a for loops opening brace should be placed on a new line.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeOpeningStateBrace">
            <summary>
                The number of spaces to place before a state blocks opening brace.
            </summary>
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.AddSpacesBeforeOpeningStateBraceAfterCommentBreak" />
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeClosingStateBrace">
            <summary>
                The number of spaces to place before a state blocks closing brace.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeOpeningIfBrace">
            <summary>
                The number of spaces to place before an if statements opening brace.
            </summary>
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.AddSpacesBeforeOpeningIfBraceAfterCommentBreak" />
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeClosingIfBrace">
            <summary>
                The number of spaces to place before an if statements closing brace.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeOpeningElseIfBrace">
            <summary>
                The number of spaces to place before an 'else if' statements opening brace.
            </summary>
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.AddSpacesBeforeOpeningElseIfBraceAfterCommentBreak" />
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeClosingElseIfBrace">
            <summary>
                The number of spaces to place before an 'else if' statements closing brace.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeOpeningElseBrace">
            <summary>
                The number of spaces to place before an else statements opening brace.
            </summary>
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.AddSpacesBeforeOpeningElseBraceAfterCommentBreak" />
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeClosingElseBrace">
            <summary>
                The number of spaces to place before an else statements closing brace.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeOpeningForLoopBrace">
            <summary>
                The number of spaces to place before a for loop statements opening brace.
            </summary>
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.AddSpacesBeforeOpeningForLoopBraceAfterCommentBreak" />
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeClosingForLoopBrace">
            <summary>
                The number of spaces to place before a for loop statements closing brace.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeOpeningDoLoopBrace">
            <summary>
                The number of spaces to place before a do loop statements opening brace.
            </summary>
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.AddSpacesBeforeOpeningDoLoopBraceAfterCommentBreak" />
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeClosingDoLoopBrace">
            <summary>
                The number of spaces to place before a do loop statements closing brace.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeOpeningWhileLoopBrace">
            <summary>
                The number of spaces to place before a while loop statements opening brace.
            </summary>
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.AddSpacesBeforeOpeningWhileLoopBraceAfterCommentBreak" />
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeClosingWhileLoopBrace">
            <summary>
                The number of spaces to place before a while loop statements closing brace.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeOpeningEventBrace">
            <summary>
                The number of spaces to place before an event handlers opening brace.
            </summary>
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.AddSpacesBeforeOpeningEventBraceAfterCommentBreak" />
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeClosingEventBrace">
            <summary>
                The number of spaces to place before an event handlers closing brace.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeOpeningFunctionBrace">
            <summary>
                The number of spaces to place before a function declarations opening brace.
            </summary>
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.AddSpacesBeforeOpeningFunctionBraceAfterCommentBreak" />
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeClosingFunctionBrace">
            <summary>
                The number of spaces to place before a function declarations closing brace.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.IndentBracelessControlStatements">
            <summary>
                Whether or not to indent control statements (branches and loops) that do not use braces. (single statement scopes)
                <para />
                Setting this to <c>true</c> will make <see cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.ConvertBracelessControlStatements" /> <c>false</c>.
            </summary>
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.ConvertBracelessControlStatements" />
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.ConvertBracelessControlStatements">
            <summary>
                Whether or not to add braces to control statements (branches and loops) that were not previously using braces.
                (single statement scopes)
                <para />
                Setting this to <c>true</c> will make <see cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.IndentBracelessControlStatements" /> <c>false</c>.
            </summary>
            <seealso cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.IndentBracelessControlStatements" />
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeUnbrokenElseIfStatement">
            <summary>
                The number of spaces to place before an unbroken 'else if' statement keyword.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.ElseIfStatementOnNewLine">
            <summary>
                Whether or not to place 'else if' on a new line in branch statements.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.ElseStatementOnNewLine">
            <summary>
                Whether or not to place 'else' on a new line in branch statements.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeUnbrokenElseStatement">
            <summary>
                The number of spaces to place before an unbroken 'else' statement keyword.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MaximumNewLinesAtEndOfCodeScope">
            <summary>
                The maximum amount of new lines that can appear at the end of a code scope, the lowest possible value is 1.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MaximumNewLinesAtBeginingOfCodeScope">
            <summary>
                The maximum amount of new lines that can appear at the beginning of a code scope, the lowest possible value is 1.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MinimumNewLinesBetweenDistinctLocalStatements">
            <summary>
                The minimum amount of new lines between distinct types of code statements inside of a code scope, the lowest
                possible value is 1.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MinimumNewLinesBetweenDistinctGlobalStatements">
            <summary>
                The minimum amount of new lines between distinct types of code statements in the global scope, the lowest possible
                value is 1.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MaximumNewLinesAtBeginingOfStateScope">
            <summary>
                The maximum amount of new lines that can appear at the beginning of a state scope, the lowest possible value is 1.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MinimumNewLinesBetweenEventHandlers">
            <summary>
                The minimum amount of new lines between distinct types of code statement inside of a code scope, the lowest
                possible value is 1.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MaximumNewLinesAtEndOfStateScope">
            <summary>
                The maximum amount of new lines that can appear at the end of a state scope, the lowest possible value is 1.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.AddSpacesBeforeOpeningWhileLoopBraceAfterCommentBreak">
            <summary>
                Whether or not to add <see cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeOpeningWhileLoopBrace" /> before an opening while loop brace
                that has been forcefully put on a new line, due to a comment appearing immediately before the brace.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.AddSpacesBeforeOpeningDoLoopBraceAfterCommentBreak">
            <summary>
                Whether or not to add <see cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeOpeningDoLoopBrace" /> before an opening do loop brace
                that has been forcefully put on a new line, due to a comment appearing immediately before the brace.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.AddSpacesBeforeOpeningForLoopBraceAfterCommentBreak">
            <summary>
                Whether or not to add <see cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeOpeningForLoopBrace" /> before an opening for loop brace
                that has been forcefully put on a new line, due to a comment appearing immediately before the brace.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.AddSpacesBeforeOpeningElseBraceAfterCommentBreak">
            <summary>
                Whether or not to add <see cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeOpeningElseBrace" /> before an opening 'else' statement brace
                that has been forcefully put on a new line, due to a comment appearing immediately before the brace.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.AddSpacesBeforeOpeningElseIfBraceAfterCommentBreak">
            <summary>
                Whether or not to add <see cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeOpeningElseIfBrace" /> before an opening 'else if' statement brace
                that has been forcefully put on a new line, due to a comment appearing immediately before the brace.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.AddSpacesBeforeOpeningIfBraceAfterCommentBreak">
            <summary>
                Whether or not to add <see cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeOpeningIfBrace" /> before an opening 'if' statement brace
                that has been forcefully put on a new line, due to a comment appearing immediately before the brace.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.AddSpacesBeforeOpeningFunctionBraceAfterCommentBreak">
            <summary>
                Whether or not to add <see cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeOpeningFunctionBrace" /> before an opening function declaration brace
                that has been forcefully put on a new line, due to a comment appearing immediately before the brace.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.AddSpacesBeforeOpeningEventBraceAfterCommentBreak">
            <summary>
                Whether or not to add <see cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeOpeningEventBrace" /> before an opening event handler brace
                that has been forcefully put on a new line, due to a comment appearing immediately before the brace.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.AddSpacesBeforeOpeningStateBraceAfterCommentBreak">
            <summary>
                Whether or not to add <see cref="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.SpacesBeforeOpeningStateBrace" /> before an opening state block brace
                that has been forcefully put on a new line, due to a comment appearing immediately before the brace.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MaximumNewLinesBetweenLocalStatements">
            <summary>
                The maximum amount of newlines that can appear between local code statements.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MaximumNewLinesBetweenGlobalStatements">
            <summary>
                The maximum amount of newlines that can appear between global code statements.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MaximumCharactersBeforeListLiteralWrap">
            <summary>
                The maximum amount of character columns that can appear in a list literal before it wraps.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MaximumCharactersBeforeArgumentListWrap">
            <summary>
                The maximum amount of character columns that can appear in an argument list before it wraps.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MinimumNewLinesBetweenGlobalStatementAndNextComment">
            <summary>
                The minimum amount of new lines between a global statement and a comment that follows after it.
            </summary>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterSettings.MaximumNewLinesBetweenGlobalStatementAndNextComment">
            <summary>
                The maximum amount of new lines between a global statement and a comment that follows after it.
            </summary>
        </member>
        <member name="T:LibLSLCC.CodeFormatter.LSLCodeFormatterVisitor">
            <summary>
                An LSL Syntax tree visitor that formats code.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeFormatter.LSLCodeFormatterVisitor.#ctor(LibLSLCC.CodeFormatter.LSLCodeFormatterSettings)">
            <summary>
                Default constructor for the formatting visitor.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="settings" /> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.CodeFormatter.LSLCodeFormatterVisitor.Writer">
            <summary>
                The TextWriter that was passed to the WriteAndFlush function.
            </summary>
        </member>
        <member name="M:LibLSLCC.CodeFormatter.LSLCodeFormatterVisitor.WriteAndFlush(System.String,System.Collections.Generic.IEnumerable{LibLSLCC.CodeValidator.LSLComment},LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode,System.IO.TextWriter,System.Boolean)">
            <summary>
                Formats an <see cref="T:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode" /> to an output writer, with the ability to provide optional source code hint text.
            </summary>
            <param name="sourceCodeHint">
                The source code of the script, this can be <c>null</c>.  
                when provided the formatter can make more intelligent decisions in various places, such as retaining user spacing when comments appear on the same line as a statement.
            </param>
            <param name="sourceComments">Source code comments.  Optional, may be <c>null</c>.</param>
            <param name="syntaxTree">Syntax tree node to format to output.</param>
            <param name="writer">The writer to write the formated source code to.</param>
            <param name="closeStream">
                <c>true</c> if this method should close <paramref name="writer" /> when finished.  The
                default value is <c>false</c>.
            </param>
            <exception cref="T:System.ArgumentException">
                If <see cref="P:LibLSLCC.CodeValidator.ILSLReadOnlySyntaxTreeNode.HasErrors" /> is <c>true</c> in
                <paramref name="syntaxTree" />.
            </exception>
            <exception cref="T:System.ArgumentNullException">
                If <paramref name="syntaxTree" /> or <paramref name="writer" /> is
                <c>null</c>.
            </exception>
        </member>
        <member name="T:LibLSLCC.LibraryData.LSLEmbeddedLibraryDataProvider">
            <summary>
                The LSLEmbeddedLibraryDataProvider reads XML from the embedded resource
                LibLSLCC.CodeValidator.Components.LibraryDataProvider.LSLEmbeddedLibraryDataProvider.xml
                to define its data
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLEmbeddedLibraryDataProvider.#ctor(LibLSLCC.LibraryData.LSLLibraryBaseData,LibLSLCC.LibraryData.LSLLibraryDataAdditions,System.Boolean,LibLSLCC.LibraryData.LSLLibraryDataLoadOptions)">
            <summary>
                Constructs an <see cref="T:LibLSLCC.LibraryData.LSLEmbeddedLibraryDataProvider"/> using the library data embedded in LibLSLCC's assembly.
            </summary>
            <param name="liveFiltering">
                If this is set to true, all subsets will be loaded into memory. And when you change the active subsets query
                results will change.  Otherwise if this is false, only subsets present upon construction will be loaded.
            </param>
            <param name="libraryBaseData">The base library data to use.</param>
            <param name="dataAdditions">Addititional library data to import (flags).</param>
            <param name="loadOptions">
                Optionally specifies what type's of library definitions will be loaded, defaults to
                <see cref="F:LibLSLCC.LibraryData.LSLLibraryDataLoadOptions.All" />
            </param>
            <exception cref="T:System.InvalidOperationException">
                If the embedded library data could not be loaded from the assembly
                manifest.
            </exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLEmbeddedLibraryDataProvider.#ctor(LibLSLCC.LibraryData.LSLLibraryBaseData,LibLSLCC.LibraryData.LSLLibraryDataAdditions,LibLSLCC.LibraryData.LSLLibraryDataLoadOptions)">
            <summary>
                Constructs an <see cref="T:LibLSLCC.LibraryData.LSLEmbeddedLibraryDataProvider"/> using the library data embedded in LibLSLCC's assembly.
                <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.LiveFiltering"/> will be enabled by default.
            </summary>
            <param name="libraryBaseData">The base library data to use.</param>
            <param name="dataAdditions">Addititional library data to import (flags).</param>
            <param name="loadOptions">
                Optionally specifies what type's of library definitions will be loaded, defaults to
                <see cref="F:LibLSLCC.LibraryData.LSLLibraryDataLoadOptions.All" />
            </param>
            <exception cref="T:System.InvalidOperationException">
                If the embedded library data could not be loaded from the assembly
                manifest.
            </exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLEmbeddedLibraryDataProvider.#ctor(System.Collections.Generic.IEnumerable{System.String},LibLSLCC.LibraryData.LSLLibraryDataLoadOptions)">
            <summary>
                Constructs an <see cref="T:LibLSLCC.LibraryData.LSLEmbeddedLibraryDataProvider"/> using the library data embedded in LibLSLCC's assembly.
                <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.LiveFiltering"/> will be enabled by default.
            </summary>
            <param name="activeSubsets">The library subsets to utilize.</param>
            <param name="loadOptions">
                Optionally specifies what type's of library definitions will be loaded, defaults to
                <see cref="F:LibLSLCC.LibraryData.LSLLibraryDataLoadOptions.All" />
            </param>
            <exception cref="T:System.InvalidOperationException">
                If the embedded library data could not be loaded from the assembly
                manifest.
            </exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLEmbeddedLibraryDataProvider.#ctor(System.Collections.Generic.IEnumerable{System.String},System.Boolean,LibLSLCC.LibraryData.LSLLibraryDataLoadOptions)">
            <summary>
                Constructs an <see cref="T:LibLSLCC.LibraryData.LSLEmbeddedLibraryDataProvider"/> using the library data embedded in LibLSLCC's assembly.
            </summary>
            <param name="activeSubsets">The library subsets to utilize.</param>
            <param name="liveFiltering">
                If this is set to true, all subsets will be loaded into memory. And when you change the active subsets query
                results will change.  Otherwise if this is false, only subsets present upon construction will be loaded.
            </param>
            <param name="loadOptions">
                Optionally specifies what type's of library definitions will be loaded, defaults to
                <see cref="F:LibLSLCC.LibraryData.LSLLibraryDataLoadOptions.All" />
            </param>
            <exception cref="T:System.InvalidOperationException">
                If the embedded library data could not be loaded from the assembly
                manifest.
            </exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLEmbeddedLibraryDataProvider.#ctor">
            <summary>
                Constructs an <see cref="T:LibLSLCC.LibraryData.LSLEmbeddedLibraryDataProvider"/> using the library data embedded in LibLSLCC's assembly.
                <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.LiveFiltering"/> will be enabled by default.
            </summary>
            <exception cref="T:System.InvalidOperationException">
                If the embedded library data could not be loaded from the assembly
                manifest.
            </exception>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLEmbeddedLibraryDataProvider.LiveFilteringBaseLibraryData">
            <summary>
                Easy way to add either 'lsl' or 'os-lsl' to the active subsets
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLEmbeddedLibraryDataProvider.LiveFilteringLibraryDataAdditions">
            <summary>
                Easy way to add extra modules to the active subsets
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLEmbeddedLibraryDataProvider.GetDefaultLibraryDataStream">
            <summary>
                Get a stream that points the default library XML data embedded in the LibLSLCC assembly.
            </summary>
            <returns>A stream containing the default library XML data embedded in LibLSLCC</returns>
        </member>
        <member name="T:LibLSLCC.LibraryData.LSLLibraryDataAdditions">
            <summary>
                Represents the available additional library subsets in LSLEmbeddedLibraryDataProvider.xml
            </summary>
        </member>
        <member name="F:LibLSLCC.LibraryData.LSLLibraryDataAdditions.None">
            <summary>
                Specifies no extra library data
            </summary>
        </member>
        <member name="F:LibLSLCC.LibraryData.LSLLibraryDataAdditions.OpenSimOssl">
            <summary>
                Specifies the addition of the OpenSim OSSL functions
            </summary>
        </member>
        <member name="F:LibLSLCC.LibraryData.LSLLibraryDataAdditions.OpenSimWindlight">
            <summary>
                Specifies the addition of the OpenSim light share functions
            </summary>
        </member>
        <member name="F:LibLSLCC.LibraryData.LSLLibraryDataAdditions.OpenSimBulletPhysics">
            <summary>
                Specifies the addition of the OpenSim bullet phys* functions
            </summary>
        </member>
        <member name="F:LibLSLCC.LibraryData.LSLLibraryDataAdditions.OpenSimModInvoke">
            <summary>
                Specifies the addition of the OpenSim mod invoke functions
            </summary>
        </member>
        <member name="F:LibLSLCC.LibraryData.LSLLibraryDataAdditions.OpenSimJsonStore">
            <summary>
                Specifies the addition of the OpenSim json store functions
            </summary>
        </member>
        <member name="T:LibLSLCC.LibraryData.LSLLibraryDataAdditionEnumExtensions">
            <summary>
                Extensions for the LSLLibraryDataAdditions flags Enum
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataAdditionEnumExtensions.ToSubsetNames(LibLSLCC.LibraryData.LSLLibraryDataAdditions)">
            <summary>
                Converts an <see cref="T:LibLSLCC.LibraryData.LSLLibraryDataAdditions"/> flags enum to the corresponding set of subset names.
            </summary>
            <param name="dataAdditionFlags">The additional library data flags.</param>
            <returns>a string representation of the subset</returns>
        </member>
        <member name="T:LibLSLCC.LibraryData.LSLLibraryBaseData">
            <summary>
                Represents the available base library subsets in LSLEmbeddedLibraryDataProvider.xml
            </summary>
        </member>
        <member name="F:LibLSLCC.LibraryData.LSLLibraryBaseData.StandardLsl">
            <summary>
                Standard LSL
            </summary>
        </member>
        <member name="F:LibLSLCC.LibraryData.LSLLibraryBaseData.OpensimLsl">
            <summary>
                OpenSim subset of Standard LSL
            </summary>
        </member>
        <member name="T:LibLSLCC.LibraryData.LSLLibraryBaseDataEnumExtensions">
            <summary>
                Extensions for the LSLLibraryBaseDataEnumExtensions Enum
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryBaseDataEnumExtensions.ToSubsetName(LibLSLCC.LibraryData.LSLLibraryBaseData)">
            <summary>
                Converts <see cref="T:LibLSLCC.LibraryData.LSLLibraryBaseData"/>to the corresponding subset string.
            </summary>
            <param name="baseDataOption">The base data option.</param>
            <returns>a string representation of the subset</returns>
        </member>
        <member name="T:LibLSLCC.LibraryData.ILSLLibrarySignature">
            <summary>
                Interface for the common properties shared by LSLLibrary*Signature objects.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.ILSLLibrarySignature.Deprecated">
            <summary>
                Whether or not this library signature is marked as deprecated or not.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.ILSLLibrarySignature.DocumentationString">
            <summary>
                Returns the documentation string attached to this library signature.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.ILSLLibrarySignature.Properties">
            <summary>
                Additional dynamic property values that can be attached to the constant signature and parsed from XML
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.ILSLLibrarySignature.SignatureAndDocumentation">
            <summary>
                Returns a formated string containing the signature and documentation for this library signature.
                It consists of the SignatureString followed by a semi-colon, and then followed by a new-line and
                DocumentationString
                if the documentation string is not null.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.ILSLLibrarySignature.Subsets">
            <summary>
                The library subsets this signature belongs to/is shared among.
            </summary>
        </member>
        <member name="T:LibLSLCC.LibraryData.LibraryDataSubsetAddedEventArgs">
            <summary>
                EventArgs for <see cref="E:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.OnSubsetAdded" />
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LibraryDataSubsetAddedEventArgs.#ctor(System.String)">
            <summary>
                Constructs the event arguments using the name of the subset added.
            </summary>
            <param name="subsetName">The name of the subset added.</param>
        </member>
        <member name="P:LibLSLCC.LibraryData.LibraryDataSubsetAddedEventArgs.SubsetName">
            <summary>
                The subset name added.
            </summary>
        </member>
        <member name="T:LibLSLCC.LibraryData.LibraryDataSubsetRemovedEventArgs">
            <summary>
                EventArgs for <see cref="E:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.OnSubsetRemoved" />
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LibraryDataSubsetRemovedEventArgs.#ctor(System.String)">
            <summary>
                Constructs the event arguments using the name of the subset removed.
            </summary>
            <param name="subsetName">The name of the subset removed.</param>
        </member>
        <member name="P:LibLSLCC.LibraryData.LibraryDataSubsetRemovedEventArgs.SubsetName">
            <summary>
                The subset name removed.
            </summary>
        </member>
        <member name="T:LibLSLCC.LibraryData.LibraryDataSubsetsChangedEventArgs">
            <summary>
                EventArgs for <see cref="E:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.OnSubsetsChanged" />
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LibraryDataSubsetsChangedEventArgs.#ctor(LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection)">
            <summary>
                Constructs the event arguments using a reference to the collection that was changed.
            </summary>
            <param name="collection">The collection that was changed.</param>
        </member>
        <member name="P:LibLSLCC.LibraryData.LibraryDataSubsetsChangedEventArgs.Collection">
            <summary>
                The <see cref="T:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection" /> that was changed.
            </summary>
        </member>
        <member name="T:LibLSLCC.LibraryData.LibraryDataSubsetsClearedEventArgs">
            <summary>
                EventArgs for <see cref="E:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.OnSubsetsCleared" />
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LibraryDataSubsetsClearedEventArgs.#ctor(LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection)">
            <summary>
                Constructs the event arguments using a reference to the collection that was cleared.
            </summary>
            <param name="collection">The collection that was cleared.</param>
        </member>
        <member name="P:LibLSLCC.LibraryData.LibraryDataSubsetsClearedEventArgs.Collection">
            <summary>
                The <see cref="T:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection" /> that was cleared.
            </summary>
        </member>
        <member name="T:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection">
            <summary>
                Collection wrapper for library subset strings
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Construct a subsets collection out of an existing enumerable of strings
            </summary>
            <param name="subsets">An enumerable of subset names to initialize the subset collection from.</param>
            <exception cref="T:LibLSLCC.LibraryData.LSLInvalidSubsetNameException">If any of the give subset names contain invalid characters.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="subsets" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.#ctor">
            <summary>
                Construct an empty subsets collection
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.UnionWith(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Modifies the current set so that it contains all elements that are present in both the current set and in the
                specified collection.
            </summary>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
            <exception cref="T:LibLSLCC.LibraryData.LSLInvalidSubsetNameException">
                Thrown if the UnionWith operation causes a subset name that does not match the pattern ([a-zA-Z]+[a-zA-Z_0-9\\-]*)
                to be added to the subset collection.
            </exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.IntersectWith(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Modifies the current set so that it contains only elements that are also in a specified collection.
            </summary>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.ExceptWith(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Removes all elements in the specified collection from the current set.
            </summary>
            <param name="other">The collection of items to remove from the set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.SymmetricExceptWith(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Modifies the current set so that it contains only elements that are present either in the current set or in the
                specified collection, but not both.
            </summary>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.IsSubsetOf(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Determines whether a set is a subset of a specified collection.
            </summary>
            <returns>
                true if the current set is a subset of <paramref name="other" />; otherwise, false.
            </returns>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.IsSupersetOf(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Determines whether the current set is a superset of a specified collection.
            </summary>
            <returns>
                true if the current set is a superset of <paramref name="other" />; otherwise, false.
            </returns>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.IsProperSupersetOf(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Determines whether the current set is a proper (strict) superset of a specified collection.
            </summary>
            <returns>
                true if the current set is a proper superset of <paramref name="other" />; otherwise, false.
            </returns>
            <param name="other">The collection to compare to the current set. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.IsProperSubsetOf(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Determines whether the current set is a proper (strict) subset of a specified collection.
            </summary>
            <returns>
                true if the current set is a proper subset of <paramref name="other" />; otherwise, false.
            </returns>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.Overlaps(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Determines whether the current set overlaps with the specified collection.
            </summary>
            <returns>
                true if the current set and <paramref name="other" /> share at least one common element; otherwise, false.
            </returns>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.SetEquals(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Determines whether the current set and the specified collection contain the same elements.
            </summary>
            <returns>
                true if the current set is equal to <paramref name="other" />; otherwise, false.
            </returns>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.Add(System.String)">
            <summary>
                Adds a subset name to the current subset collection and returns a value to indicate if the subset name was
                successfully added.
            </summary>
            <returns>
                true if the subset name is added to the set; false if the subset name is already in the set.
            </returns>
            <param name="subsetName">The subset to add to the set.</param>
            <exception cref="T:LibLSLCC.LibraryData.LSLInvalidSubsetNameException">
                If any of the give subset names don't match the pattern
                ([a-zA-Z]+[a-zA-Z_0-9\\-]*).
            </exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.Clear">
            <summary>
                Clear all subset strings from the collection
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.Contains(System.String)">
            <summary>
                Determines whether the <see cref="T:System.Collections.Generic.ICollection`1" /> contains a specific value.
            </summary>
            <returns>
                true if <paramref name="item" /> is found in the <see cref="T:System.Collections.Generic.ICollection`1" />;
                otherwise, false.
            </returns>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
            <exception cref="T:LibLSLCC.LibraryData.LSLInvalidSubsetNameException">If the given subset name was invalid.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.CopyTo(System.String[],System.Int32)">
            <summary>
                Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1" /> to an
                <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
            <param name="array">
                The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied
                from <see cref="T:System.Collections.Generic.ICollection`1" />. The <see cref="T:System.Array" /> must have
                zero-based indexing.
            </param>
            <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> is less than 0.</exception>
            <exception cref="T:System.ArgumentException">
                The number of elements in the source
                <see cref="T:System.Collections.Generic.ICollection`1" /> is greater than the available space from
                <paramref name="arrayIndex" /> to the end of the destination <paramref name="array" />.
            </exception>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.Count">
            <summary>
                Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
            <returns>
                The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </returns>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.IsReadOnly">
            <summary>
                Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.
            </summary>
            <returns>
                true if the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only; otherwise, false.
            </returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.Remove(System.String)">
            <summary>
                Remove a subset string/name from the collection if it exist, the name you give to this function is not checked for
                validity.
            </summary>
            <param name="subsetName">The subset string/name to remove.</param>
            <returns>True if the subset existed and was removed, False if it did not exist.</returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.GetEnumerator">
            <summary>
                Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
                A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="E:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.OnSubsetAdded">
            <summary>
                Fired when a subset string that does not already exist is added.
            </summary>
        </member>
        <member name="E:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.OnSubsetRemoved">
            <summary>
                Fired when an existing subset string is removed. This is not called
                when clear is called.
            </summary>
        </member>
        <member name="E:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.OnSubsetsChanged">
            <summary>
                Fired when the collection changes at all. Including cleared,
                but only when the collection was not already empty.
            </summary>
        </member>
        <member name="E:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.OnSubsetsCleared">
            <summary>
                Fired when the subset collection is cleared, but only if the collection
                was not empty when it was cleared.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.AddSubsets(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Add multiple subset strings at once to the collection.
            </summary>
            <param name="subsets">Enumerable of the subset strings to add</param>
            <exception cref="T:LibLSLCC.LibraryData.LSLInvalidSubsetNameException">
                Thrown if any of the given subset names do not match the pattern
                ([a-zA-Z]+[a-zA-Z_0-9\\-]*).
            </exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.AddSubsets(System.String)">
            <summary>
                Add multiple subsets at once to the collection by parsing them from CSV.
            </summary>
            <param name="subsets">CSV string of the subset names to add.</param>
            <exception cref="T:LibLSLCC.LibraryData.LSLInvalidSubsetNameException">
                Thrown if any of the given subset names in the CSV string do not match
                the pattern ([a-zA-Z]+[a-zA-Z_0-9\\-]*).
            </exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.OnSubsetAddedEvent(System.String)">
            <summary>
                Fired when a subset string that does not already exist is added.
            </summary>
            <param name="subsetName">The name of the subset added.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.OnSubsetRemovedEvent(System.String)">
            <summary>
                Fired when an existing subset string is removed. This is not called
                when clear is called.
            </summary>
            <param name="subsetName">The name of the subset removed.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.OnSubsetsChangedEvent">
            <summary>
                Fired when the collection changes at all. Including cleared,
                but only when the collection was not already empty.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.OnSubsetsClearedEvent">
            <summary>
                Fired when the subset collection is cleared, but only if the collection
                was not empty when it was cleared.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.SetSubsets(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Clear the current subset strings/names and add all the subset strings from a given enumerable.
            </summary>
            <param name="subsets">The subset strings/names to add to the collection after clearing it.</param>
            <exception cref="T:LibLSLCC.LibraryData.LSLInvalidSubsetNameException">
                Thrown if any of the given subset names do not match the pattern
                ([a-zA-Z]+[a-zA-Z_0-9\\-]*).
            </exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetCollection.SetSubsets(System.String)">
            <summary>
                Clear the current subset strings/names and add all the subset strings parsed from CSV.
            </summary>
            <param name="subsets">The subset strings/names to add to the collection after clearing it.</param>
            <exception cref="T:LibLSLCC.LibraryData.LSLInvalidSubsetNameException">
                Thrown if any of the given subset names in the CSV string do not match
                the pattern ([a-zA-Z]+[a-zA-Z_0-9\\-]*).
            </exception>
        </member>
        <member name="T:LibLSLCC.LibraryData.LSLLibraryDataSubsetNameParser">
            <summary>
                Regex utility for parsing subset lists from the XML attributes in LSL library data documents
                and elsewhere in the library.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetNameParser.ParseSubsets(System.String)">
            <summary>
                Parse a subset list from a string and return all the subset names in an enumerable. <para/>
                Subset names start with characters [a-zA-Z] followed by zero or more of the characters [a-zA-Z_0-9\-] <para/>
                They can be separated into a list of multiple subset names using commas.
            </summary>
            <param name="parse">The comma separated subset list to parse, or a single subset name.</param>
            <exception cref="T:LibLSLCC.LibraryData.LSLInvalidSubsetNameException">
                If a subset name that does not match the pattern
                ([a-zA-Z]+[a-zA-Z_0-9\\-]*) is encountered.
            </exception>
            <returns>Enumerable of parsed names.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="parse"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetNameParser.ThrowIfInvalid(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Throws an LSLInvalidSubsetNameException if any of the subset names in the given collection do not match the pattern
                ([a-zA-Z]+[a-zA-Z_0-9\\-]*)
            </summary>
            <param name="names">An enumerable containing subset names to check.</param>
            <exception cref="T:LibLSLCC.LibraryData.LSLInvalidSubsetNameException">If an invalid subset name is encountered in the enumerable.</exception>
            <returns>an enumerable over <paramref name="names"/>.</returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetNameParser.ThrowIfInvalid(System.String)">
            <summary>
                Throws an LSLInvalidSubsetNameException if a given subset name does not match the pattern
                ([a-zA-Z]+[a-zA-Z_0-9\\-]*)
            </summary>
            <param name="name">A subset name to check.</param>
            <exception cref="T:LibLSLCC.LibraryData.LSLInvalidSubsetNameException">If the given subset name was invalid.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataSubsetNameParser.ValidateSubsetName(System.String)">
            <summary>
                Validates that a single subset name matches the pattern ([a-zA-Z]+[a-zA-Z_0-9\\-]*)
            </summary>
            <param name="name">The string to check for a correct subset name.</param>
            <returns>True if the string is a properly formated subset name.</returns>
        </member>
        <member name="T:LibLSLCC.LibraryData.SerializeConstantSignatureEventArgs">
            <summary>
                EventArgs for <see cref="E:LibLSLCC.LibraryData.LSLLibraryDataXmlSerializer.ReadLibraryConstantDefinition" />
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.SerializeConstantSignatureEventArgs.#ctor(LibLSLCC.LibraryData.LSLLibraryConstantSignature)">
            <summary>
                Constructs the event args around a given <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" /> that was just read.
            </summary>
            <param name="constantSignature">The <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" /> that was just read.</param>
        </member>
        <member name="P:LibLSLCC.LibraryData.SerializeConstantSignatureEventArgs.Signature">
            <summary>
                The <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" /> node that was read.
            </summary>
        </member>
        <member name="T:LibLSLCC.LibraryData.SerializeEventHandlerSignatureEventArgs">
            <summary>
                EventArgs for <see cref="E:LibLSLCC.LibraryData.LSLLibraryDataXmlSerializer.ReadLibraryEventHandlerDefinition" />
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.SerializeEventHandlerSignatureEventArgs.#ctor(LibLSLCC.LibraryData.LSLLibraryEventSignature)">
            <summary>
                Constructs the event args around a given <see cref="T:LibLSLCC.LibraryData.LSLLibraryEventSignature" /> that was just read.
            </summary>
            <param name="eventSignature">The <see cref="T:LibLSLCC.LibraryData.LSLLibraryEventSignature" /> that was just read.</param>
        </member>
        <member name="P:LibLSLCC.LibraryData.SerializeEventHandlerSignatureEventArgs.EventSignature">
            <summary>
                The <see cref="T:LibLSLCC.LibraryData.LSLLibraryEventSignature" /> node that was read.
            </summary>
        </member>
        <member name="T:LibLSLCC.LibraryData.SerializeFunctionSignatureEventArgs">
            <summary>
                EventArgs for <see cref="E:LibLSLCC.LibraryData.LSLLibraryDataXmlSerializer.ReadLibraryFunctionDefinition" />
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.SerializeFunctionSignatureEventArgs.#ctor(LibLSLCC.LibraryData.LSLLibraryFunctionSignature)">
            <summary>
                Constructs the event args around a given <see cref="T:LibLSLCC.LibraryData.LSLLibraryFunctionSignature" /> that was just read.
            </summary>
            <param name="functionSignature">The <see cref="T:LibLSLCC.LibraryData.LSLLibraryFunctionSignature" /> that was just read.</param>
        </member>
        <member name="P:LibLSLCC.LibraryData.SerializeFunctionSignatureEventArgs.FunctionSignature">
            <summary>
                The <see cref="T:LibLSLCC.LibraryData.LSLLibraryFunctionSignature" /> node that was read.
            </summary>
        </member>
        <member name="T:LibLSLCC.LibraryData.SerializeSubsetDescriptionEventArgs">
            <summary>
                EventArgs for <see cref="E:LibLSLCC.LibraryData.LSLLibraryDataXmlSerializer.ReadLibrarySubsetDescription" />
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.SerializeSubsetDescriptionEventArgs.#ctor(LibLSLCC.LibraryData.LSLLibrarySubsetDescription)">
            <summary>
                Constructs the event args around a given <see cref="T:LibLSLCC.LibraryData.LSLLibrarySubsetDescription" /> that was just read.
            </summary>
            <param name="subsetDescription">The <see cref="T:LibLSLCC.LibraryData.LSLLibrarySubsetDescription" /> that was just read.</param>
        </member>
        <member name="P:LibLSLCC.LibraryData.SerializeSubsetDescriptionEventArgs.SubsetDescription">
            <summary>
                The <see cref="T:LibLSLCC.LibraryData.LSLLibrarySubsetDescription" /> node that was read.
            </summary>
        </member>
        <member name="T:LibLSLCC.LibraryData.LSLLibraryDataXmlSerializer">
            <summary>
                An event driven SAX parser for LSL Library data
            </summary>
        </member>
        <member name="F:LibLSLCC.LibraryData.LSLLibraryDataXmlSerializer.RootElementName">
            <summary>
                The root element name used for LSL Library Data XML
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryDataXmlSerializer.CurrentLineInfo">
            <summary>
                Info about the current XML line as parsing in progress.
            </summary>
        </member>
        <member name="E:LibLSLCC.LibraryData.LSLLibraryDataXmlSerializer.ReadLibraryFunctionDefinition">
            <summary>
                This event is fired when a function definition has been retrieved from XML markup.
            </summary>
        </member>
        <member name="E:LibLSLCC.LibraryData.LSLLibraryDataXmlSerializer.ReadLibraryConstantDefinition">
            <summary>
                This event is fired when a constant definition has been retrieved from XML markup.
            </summary>
        </member>
        <member name="E:LibLSLCC.LibraryData.LSLLibraryDataXmlSerializer.ReadLibraryEventHandlerDefinition">
            <summary>
                This event is fired when an event handler definition has been retrieved from XML markup.
            </summary>
        </member>
        <member name="E:LibLSLCC.LibraryData.LSLLibraryDataXmlSerializer.ReadLibrarySubsetDescription">
            <summary>
                This event is fired when a library subset description has been retrieved from XML markup.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataXmlSerializer.OnReadLibraryFunctionDefinition(LibLSLCC.LibraryData.LSLLibraryFunctionSignature)">
            <summary>
                This event is fired when a function definition has been retrieved from XML markup.
            </summary>
            <param name="sig">The function signature that was parsed from markup.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataXmlSerializer.OnReadLibraryEventHandlerDefinition(LibLSLCC.LibraryData.LSLLibraryEventSignature)">
            <summary>
                This event is fired when an event handler definition has been retrieved from XML markup.
            </summary>
            <param name="sig">The event signature that was parsed from markup.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataXmlSerializer.OnReadLibraryConstantDefinition(LibLSLCC.LibraryData.LSLLibraryConstantSignature)">
            <summary>
                This event is fired when a constant definition has been retrieved from XML markup.
            </summary>
            <param name="sig">The library constant that was parsed from markup.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataXmlSerializer.OnReadLibrarySubsetDescription(LibLSLCC.LibraryData.LSLLibrarySubsetDescription)">
            <summary>
                This event is fired when a library subset description has been retrieved from XML markup.
            </summary>
            <param name="desc">The library subset description that was parsed from markup.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataXmlSerializer.Parse(System.Xml.XmlReader)">
            <summary>
                Starts a parse at the current node in the given XmlReader, the default element name to consume the content of is
                'LSLLibraryData'
            </summary>
            <param name="reader">The XmlReader object to read XML from.</param>
            <exception cref="T:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException">If a syntax error was detected in the Library Data XML.</exception>
            <exception cref="T:System.Xml.XmlException">An error occurred while parsing the XML. </exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataXmlSerializer.WriteXml(LibLSLCC.LibraryData.ILSLLibraryDataProvider,System.Xml.XmlWriter,System.Boolean)">
            <summary>
                Serialize library signature definitions to an XmlWriter object
            </summary>
            <param name="dataProvider">The data provider to serialize.</param>
            <param name="writer">The XmlWriter object to serialize to.</param>
            <param name="writeRootElement">
                Boolean defining whether or not to write a root element to the stream that houses the
                signatures, or to just write the signatures without putting them in a root element.
            </param>
            <exception cref="T:System.InvalidOperationException"><paramref name="writer" /> is closed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="dataProvider"/> or <paramref see="writer"/> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.LibraryData.LSLLibrarySubsetDescription">
            <summary>
                Represents a description for a named library subset.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibrarySubsetDescription.#ctor(System.String,System.String,System.String)">
            <summary>
                Construct a description for a subset by giving the subset name, and a user friendly name associated with the
                subset.
                Optionally you can provide a description string describing the subset.
            </summary>
            <param name="subsetName">The subset name.</param>
            <param name="friendlyName">A user friendly name for the subset.</param>
            <param name="description">Optional description string.</param>
            <exception cref="T:LibLSLCC.LibraryData.LSLInvalidSubsetNameException">
                If the given subset name does not match the pattern
                ([a-zA-Z]+[a-zA-Z_0-9\\-]*).
            </exception>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibrarySubsetDescription.Subset">
            <summary>
                The name of the subset this subset description contains information about.
            </summary>
            <exception cref="T:LibLSLCC.LibraryData.LSLInvalidSubsetNameException">
                If the given subset name does not match the pattern
                ([a-zA-Z]+[a-zA-Z_0-9\\-]*).
            </exception>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibrarySubsetDescription.FriendlyName">
            <summary>
                The friendly name to associate with the subset.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibrarySubsetDescription.Description">
            <summary>
                The description string for the subset.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibrarySubsetDescription.GetSchema">
            <summary>
                Implementors of IXmlSerializable should return null from this function.
            </summary>
            <returns>null</returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibrarySubsetDescription.ReadXml(System.Xml.XmlReader)">
            <summary>
                Generates an object from its XML representation.
            </summary>
            <param name="reader">The <see cref="T:System.Xml.XmlReader" /> stream from which the object is deserialized. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibrarySubsetDescription.WriteXml(System.Xml.XmlWriter)">
            <summary>
                Converts an object into its XML representation.
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> stream to which the object is serialized. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="writer"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibrarySubsetDescription.FromXmlFragment(System.Xml.XmlReader)">
            <summary>
                Reads a library subset description object from an XML fragment.
            </summary>
            <param name="fragment">The XML reader containing the fragment to read.</param>
            <returns>The parsed LSLLibrarySubsetDescription object.</returns>
        </member>
        <member name="T:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException">
            <summary>
                Exception thrown by <see cref="M:LibLSLCC.LibraryData.LSLLibraryDataXmlSerializer.Parse(System.Xml.XmlReader)" /> and the XML reading methods of
                <see cref="T:LibLSLCC.LibraryData.LSLXmlLibraryDataProvider" />
                when there are syntax errors in XML library data.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException" /> class.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException" /> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException.#ctor(System.String,System.Exception)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException" /> class.
            </summary>
            <param name="message">The message.</param>
            <param name="inner">The inner exception.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException.#ctor(System.Int32,System.String,System.Exception)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException" /> class.
            </summary>
            <param name="lineNumber">The line number the syntax error occurred on.</param>
            <param name="message">The message.</param>
            <param name="inner">The inner exception.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException" /> class.
            </summary>
            <param name="info">
                The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object
                data about the exception being thrown.
            </param>
            <param name="context">
                The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual
                information about the source or destination.
            </param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException.#ctor(System.Int32,System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException" /> class.
            </summary>
            <param name="lineNumber">The line number.</param>
            <param name="message">The message.</param>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException.LineNumber">
            <summary>
                The line number on which the exception occurred.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with
                information about the exception.
            </summary>
            <param name="info">
                The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the
                exception being thrown.
            </param>
            <param name="context">
                The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual
                information about the source or destination.
            </param>
            <exception cref="T:System.ArgumentNullException">
                The <paramref name="info" /> parameter is a null reference (Nothing in Visual Basic).
            </exception>
            <filterpriority>2</filterpriority>
            <PermissionSet>
                <IPermission
                    class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
                    version="1" Read="*AllFiles*" PathDiscovery="*AllFiles*" />
                <IPermission
                    class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
                    version="1" Flags="SerializationFormatter" />
            </PermissionSet>
        </member>
        <member name="T:LibLSLCC.LibraryData.Reflection.ILSLConstantFilter">
            <summary>
                Allows modification of a constant signature after its basic information has been serialized, before its returned.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.ILSLConstantFilter.PreFilter(LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.PropertyInfo)">
            <summary>
                Allows <see cref="T:System.Reflection.PropertyInfo" /> objects to be prematurely filtered from de-serialization output.  Returns
                <c>true</c> if the <see cref="T:System.Reflection.PropertyInfo" /> should be filtered.
            </summary>
            <param name="serializer">The <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> this add-on belongs to.</param>
            <param name="info">The <see cref="T:System.Reflection.PropertyInfo" /> object we may want to filter from the output.</param>
            <returns><c>true</c> if the property needs to be filtered from the results.</returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.ILSLConstantFilter.PreFilter(LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.FieldInfo)">
            <summary>
                Allows <see cref="T:System.Reflection.FieldInfo" /> objects to be prematurely filtered from de-serialization output.  Returns
                <c>true</c> if the <see cref="T:System.Reflection.MethodInfo" /> should be filtered.
            </summary>
            <param name="serializer">The <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> this add-on belongs to.</param>
            <param name="info">The <see cref="T:System.Reflection.PropertyInfo" /> object we may want to filter from the output.</param>
            <returns><c>true</c> if the field needs to be filtered from the results.</returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.ILSLConstantFilter.MutateSignature(LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.PropertyInfo,LibLSLCC.LibraryData.LSLLibraryConstantSignature)">
            <summary>
                Allows modification of a constant signature after its basic information has been serialized from an objects
                Property, before its returned.
            </summary>
            <param name="serializer">The <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> this add-on belongs to.</param>
            <param name="info">The <see cref="T:System.Reflection.PropertyInfo" /> object the library constant signature was serialized from.</param>
            <param name="signature">The signature.</param>
            <returns><c>true</c> if the constant needs to be filtered from the results.</returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.ILSLConstantFilter.MutateSignature(LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.FieldInfo,LibLSLCC.LibraryData.LSLLibraryConstantSignature)">
            <summary>
                Allows modification of a constant signature after its basic information has been serialized from an objects
                Property, before its returned.
            </summary>
            <param name="serializer">The <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> this add-on belongs to.</param>
            <param name="info">The <see cref="T:System.Reflection.FieldInfo" /> object the library constant signature was serialized from.</param>
            <param name="signature">The signature.</param>
            <returns><c>true</c> if the constant needs to be filtered from the results.</returns>
        </member>
        <member name="T:LibLSLCC.LibraryData.Reflection.ILSLParamTypeConverter">
            <summary>
                Interface for converting .NET runtime <see cref="T:System.Reflection.ParameterInfo" />'s into their equivalent <see cref="T:LibLSLCC.CodeValidator.LSLType" />.
                This is used to convert the parameter types encountered in reflected .NET methods.
                This interface is used with <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> and the library data attributes.
            </summary>
            <seealso cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ConstantTypeConverter" />
            <seealso cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ReturnTypeConverter" />
            <seealso cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ParamTypeConverter" />
            <seealso cref="P:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute.TypeConverter" />
            <seealso cref="P:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute.ReturnTypeConverter" />
            <seealso cref="P:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute.ParamTypeConverter" />
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.ILSLParamTypeConverter.ConvertParameter(System.Reflection.ParameterInfo,System.Type,LibLSLCC.CodeValidator.LSLType@)">
            <summary>
                Converts the specified <see cref="T:System.Reflection.ParameterInfo" /> into its corresponding <see cref="T:LibLSLCC.CodeValidator.LSLType" />
            </summary>
            <param name="parameterInfo">Runtime <see cref="T:System.Reflection.ParameterInfo" /> for converting to an <see cref="T:LibLSLCC.CodeValidator.LSLType" />.</param>
            <param name="basicType">
                The basic type of the parameter, this will be the parameter arrays base type if the parameter
                is variadic.
            </param>
            <param name="outType">Resulting <see cref="T:LibLSLCC.CodeValidator.LSLType" /> from the conversion.</param>
            <returns><c>true</c> if the conversion succeeded, <c>false</c> if it failed.</returns>
        </member>
        <member name="T:LibLSLCC.LibraryData.Reflection.ILSLReturnTypeConverter">
            <summary>
                Interface for converting .NET runtime <see cref="T:System.Reflection.MethodInfo" />'s return type into its equivalent
                <see cref="T:LibLSLCC.CodeValidator.LSLType" />.
                This is used to convert the return types encountered in reflected .NET methods.
                This interface is used with <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> and the library data attributes.
            </summary>
            <seealso cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ConstantTypeConverter" />
            <seealso cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ReturnTypeConverter" />
            <seealso cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ParamTypeConverter" />
            <seealso cref="P:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute.TypeConverter" />
            <seealso cref="P:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute.ReturnTypeConverter" />
            <seealso cref="P:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute.ParamTypeConverter" />
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.ILSLReturnTypeConverter.ConvertReturn(System.Reflection.MethodInfo,LibLSLCC.CodeValidator.LSLType@)">
            <summary>
                Converts the specified <see cref="T:System.Reflection.MethodInfo" /> return type into its corresponding <see cref="T:LibLSLCC.CodeValidator.LSLType" />
            </summary>
            <param name="methodInfo">Runtime <see cref="T:System.Type" /> to convert.</param>
            <param name="outType">Resulting <see cref="T:LibLSLCC.CodeValidator.LSLType" /> from the conversion.</param>
            <returns><c>true</c> if the conversion succeeded, <c>false</c> if it failed.</returns>
        </member>
        <member name="T:LibLSLCC.LibraryData.Reflection.LSLMultiConstantFilter">
            <summary>
                Allows multiple <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLConstantFilter" /> objects to participate in filtering/mutating constant
                signatures de-serialized from runtime types using <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" />.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLMultiConstantFilter.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLMultiMethodFilter" /> class.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLMultiConstantFilter.Filters">
            <summary>
                A modifiable collection of all <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLConstantFilter" /> objects participating in filtering.
            </summary>
            <value>
                The <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLConstantFilter" />'s being used to filter.
            </value>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLMultiConstantFilter.GetEnumerator">
            <summary>
                Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
                A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLMultiConstantFilter.PreFilter(LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.PropertyInfo)">
            <summary>
                Allows <see cref="T:System.Reflection.PropertyInfo" /> objects to be prematurely filtered from de-serialization output.  Returns
                <c>true</c> if the <see cref="T:System.Reflection.PropertyInfo" /> should be filtered.
            </summary>
            <param name="serializer">The <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> this add-on belongs to.</param>
            <param name="info">The <see cref="T:System.Reflection.PropertyInfo" /> object we may want to filter from the output.</param>
            <returns><c>true</c> if the property needs to be filtered from the results.</returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLMultiConstantFilter.PreFilter(LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.FieldInfo)">
            <summary>
                Allows <see cref="T:System.Reflection.FieldInfo" /> objects to be prematurely filtered from de-serialization output.  Returns
                <c>true</c> if the <see cref="T:System.Reflection.MethodInfo" /> should be filtered.
            </summary>
            <param name="serializer">The <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> this add-on belongs to.</param>
            <param name="info">The <see cref="T:System.Reflection.PropertyInfo" /> object we may want to filter from the output.</param>
            <returns><c>true</c> if the field needs to be filtered from the results.</returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLMultiConstantFilter.MutateSignature(LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.PropertyInfo,LibLSLCC.LibraryData.LSLLibraryConstantSignature)">
            <summary>
                Allows modification of a constant signature after its basic information has been serialized from an objects
                Property, before its returned.
            </summary>
            <param name="serializer">The <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> this add-on belongs to.</param>
            <param name="info">The <see cref="T:System.Reflection.PropertyInfo" /> object the library constant signature was serialized from.</param>
            <param name="signature">The signature.</param>
            <returns><c>true</c> if the constant needs to be filtered from the results.</returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLMultiConstantFilter.MutateSignature(LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.FieldInfo,LibLSLCC.LibraryData.LSLLibraryConstantSignature)">
            <summary>
                Allows modification of a constant signature after its basic information has been serialized from an objects
                Property, before its returned.
            </summary>
            <param name="serializer">The <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> this add-on belongs to.</param>
            <param name="info">The <see cref="T:System.Reflection.FieldInfo" /> object the library constant signature was serialized from.</param>
            <param name="signature">The signature.</param>
            <returns><c>true</c> if the constant needs to be filtered from the results.</returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLMultiConstantFilter.Add(LibLSLCC.LibraryData.Reflection.LSLMultiConstantFilter)">
            <summary>
                Add's a filter to this multi filter, this here so list initializer syntax can be utilized to build a multi filter.
            </summary>
            <param name="filter">The filter to add.</param>
        </member>
        <member name="T:LibLSLCC.LibraryData.Reflection.ILSLMethodFilter">
            <summary>
                Allows modification of a function signature after its basic information has been serialized, before its returned.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.ILSLMethodFilter.PreFilter(LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.MethodInfo)">
            <summary>
                Allows <see cref="T:System.Reflection.MethodInfo" /> objects to be prematurely filtered from de-serialization output.  Returns
                <c>true</c> if the <see cref="T:System.Reflection.MethodInfo" /> should be filtered.
            </summary>
            <param name="serializer">The <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> this add-on belongs to.</param>
            <param name="info">The <see cref="T:System.Reflection.MethodInfo" /> object we may want to filter from the output.</param>
            <returns><c>true</c> if the method needs to be filtered from the results.</returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.ILSLMethodFilter.MutateSignature(LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.MethodInfo,LibLSLCC.LibraryData.LSLLibraryFunctionSignature)">
            <summary>
                Allows modification a function signature after its basic information has been serialized, before its returned.
            </summary>
            <param name="serializer">The <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> this add-on belongs to.</param>
            <param name="info">The <see cref="T:System.Reflection.MethodInfo" /> object the library function signature was serialized from.</param>
            <param name="signature">The signature.</param>
            <returns><c>true</c> if the method needs to be filtered from the results.</returns>
        </member>
        <member name="T:LibLSLCC.LibraryData.Reflection.ILSLConstantTypeConverter">
            <summary>
                Interface for converting .NET runtime <see cref="T:System.Reflection.FieldInfo" /> or <see cref="T:System.Reflection.PropertyInfo" /> into its equivalent
                <see cref="T:LibLSLCC.CodeValidator.LSLType" />.
                This is used to convert the declaration type of reflected class fields/properties.
                This interface is used with <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> and the library data attributes.
            </summary>
            <seealso cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ConstantTypeConverter" />
            <seealso cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ReturnTypeConverter" />
            <seealso cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ParamTypeConverter" />
            <seealso cref="P:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute.TypeConverter" />
            <seealso cref="P:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute.ReturnTypeConverter" />
            <seealso cref="P:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute.ParamTypeConverter" />
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.ILSLConstantTypeConverter.ConvertField(System.Reflection.FieldInfo,LibLSLCC.CodeValidator.LSLType@)">
            <summary>
                Converts the specified <see cref="T:System.Reflection.FieldInfo" /> into its corresponding <see cref="T:LibLSLCC.CodeValidator.LSLType" />
            </summary>
            <param name="fieldInfo">Runtime <see cref="T:System.Reflection.FieldInfo" /> to convert.</param>
            <param name="outType">Resulting <see cref="T:LibLSLCC.CodeValidator.LSLType" /> from the conversion.</param>
            <returns><c>true</c> if the conversion succeeded, <c>false</c> if it failed.</returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.ILSLConstantTypeConverter.ConvertProperty(System.Reflection.PropertyInfo,LibLSLCC.CodeValidator.LSLType@)">
            <summary>
                Converts the specified <see cref="T:System.Reflection.PropertyInfo" /> into its corresponding <see cref="T:LibLSLCC.CodeValidator.LSLType" />
            </summary>
            <param name="fieldInfo">Runtime <see cref="T:System.Reflection.PropertyInfo" /> to convert.</param>
            <param name="outType">Resulting <see cref="T:LibLSLCC.CodeValidator.LSLType" /> from the conversion.</param>
            <returns><c>true</c> if the conversion succeeded, <c>false</c> if it failed.</returns>
        </member>
        <member name="T:LibLSLCC.LibraryData.Reflection.ILSLValueStringConverter">
            <summary>
                Interface for converting property/field values into strings assignable to
                <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" />.
                This interface is for types that are assigned to the attribute property
                <see cref="P:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute.ValueStringConverter" /> using the <c>typeof</c> operator.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.ILSLValueStringConverter.ConvertProperty(System.Reflection.PropertyInfo,LibLSLCC.CodeValidator.LSLType,System.Object,System.String@)">
            <summary>
                Convert the value taken from a property with the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute" /> into
                something that is valid to assign to <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" /> given the specified
                <see cref="T:LibLSLCC.CodeValidator.LSLType" /> that is to be assigned to <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" />.
            </summary>
            <param name="propertyInfo">The <see cref="T:System.Reflection.PropertyInfo" /> of the property the value was taken from.</param>
            <param name="constantType">
                The <see cref="T:LibLSLCC.CodeValidator.LSLType" /> being assigned to <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" />
                .
            </param>
            <param name="fieldValue">The value taking from the property or field with an <see cref="T:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute" />.</param>
            <param name="valueString">
                The string to assign to <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" />.
                this should be a string that <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" /> is able to parse for the given
                <see cref="T:LibLSLCC.CodeValidator.LSLType" />.
                You should not assign <c>null</c> to <paramref name="valueString" /> if you intend to return <c>true</c>, this is
                invalid and the serializer will throw an exception.
            </param>
            <returns>
                True if the conversion succeeded, false if it did not.
            </returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.ILSLValueStringConverter.ConvertField(System.Reflection.FieldInfo,LibLSLCC.CodeValidator.LSLType,System.Object,System.String@)">
            <summary>
                Convert the value taken from a field with the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute" /> into
                something that is valid to assign to <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" /> given the specified
                <see cref="T:LibLSLCC.CodeValidator.LSLType" /> that is to be assigned to <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" />.
            </summary>
            <param name="fieldInfo">The <see cref="T:System.Reflection.FieldInfo" /> of the field the value was taken from.</param>
            <param name="constantType">
                The <see cref="T:LibLSLCC.CodeValidator.LSLType" /> being assigned to <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" />
                .
            </param>
            <param name="fieldValue">The value taking from the property or field with an <see cref="T:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute" />.</param>
            <param name="valueString">
                The string to assign to <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" />.
                this should be a string that <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" /> is able to parse for the given
                <see cref="T:LibLSLCC.CodeValidator.LSLType" />.
                You should not assign <c>null</c> to <paramref name="valueString" /> if you intend to return <c>true</c>, this is
                invalid and the serializer will throw an exception.
            </param>
            <returns>
                True if the conversion succeeded, false if it did not.
            </returns>
        </member>
        <member name="T:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute">
            <summary>
                Optional Attribute for explicitly exposing methods to <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" />.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute.#ctor">
            <summary>
                Initializes the attribute without an explicit return type.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute.#ctor(LibLSLCC.CodeValidator.LSLType)">
            <summary>
                Initializes the attribute with an explicit return type.
            </summary>
            <param name="returnType">Type of the return.</param>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute.ReturnType">
            <summary>
                The <see cref="T:LibLSLCC.CodeValidator.LSLType" /> returned by the function being attributed.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute.ReturnTypeConverter">
            <summary>
                <para>
                    Gets or sets the <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLReturnTypeConverter" /> that is used in the case that no <see cref="T:System.Type" /> is
                    given for <see cref="P:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute.ReturnType" />, it takes the method return type and converts it to an
                    <see cref="T:LibLSLCC.CodeValidator.LSLType" />.
                    You cannot set both an explicit <see cref="P:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute.ReturnType" /> and a <see cref="P:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute.ReturnTypeConverter" /> or the
                    serializer will throw an exception.
                    This property is only optional if the class is using a defined
                    <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ReturnTypeConverter" /> or
                    <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ReturnTypeConverter" /> is set.
                    Setting this property will override both <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ReturnTypeConverter" />
                    and <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ReturnTypeConverter" />.
                </para>
            </summary>
            <value>
                The type converter which should derive from <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLReturnTypeConverter" />.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute.ParamTypeConverter">
            <summary>
                <para>
                    Gets or sets the <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLParamTypeConverter" /> that is used in the case that no
                    <see cref="T:LibLSLCC.LibraryData.Reflection.LSLParamAttribute" /> is applied to a given method parameter, it takes the parameter type and
                    converts it to an <see cref="T:LibLSLCC.CodeValidator.LSLType" />.
                    Parameters that do not have an <see cref="T:LibLSLCC.LibraryData.Reflection.LSLParamAttribute" /> applied to them will use this converter to
                    convert the .NET parameter type into an <see cref="T:LibLSLCC.CodeValidator.LSLType" />.
                    This property is only optional if the class is using a defined
                    <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ParamTypeConverter" /> or
                    <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ParamTypeConverter" /> is set.
                    Setting this property will override both <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ParamTypeConverter" />
                    and <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ParamTypeConverter" />.
                </para>
            </summary>
            <value>
                The type converter which should derive from <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLParamTypeConverter" />.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute.Deprecated">
            <summary>
                Gets a value indicating what serialized <see cref="T:LibLSLCC.LibraryData.LSLLibraryFunctionSignature" /> objects should have
                <see cref="P:LibLSLCC.LibraryData.LSLLibraryFunctionSignature.Deprecated" /> set to.
            </summary>
            <value>
                The value to set <see cref="P:LibLSLCC.LibraryData.LSLLibraryFunctionSignature.Deprecated" /> to.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute.ModInvoke">
            <summary>
                Gets a value indicating what serialized <see cref="T:LibLSLCC.LibraryData.LSLLibraryFunctionSignature" /> objects should have
                <see cref="P:LibLSLCC.LibraryData.LSLLibraryFunctionSignature.ModInvoke" /> set to.
            </summary>
            <value>
                The value to set <see cref="P:LibLSLCC.LibraryData.LSLLibraryFunctionSignature.ModInvoke" /> to.
            </value>
        </member>
        <member name="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataAttributeException">
            <summary>
                Thrown when a problem with a library data reflection attribute is discovered.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLibraryDataAttributeException.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataAttributeException" /> class.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLibraryDataAttributeException.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataAttributeException" /> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLibraryDataAttributeException.#ctor(System.String,System.Exception)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataAttributeException" /> class.
            </summary>
            <param name="message">The message.</param>
            <param name="inner">The inner.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLibraryDataAttributeException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataAttributeException" /> class.
            </summary>
            <param name="info">
                The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object
                data about the exception being thrown.
            </param>
            <param name="context">
                The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual
                information about the source or destination.
            </param>
        </member>
        <member name="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute">
            <summary>
                Optional Attribute for specifying class wide type converters and the constant ValueStringConverter that overrides
                the one's in <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" />.
                This is to be used on classes that contain methods and fields/properties that are to be reflected as library data
                objects.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ReturnTypeConverter">
            <summary>
                Gets or sets the <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLReturnTypeConverter" /> used to convert the return types of methods in a given
                class to <see cref="T:LibLSLCC.CodeValidator.LSLType" />'s.
                The return type converter defined in the class attribute can be overridden per method by
                <see cref="P:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute.ReturnTypeConverter" />.
                This property will override <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ReturnTypeConverter" /> if it is set.
            </summary>
            <value>
                The return type converter, should derive from <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLReturnTypeConverter" />.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ParamTypeConverter">
            <summary>
                Gets or sets the <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLParamTypeConverter" /> used to convert the parameter types of methods in a given
                class to <see cref="T:LibLSLCC.CodeValidator.LSLType" />'s.
                The parameter type converter defined in the class attribute can be overridden per method by
                <see cref="P:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute.ParamTypeConverter" />.
                This property will override <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ParamTypeConverter" /> if it is set.
            </summary>
            <value>
                The parameter type converter, should derive from <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLParamTypeConverter" />.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ConstantTypeConverter">
            <summary>
                Gets or sets the <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLConstantTypeConverter" /> used to convert the types of fields/properties in a given
                class to <see cref="T:LibLSLCC.CodeValidator.LSLType" />'s.
                The constant type converter defined in the class attribute can be overridden per method by
                <see cref="P:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute.TypeConverter" />.
                This property will override <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ConstantTypeConverter" /> if it is set.
            </summary>
            <value>
                The parameter type converter, should derive from <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLConstantTypeConverter" />.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ValueStringConverter">
            <summary>
                Gets or sets the <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLValueStringConverter" /> used to convert the values taken from fields/properties in
                given class to strings that can be parsed by <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" />.
                The value string converter defined in the class attribute can be overridden per field/property by
                <see cref="P:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute.ValueStringConverter" />.
                This property will override <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ValueStringConverter" /> if it is set.
            </summary>
            <value>
                The value string converter, should derive from <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLValueStringConverter" />.
            </value>
        </member>
        <member name="T:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute">
            <summary>
                Optional attribute for exposing properties and fields to <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> without
                having to map types.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute.#ctor(LibLSLCC.CodeValidator.LSLType)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute" /> class.
            </summary>
            <param name="type">The <see cref="T:LibLSLCC.CodeValidator.LSLType" /> of the constant.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute" /> class.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute.Type">
            <summary>
                Gets the <see cref="T:LibLSLCC.CodeValidator.LSLType" /> of the constant as specified by the attribute.
            </summary>
            <value>
                The <see cref="T:LibLSLCC.CodeValidator.LSLType" /> of the constant.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute.Expand">
            <summary>
                Gets a value indicating what serialized <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" /> objects should have
                <see cref="P:LibLSLCC.LibraryData.LSLLibraryConstantSignature.Expand" /> set to.
            </summary>
            <value>
                The value to set <see cref="P:LibLSLCC.LibraryData.LSLLibraryConstantSignature.Expand" /> to.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute.Deprecated">
            <summary>
                Gets a value indicating what serialized <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" /> objects should have
                <see cref="P:LibLSLCC.LibraryData.LSLLibraryConstantSignature.Deprecated" /> set to.
            </summary>
            <value>
                The value to set <see cref="P:LibLSLCC.LibraryData.LSLLibraryConstantSignature.Deprecated" /> to.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute.ValueString">
            <summary>
                Gets or sets the value string to be assigned to <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" /> if no
                <see cref="P:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute.ValueStringConverter" /> type is present.
                You cannot have both an explicit <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" /> and
                <see cref="P:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute.ValueStringConverter" /> at the same time, this will cause an exception from the serializer.
            </summary>
            <value>
                The value string to be assigned to <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" />.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute.ValueStringConverter">
            <summary>
                <para>
                    Gets or sets the value string converter <see cref="P:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute.Type" />, this type should derive from
                    <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLValueStringConverter" /> or you will get exceptions from the serializer.
                    The value string converter is responsible for converting field/property values into something that is parsable
                    by <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" />.
                    You cannot have both an explicit <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" /> and
                    <see cref="P:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute.ValueStringConverter" /> at the same time, this will cause an exception from the serializer.
                    This property is only optional if the class is using a defined
                    <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ValueStringConverter" /> or
                    <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ValueStringConverter" /> is set.
                    Setting this property will override both
                    <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ValueStringConverter" /> and
                    <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ValueStringConverter" />.
                </para>
            </summary>
            <value>
                The value string converter <see cref="P:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute.Type" /> which sould derive from <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLValueStringConverter" />.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute.TypeConverter">
            <summary>
                <para>
                    Gets or sets the <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLConstantTypeConverter" /> that is used in the case that no <see cref="P:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute.Type" />
                    is given, it takes the property type and converts it to an <see cref="T:LibLSLCC.CodeValidator.LSLType" />.
                    This property is only optional if the class is using a defined
                    <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ConstantTypeConverter" /> or
                    <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ConstantTypeConverter" /> is set.
                    Setting this property will override both
                    <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ConstantTypeConverter" /> and
                    <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ConstantTypeConverter" />.
                </para>
            </summary>
            <value>
                The type converter which should derive from <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLConstantTypeConverter" />.
            </value>
        </member>
        <member name="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionException">
            <summary>
                Base class for exceptions thrown by the de-serialization methods in
                <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" />
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionException.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionException" /> class.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionException.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionException" /> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionException.#ctor(System.String,System.Exception)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionException" /> class.
            </summary>
            <param name="message">The message.</param>
            <param name="inner">The inner.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionException" /> class.
            </summary>
            <param name="info">
                The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object
                data about the exception being thrown.
            </param>
            <param name="context">
                The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual
                information about the source or destination.
            </param>
        </member>
        <member name="T:LibLSLCC.LibraryData.Reflection.AutoFilteredMethodEventArgs">
            <summary>
                EventArgs for FilterMethod events in <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" />.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.AutoFilteredMethodEventArgs.#ctor(System.Reflection.MethodInfo)">
            <summary>
                Construct a filtered method event args object given the filtered <see cref="T:System.Reflection.MethodInfo" />.
            </summary>
            <param name="member">The <see cref="T:System.Reflection.MethodInfo" /> that was filtered.</param>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.AutoFilteredMethodEventArgs.Member">
            <summary>
                The method that was filtered.
            </summary>
        </member>
        <member name="T:LibLSLCC.LibraryData.Reflection.AutoFilteredConstantEventArgs">
            <summary>
                EventArg for FilterConstant events in <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" />.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.AutoFilteredConstantEventArgs.#ctor(System.Reflection.MemberInfo)">
            <summary>
                Construct a filtered constant event args object given the filtered <see cref="T:System.Reflection.MemberInfo" />.
            </summary>
            <param name="member">The <see cref="T:System.Reflection.MemberInfo" /> that was filtered.</param>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.AutoFilteredConstantEventArgs.Member">
            <summary>
                The member that was filtered.
            </summary>
        </member>
        <member name="T:LibLSLCC.LibraryData.Reflection.AutoFilteredConstantFieldEventArgs">
            <summary>
                EventArg for FilterConstantField events in <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" />.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.AutoFilteredConstantFieldEventArgs.#ctor(System.Reflection.FieldInfo)">
            <summary>
                Construct a filtered constant event args object given the filtered <see cref="T:System.Reflection.FieldInfo" />.
            </summary>
            <param name="member">The <see cref="T:System.Reflection.FieldInfo" /> that was filtered.</param>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.AutoFilteredConstantFieldEventArgs.Member">
            <summary>
                The member that was filtered.
            </summary>
        </member>
        <member name="T:LibLSLCC.LibraryData.Reflection.AutoFilteredConstantPropertyEventArgs">
            <summary>
                EventArg for FilterConstantProperty events in <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" />.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.AutoFilteredConstantPropertyEventArgs.#ctor(System.Reflection.PropertyInfo)">
            <summary>
                Construct a filtered constant event args object given the filtered <see cref="T:System.Reflection.PropertyInfo" />.
            </summary>
            <param name="member">The <see cref="T:System.Reflection.PropertyInfo" /> that was filtered.</param>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.AutoFilteredConstantPropertyEventArgs.Member">
            <summary>
                The member that was filtered.
            </summary>
        </member>
        <member name="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer">
            <summary>
                Serializes library signature objects from CSharp types using runtime reflection
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> class.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.MethodFilter">
            <summary>
                Gets or sets the method filter which can pre-filter <see cref="T:System.Reflection.MethodInfo" /> objects from the reflection search
                results.
            </summary>
            <value>
                The method filter.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ParameterFilter">
            <summary>
                Gets or sets the parameter filter, which can filter <see cref="T:System.Reflection.ParameterInfo" /> objects out of a function
                definition generated by the serializer.
                This function should return <c>true</c> if a parameter is to be filtered out of the generated
                <see cref="T:LibLSLCC.LibraryData.LSLLibraryFunctionSignature" />.
            </summary>
            <value>
                The parameter filter.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ConstantFilter">
            <summary>
                Gets or sets the constant filter which can pre-filter <see cref="T:System.Reflection.FieldInfo" /> and <see cref="T:System.Reflection.PropertyInfo" />
                objects from the reflection search results.
            </summary>
            <value>
                The constant filter.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.PropertyBindingFlags">
            <summary>
                Gets or sets the reflection <see cref="T:System.Reflection.BindingFlags" /> used to search for class properties.
            </summary>
            <value>
                The property binding flags.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.FieldBindingFlags">
            <summary>
                Gets or sets the reflection <see cref="T:System.Reflection.BindingFlags" /> used to search for class fields.
            </summary>
            <value>
                The field binding flags.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.MethodBindingFlags">
            <summary>
                Gets or sets the reflection <see cref="T:System.Reflection.BindingFlags" /> used to search for class methods.
            </summary>
            <value>
                The method binding flags.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.FilterMethodsWithUnmappedReturnTypes">
            <summary>
                Gets or sets a value indicating whether to filter methods lacking an <see cref="T:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute" /> where the
                return
                type of the method cannot be converted to an <see cref="T:LibLSLCC.CodeValidator.LSLType" /> by the implementation of
                <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLReturnTypeConverter" />
                assigned to <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ReturnTypeConverter" />.  If set to <c>false</c> an
                <see cref="T:LibLSLCC.LibraryData.Reflection.LSLReflectionTypeMappingException" /> will
                be thrown when a return type is found to be un-convertible.
            </summary>
            <value>
                <c>true</c> to filter reflected methods lacking an <see cref="T:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute" /> where the return type is
                un-convertible by
                <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ReturnTypeConverter" />;  otherwise, <c>false</c> to throw an
                <see cref="T:LibLSLCC.LibraryData.Reflection.LSLReflectionTypeMappingException" />.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.FilterMethodsWithUnmappedParamTypes">
            <summary>
                Gets or sets a value indicating whether to filter methods lacking an <see cref="T:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute" /> where one
                or more parameter
                types of the method cannot be converted to an <see cref="T:LibLSLCC.CodeValidator.LSLType" /> by the implementation of
                <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLParamTypeConverter" />
                assigned to <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ParamTypeConverter" />.  If set to <c>false</c> an
                <see cref="T:LibLSLCC.LibraryData.Reflection.LSLReflectionTypeMappingException" /> will
                be thrown when a parameter type is found to be un-convertible.
            </summary>
            <value>
                <c>true</c> to filter reflected methods lacking an <see cref="T:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute" /> where a parameter type is
                un-convertible by
                <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ParamTypeConverter" />;  otherwise, <c>false</c> to throw an
                <see cref="T:LibLSLCC.LibraryData.Reflection.LSLReflectionTypeMappingException" />.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.FilterConstantsWithUnmappedTypes">
            <summary>
                Gets or sets a value indicating whether to filter field/properties lacking an <see cref="T:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute" />
                where the declaration
                type of the class member cannot be converted to an <see cref="T:LibLSLCC.CodeValidator.LSLType" /> by the implementation of
                <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLConstantTypeConverter" />
                assigned to <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ConstantTypeConverter" />.  If set to <c>false</c> an
                <see cref="T:LibLSLCC.LibraryData.Reflection.LSLReflectionTypeMappingException" /> will
                be thrown when a field/property type is found to be un-convertible.
            </summary>
            <value>
                <c>true</c> to filter reflected fields/properties lacking an <see cref="T:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute" /> where a declared
                type is
                un-convertible by <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ConstantTypeConverter" />;  otherwise, <c>false</c> to throw an
                <see cref="T:LibLSLCC.LibraryData.Reflection.LSLReflectionTypeMappingException" />.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ValueStringConverter">
            <summary>
                Gets or sets base <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLValueStringConverter" /> to be used when a field or property lacks an
                <see cref="T:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute" /> or
                when <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ValueStringConverter" /> or
                <see cref="P:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute.ValueStringConverter" /> is not specified
                to override it.
            </summary>
            <value>
                The value string converter.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ConstantTypeConverter">
            <summary>
                Gets or sets base <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLConstantTypeConverter" /> to be used when a field or property lacks an
                <see cref="T:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute" /> or
                when <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ConstantTypeConverter" /> or
                <see cref="P:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute.TypeConverter" /> is not specified
                to override it.
            </summary>
            <value>
                The constant type converter.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ReturnTypeConverter">
            <summary>
                Gets or sets base <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLReturnTypeConverter" /> to be used when a method lacks an
                <see cref="T:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute" /> or
                when <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ReturnTypeConverter" /> or
                <see cref="P:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute.ReturnTypeConverter" /> is not specified
                to override it.
            </summary>
            <value>
                The return type converter.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ParamTypeConverter">
            <summary>
                Gets or sets base <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLParamTypeConverter" /> to be used when a method parameter lacks an
                <see cref="T:LibLSLCC.LibraryData.Reflection.LSLParamAttribute" /> or
                when <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataSerializableAttribute.ParamTypeConverter" /> or
                <see cref="P:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute.ParamTypeConverter" /> is not specified
                to override it.
            </summary>
            <value>
                The parameter type converter.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.FilterNullConstants">
            <summary>
                Gets or sets a value indicating whether to filter fields and properties that lack an
                <see cref="T:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute" /> and are declared with/return a <c>null</c> value.
                Instance fields will be considered to have <c>null</c> values if you do not provide an object instance to
                <see cref="M:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.DeSerializeConstants(System.Type,System.Object)" />.
                If a <c>null</c> value is encountered in a field or property that lacks an <see cref="T:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute" /> and
                this is <c>false</c>, an <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionException" /> will be thrown.
            </summary>
            <value>
                <c>true</c> to filter out null field/property values on field's/properties lacking an
                <see cref="T:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute" />; otherwise, <c>false</c> to throw
                <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionException" />.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.FilterInvalidValueStrings">
            <summary>
                Gets or sets a value indicating whether to filter un-attributed fields and properties whose values where converted
                into an invalid/un-parsable
                ValueString by <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ValueStringConverter" />.  This is only effective for properties/fields that lack an
                <see cref="T:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute" />.
                ValueStrings returned from converters for attributed constants are always rigorously checked for errors, an
                <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionException" />
                will be thrown if there is a ValueString parsing error caused by an attributed constant.
            </summary>
            <value>
                <c>true</c> to filter out fields/property's with invalid ValueString's when they are lacking an
                <see cref="T:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute" />;
                otherwise, <c>false</c> to throw <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionException" />.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.FilterValueStringConversionFailures">
            <summary>
                Gets or sets a value indicating whether to filter fields and properties whose values failed to convert into a
                ValueString according to <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ValueStringConverter" />.
                This is only effective for properties/fields that lack an <see cref="T:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute" />.  Failed conversions
                for attributed constants always throw an
                <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionException" />.
            </summary>
            <value>
                <c>true</c> to filter out fields/property's lacking an <see cref="T:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute" /> where
                <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ValueStringConverter" />
                fails to convert their value to a ValueString;  otherwise, <c>false</c> to throw
                <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionException" />.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.AttributedMethodsOnly">
            <summary>
                Gets or sets a value indicating whether the serializer should only de-serialize methods marked with an
                <see cref="T:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute" />.
                The default value is <c>true</c>.  This property is taken into consideration only AFTER filtering by
                <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ParameterFilter" /> has taken place.
            </summary>
            <value>
                <c>true</c> If the serializer should only de-serialize methods marked with an <see cref="T:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute" />;
                otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.AttributedParametersOnly">
            <summary>
                Gets or sets a value indicating whether the serializer should only add parameters marked with an
                <see cref="T:LibLSLCC.LibraryData.Reflection.LSLParamAttribute" /> to de-serialized <see cref="T:LibLSLCC.LibraryData.LSLLibraryFunctionSignature" /> objects.
                This option is only effective on methods that have an <see cref="T:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute" />.
                The default value is <c>true</c>.
            </summary>
            <value>
                <c>true</c> If the serializer should only de-serialize methods marked with an <see cref="T:LibLSLCC.LibraryData.Reflection.LSLFunctionAttribute" />;
                otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.AttributedConstantsOnly">
            <summary>
                Gets or sets a value indicating whether the serializer should only de-serialize fields and properties marked with
                an <see cref="T:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute" />.
                The default value is <c>true</c>.
            </summary>
            <value>
                <c>true</c> If the serializer should only de-serialize fields and properties marked with an
                <see cref="T:LibLSLCC.LibraryData.Reflection.LSLConstantAttribute" />; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterMethodWithUnmappedReturnType">
            <summary>
                Occurs when <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.FilterMethodsWithUnmappedReturnTypes" /> is <c>true</c> and an un-attributed method is
                filtered because
                <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ReturnTypeConverter" /> cannot successfully convert it's return type to an <see cref="T:LibLSLCC.CodeValidator.LSLType" />.
            </summary>
        </member>
        <member name="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterMethodWithUnmappedParamType">
            <summary>
                Occurs when <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.FilterMethodsWithUnmappedParamTypes" /> is <c>true</c> and an un-attributed method is
                filtered because
                <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ParamTypeConverter" /> cannot successfully convert one of it's parameter types to an
                <see cref="T:LibLSLCC.CodeValidator.LSLType" />.
            </summary>
        </member>
        <member name="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterConstantWithUnmappedType">
            <summary>
                Occurs when <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.FilterConstantsWithUnmappedTypes" /> is <c>true</c> and an un-attributed constant is
                filtered because
                <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ConstantTypeConverter" /> cannot successfully convert its type to an <see cref="T:LibLSLCC.CodeValidator.LSLType" />.
            </summary>
        </member>
        <member name="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterConstantPropertyWithUnmappedType">
            <summary>
                Occurs when <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.FilterConstantsWithUnmappedTypes" /> is <c>true</c> and an un-attributed constant Property
                is filtered because
                <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ConstantTypeConverter" /> cannot successfully convert its type to an <see cref="T:LibLSLCC.CodeValidator.LSLType" />.
            </summary>
        </member>
        <member name="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterConstantFieldWithUnmappedType">
            <summary>
                Occurs when <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.FilterConstantsWithUnmappedTypes" /> is <c>true</c> and an un-attributed constant Field is
                filtered because
                <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ConstantTypeConverter" /> cannot successfully convert its type to an <see cref="T:LibLSLCC.CodeValidator.LSLType" />.
            </summary>
        </member>
        <member name="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterNullConstant">
            <summary>
                Occurs when <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.FilterNullConstants" /> is <c>true</c> and an un-attributed constant is filtered for having
                a null field/property value.
            </summary>
        </member>
        <member name="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterNullConstantProperty">
            <summary>
                Occurs when <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.FilterNullConstants" /> is <c>true</c> and an un-attributed constant is filtered for having
                a null property value.
            </summary>
        </member>
        <member name="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterNullConstantField">
            <summary>
                Occurs when <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.FilterNullConstants" /> is <c>true</c> and an un-attributed constant is filtered for having
                a null field value.
            </summary>
        </member>
        <member name="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterInvalidValueString">
            <summary>
                Occurs when <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.FilterInvalidValueStrings" /> is <c>true</c> and an un-attributed constant is filtered for
                having
                an invalid ValueString generated for it by <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ValueStringConverter" />.
            </summary>
        </member>
        <member name="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterInvalidValueStringProperty">
            <summary>
                Occurs when <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.FilterInvalidValueStrings" /> is <c>true</c> and an un-attributed constant Property is
                filtered for having
                an invalid ValueString generated for it by <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ValueStringConverter" />.
            </summary>
        </member>
        <member name="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterInvalidValueStringField">
            <summary>
                Occurs when <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.FilterInvalidValueStrings" /> is <c>true</c> and an un-attributed constant Field is filtered
                for having
                an invalid ValueString generated for it by <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ValueStringConverter" />.
            </summary>
        </member>
        <member name="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterValueStringConversionFailure">
            <summary>
                Occurs when <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.FilterValueStringConversionFailures" /> is <c>true</c> and an un-attributed constant is
                filtered because
                <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ValueStringConverter" /> reported a ValueString conversion failure for the constants retrieved value.
            </summary>
        </member>
        <member name="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterValueStringConversionFailureProperty">
            <summary>
                Occurs when <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.FilterValueStringConversionFailures" /> is <c>true</c> and an un-attributed constant
                Property is filtered because
                <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ValueStringConverter" /> reported a ValueString conversion failure for the constant Property's retrieved
                value.
            </summary>
        </member>
        <member name="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterValueStringConversionFailureField">
            <summary>
                Occurs when <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.FilterValueStringConversionFailures" /> is <c>true</c> and an un-attributed constant Field
                is filtered because
                <see cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.ValueStringConverter" /> reported a ValueString conversion failure for the constant Field's retrieved
                value.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.DeSerializeMethod(System.Reflection.MethodInfo)">
            <summary>
                de-serialize a <see cref="T:LibLSLCC.LibraryData.LSLLibraryFunctionSignature" /> from a <see cref="T:System.Reflection.MethodInfo" /> object.
            </summary>
            <param name="info">The <see cref="T:System.Reflection.MethodInfo" /> object to de-serialize from.</param>
            <returns>The de-serialized <see cref="T:LibLSLCC.LibraryData.LSLLibraryFunctionSignature" /> or <c>null</c>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="info"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.DeSerializeConstant(System.Reflection.PropertyInfo,System.Object)">
            <summary>
                de-serialize a <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" /> from a <see cref="T:System.Reflection.PropertyInfo" /> object.
            </summary>
            <param name="info">The <see cref="T:System.Reflection.PropertyInfo" /> object to de-serialize from.</param>
            <param name="optionalInstance">
                An optional object instance to provide to serializer.
                Instance properties will be considered <c>null</c> if one is not provided.
            </param>
            <returns>The de-serialized <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" /> or <c>null</c>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="info"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.DeSerializeConstantGeneric(System.Reflection.MemberInfo,System.Object)">
            <summary>
                de-serialize a <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" /> from a <see cref="T:System.Reflection.MemberInfo" /> object.
                The passed <see cref="T:System.Reflection.MemberInfo" /> object must derive from either <see cref="T:System.Reflection.PropertyInfo" /> or
                <see cref="T:System.Reflection.FieldInfo" />.
            </summary>
            <param name="info">The <see cref="T:System.Reflection.MemberInfo" /> object to de-serialize from.</param>
            <param name="optionalInstance">
                An optional object instance to provide to serializer.
                Instance properties will be considered <c>null</c> if one is not provided.
            </param>
            <exception cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionException">
                Thrown if <paramref name="info" /> does not derive from either
                <see cref="T:System.Reflection.PropertyInfo" /> or <see cref="T:System.Reflection.FieldInfo" />.
            </exception>
            <returns>The de-serialized <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" /> or <c>null</c>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="info"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.DeSerializeConstant(System.Reflection.FieldInfo,System.Object)">
            <summary>
                de-serialize a <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" /> from a <see cref="T:System.Reflection.FieldInfo" /> object.
            </summary>
            <param name="info">The <see cref="T:System.Reflection.FieldInfo" /> object to de-serialize from.</param>
            <param name="optionalInstance">
                An optional object instance to provide to serializer.
                Instance fields will be considered <c>null</c> if one is not provided.
            </param>
            <returns>The de-serialized <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" /> or <c>null</c>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="info"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.DeSerializeMethods(System.Type)">
            <summary>
                de-serialize <see cref="T:LibLSLCC.LibraryData.LSLLibraryFunctionSignature" />'s from a class or interface using the options provided to
                the serializer.
            </summary>
            <param name="objectType">The type of the class or interface to serialize method definitions from.</param>
            <returns>
                An enumerable of de-serialized <see cref="T:LibLSLCC.LibraryData.LSLLibraryFunctionSignature" /> generated from the object type's
                methods.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="objectType"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.DeSerializeConstants(System.Type,System.Object)">
            <summary>
                de-serialize <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" />'s from a class or interface using the options provided to
                the serializer.
                Any non-static field or property encountered in the class will be considered <c>null</c> if no object instance is
                provided in <paramref name="typeInstance" />
            </summary>
            <param name="objectType">The type of the class or interface to serialize method definitions from.</param>
            <param name="typeInstance">
                An optional instance of the type, which instance field/property values can be taken from.
                Any non-static field or property encountered in the class will be considered <c>null</c> if no object instance is
                provided.
            </param>
            <returns>
                An enumerable of de-serialized <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" /> generated from the object type's
                fields and properties.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="objectType"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.DeSerializeConstants(System.Object)">
            <summary>
                de-serialize <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" />'s from a object instance using the options provided to the
                serializer.
            </summary>
            <param name="fieldValueInstance">
                The object instance to use, instance field and property values will be able to be
                retrieved from this instance.
            </param>
            <returns>
                An enumerable of de-serialized <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" /> generated from the object instances
                fields and properties.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="fieldValueInstance"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.InvokeOnFilterNullConstant(System.Reflection.MemberInfo)">
            <summary>
                <para>
                    Invokes <see cref="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterNullConstant" /> first.
                    Then Invokes <see cref="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterNullConstantProperty" /> if <paramref name="member" /> is a
                    <see cref="T:System.Reflection.PropertyInfo" /> object.
                    Otherwise, invokes <see cref="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterNullConstantField" /> if <paramref name="member" /> is a
                    <see cref="T:System.Reflection.FieldInfo" /> object.
                </para>
            </summary>
            <param name="member">The <see cref="T:System.Reflection.MemberInfo" /> of the member being filtered.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.InvokeOnFilterInvalidValueString(System.Reflection.MemberInfo)">
            <summary>
                <para>
                    Invokes <see cref="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterInvalidValueString" /> first.
                    Then Invokes <see cref="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterInvalidValueStringProperty" /> if <paramref name="member" /> is a
                    <see cref="T:System.Reflection.PropertyInfo" /> object.
                    Otherwise, invokes <see cref="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterInvalidValueStringField" /> if <paramref name="member" /> is a
                    <see cref="T:System.Reflection.FieldInfo" /> object.
                </para>
            </summary>
            <param name="member">The <see cref="T:System.Reflection.MemberInfo" /> of the member being filtered.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.InvokeOnFilterValueStringConversionFailure(System.Reflection.MemberInfo)">
            <summary>
                <para>
                    Invokes <see cref="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterValueStringConversionFailure" /> first.
                    Then Invokes <see cref="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterValueStringConversionFailureProperty" /> if <paramref name="member" /> is a
                    <see cref="T:System.Reflection.PropertyInfo" /> object.
                    Otherwise, invokes <see cref="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterValueStringConversionFailureField" /> if <paramref name="member" /> is a
                    <see cref="T:System.Reflection.FieldInfo" /> object.
                </para>
            </summary>
            <param name="member">The <see cref="T:System.Reflection.MemberInfo" /> of the member being filtered.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.InvokeOnFilterConstantWithUnmappedType(System.Reflection.MemberInfo)">
            <summary>
                <para>
                    Invokes <see cref="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterConstantWithUnmappedType" /> first.
                    Then Invokes <see cref="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterConstantPropertyWithUnmappedType" /> if <paramref name="member" /> is a
                    <see cref="T:System.Reflection.PropertyInfo" /> object.
                    Otherwise, invokes <see cref="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterConstantFieldWithUnmappedType" /> if <paramref name="member" /> is a
                    <see cref="T:System.Reflection.FieldInfo" /> object.
                </para>
            </summary>
            <param name="member">The <see cref="T:System.Reflection.MemberInfo" /> of the member being filtered.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.InvokeOnFilterMethodWithUnmappedParamType(System.Reflection.MethodInfo)">
            <summary>
                Invokes <see cref="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterMethodWithUnmappedParamType" />.
            </summary>
            <param name="member">The <see cref="T:System.Reflection.MemberInfo" /> of the member being filtered.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.InvokeOnFilterMethodWithUnmappedReturnType(System.Reflection.MethodInfo)">
            <summary>
                Invokes <see cref="E:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.OnFilterMethodWithUnmappedReturnType" />.
            </summary>
            <param name="member">The <see cref="T:System.Reflection.MemberInfo" /> of the member being filtered.</param>
        </member>
        <member name="T:LibLSLCC.LibraryData.Reflection.LSLParamAttribute">
            <summary>
                Optional Attribute for exposing method parameters to <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> without
                having to map types.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLParamAttribute.#ctor(LibLSLCC.CodeValidator.LSLType)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLParamAttribute" /> class.
            </summary>
            <param name="type">The <see cref="T:LibLSLCC.CodeValidator.LSLType" /> of the parameter, variadic status is detected automagically.</param>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLParamAttribute.Type">
            <summary>
                Gets the <see cref="T:LibLSLCC.CodeValidator.LSLType" /> of the parameter as specified by the attribute.
            </summary>
            <value>
                The <see cref="T:LibLSLCC.CodeValidator.LSLType" /> of the parameter.
            </value>
        </member>
        <member name="T:LibLSLCC.LibraryData.Reflection.LSLLambdaConstantFilter">
            <summary>
                Implements <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLConstantFilter" /> using function objects.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLambdaConstantFilter.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLambdaConstantFilter" /> class.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLambdaConstantFilter.PreFilterPropertyConstant">
            <summary>
                The function used to implement <see cref="M:LibLSLCC.LibraryData.Reflection.LSLLambdaConstantFilter.PreFilter(LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.PropertyInfo)" />.
                If its <c>null</c> nothing will be filtered (everything will be allowed).
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLambdaConstantFilter.MutatePropertyConstant">
            <summary>
                The function used to implement
                <see cref="M:LibLSLCC.LibraryData.Reflection.LSLLambdaConstantFilter.MutateSignature(LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.PropertyInfo,LibLSLCC.LibraryData.LSLLibraryConstantSignature)" />.
                If its <c>null</c> nothing will be filtered (everything will be allowed) and no de-serialized constants derived
                from fields will be mutated.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLambdaConstantFilter.PreFilterFieldConstant">
            <summary>
                The function used to implement <see cref="M:LibLSLCC.LibraryData.Reflection.LSLLambdaConstantFilter.PreFilter(LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.FieldInfo)" />.
                If its <c>null</c> nothing will be filtered (everything will be allowed).
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLambdaConstantFilter.MutateFieldConstant">
            <summary>
                The function used to implement
                <see cref="M:LibLSLCC.LibraryData.Reflection.LSLLambdaConstantFilter.MutateSignature(LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.FieldInfo,LibLSLCC.LibraryData.LSLLibraryConstantSignature)" />.
                If its <c>null</c> nothing will be filtered (everything will be allowed) and no de-serialized constants derived
                from fields will be mutated.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLambdaConstantFilter.PreFilter(LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.PropertyInfo)">
            <summary>
                Allows <see cref="T:System.Reflection.PropertyInfo" /> objects to be prematurely filtered from de-serialization output.  Returns
                <c>true</c> if the <see cref="T:System.Reflection.PropertyInfo" /> should be filtered.
            </summary>
            <param name="serializer">The <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> this add-on belongs to.</param>
            <param name="info">The <see cref="T:System.Reflection.PropertyInfo" /> object we may want to filter from the output.</param>
            <returns><c>true</c> if the property needs to be filtered from the results.</returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLambdaConstantFilter.PreFilter(LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.FieldInfo)">
            <summary>
                Allows <see cref="T:System.Reflection.FieldInfo" /> objects to be prematurely filtered from de-serialization output.  Returns
                <c>true</c> if the <see cref="T:System.Reflection.MethodInfo" /> should be filtered.
            </summary>
            <param name="serializer">The <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> this add-on belongs to.</param>
            <param name="info">The <see cref="T:System.Reflection.PropertyInfo" /> object we may want to filter from the output.</param>
            <returns><c>true</c> if the field needs to be filtered from the results.</returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLambdaConstantFilter.MutateSignature(LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.PropertyInfo,LibLSLCC.LibraryData.LSLLibraryConstantSignature)">
            <summary>
                Allows modification of a constant signature after its basic information has been serialized from an objects
                Property, before its returned.
            </summary>
            <param name="serializer">The <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> this add-on belongs to.</param>
            <param name="info">The <see cref="T:System.Reflection.PropertyInfo" /> object the library constant signature was serialized from.</param>
            <param name="signature">The signature.</param>
            <returns><c>true</c> if the constant needs to be filtered from the results.</returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLambdaConstantFilter.MutateSignature(LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.FieldInfo,LibLSLCC.LibraryData.LSLLibraryConstantSignature)">
            <summary>
                Allows modification of a constant signature after its basic information has been serialized from an objects
                Property, before its returned.
            </summary>
            <param name="serializer">The <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> this add-on belongs to.</param>
            <param name="info">The <see cref="T:System.Reflection.FieldInfo" /> object the library constant signature was serialized from.</param>
            <param name="signature">The signature.</param>
            <returns><c>true</c> if the constant needs to be filtered from the results.</returns>
        </member>
        <member name="T:LibLSLCC.LibraryData.Reflection.LSLLambdaMethodFilter">
            <summary>
                Implements <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLMethodFilter" /> using function objects.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLambdaMethodFilter.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLambdaMethodFilter" /> class.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLambdaMethodFilter.#ctor(System.Func{LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.MethodInfo,System.Boolean})">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLambdaMethodFilter" /> class.
            </summary>
            <param name="preFilterFunction">The pre filter function.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLambdaMethodFilter.#ctor(System.Func{LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.MethodInfo,LibLSLCC.LibraryData.LSLLibraryFunctionSignature,System.Boolean})">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLambdaMethodFilter" /> class.
            </summary>
            <param name="mutateSignatureFunction">The mutate signature function.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLambdaMethodFilter.#ctor(System.Func{LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.MethodInfo,System.Boolean},System.Func{LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.MethodInfo,LibLSLCC.LibraryData.LSLLibraryFunctionSignature,System.Boolean})">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLambdaMethodFilter" /> class.
            </summary>
            <param name="preFilterFunction">The pre filter function.</param>
            <param name="mutateSignatureFunction">The mutate signature function.</param>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLambdaMethodFilter.PreFilterFunction">
            <summary>
                The function used to implement <see cref="M:LibLSLCC.LibraryData.Reflection.LSLLambdaMethodFilter.PreFilter(LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.MethodInfo)" />.  If <c>null</c> no filtering will occur (everything will
                be allowed).
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLLambdaMethodFilter.MutateSignatureFunction">
            <summary>
                The function used to implement <see cref="M:LibLSLCC.LibraryData.Reflection.LSLLambdaMethodFilter.MutateSignature(LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.MethodInfo,LibLSLCC.LibraryData.LSLLibraryFunctionSignature)" />.  If <c>null</c> no filtering will occur (everything
                will be allowed) and no de-serialized method signatures will be mutated.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLambdaMethodFilter.PreFilter(LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.MethodInfo)">
            <summary>
                Allows <see cref="T:System.Reflection.MethodInfo" /> objects to be prematurely filtered from de-serialization output.  Returns
                <c>true</c> if the <see cref="T:System.Reflection.MethodInfo" /> should be filtered.
            </summary>
            <param name="serializer">The <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> this add-on belongs to.</param>
            <param name="info">The <see cref="T:System.Reflection.MethodInfo" /> object we may want to filter from the output.</param>
            <returns><c>true</c> if the method needs to be filtered from the results.</returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLLambdaMethodFilter.MutateSignature(LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.MethodInfo,LibLSLCC.LibraryData.LSLLibraryFunctionSignature)">
            <summary>
                Allows modification a function signature after its basic information has been serialized, before its returned.
            </summary>
            <param name="serializer">The <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> this add-on belongs to.</param>
            <param name="info">The <see cref="T:System.Reflection.MethodInfo" /> object the library function signature was serialized from.</param>
            <param name="signature">The signature.</param>
            <returns><c>true</c> if the method needs to be filtered from the results.</returns>
        </member>
        <member name="T:LibLSLCC.LibraryData.Reflection.LSLReflectionTypeMappingException">
            <summary>
                Thrown by de-serialization methods in <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> when a type encountered in
                a non-attributed member
                signature contains <see cref="T:System.Type" />('s) that were un-mappable to an <see cref="T:LibLSLCC.CodeValidator.LSLType" />
            </summary>
            <seealso cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.FilterMethodsWithUnmappedReturnTypes" />
            <seealso cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.FilterMethodsWithUnmappedParamTypes" />
            <seealso cref="P:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer.FilterConstantsWithUnmappedTypes" />
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLReflectionTypeMappingException.#ctor">
            <summary>
                Constructs a new <see cref="T:LibLSLCC.LibraryData.Reflection.LSLReflectionTypeMappingException" />
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLReflectionTypeMappingException.#ctor(System.String)">
            <summary>
                Constructs a new <see cref="T:LibLSLCC.LibraryData.Reflection.LSLReflectionTypeMappingException" />
            </summary>
            <param name="message">The message to use for the exception.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLReflectionTypeMappingException.#ctor(System.String,System.Exception)">
            <summary>
                Constructs a new <see cref="T:LibLSLCC.LibraryData.Reflection.LSLReflectionTypeMappingException" />
            </summary>
            <param name="message">The message to use for the exception.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLReflectionTypeMappingException.#ctor(System.Type)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLReflectionTypeMappingException" /> class.
            </summary>
            <param name="missingType">The type that was missing a mapping to convert it into an <see cref="T:LibLSLCC.CodeValidator.LSLType" /></param>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLReflectionTypeMappingException.#ctor(System.String,System.Type)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLReflectionTypeMappingException" /> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="missingType">The type that was missing a mapping to convert it into an <see cref="T:LibLSLCC.CodeValidator.LSLType" /></param>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLReflectionTypeMappingException.#ctor(System.String,System.Exception,System.Type)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLReflectionTypeMappingException" /> class.
            </summary>
            <param name="message">The message.</param>
            <param name="inner">The inner.</param>
            <param name="missingType">The type that was missing a mapping to convert it into an <see cref="T:LibLSLCC.CodeValidator.LSLType" /></param>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLReflectionTypeMappingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLReflectionTypeMappingException" /> class.
            </summary>
            <param name="info">
                The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object
                data about the exception being thrown.
            </param>
            <param name="context">
                The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual
                information about the source or destination.
            </param>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLReflectionTypeMappingException.MissingType">
            <summary>
                The type that no mapping existed for.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLReflectionTypeMappingException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with
                information about the exception.
            </summary>
            <param name="info">
                The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the
                exception being thrown.
            </param>
            <param name="context">
                The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual
                information about the source or destination.
            </param>
            <exception cref="T:System.ArgumentNullException">
                The <paramref name="info" /> parameter is a null reference (Nothing in Visual Basic).
            </exception>
            <filterpriority>2</filterpriority>
            <PermissionSet>
                <IPermission
                    class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
                    version="1" Read="*AllFiles*" PathDiscovery="*AllFiles*" />
                <IPermission
                    class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
                    version="1" Flags="SerializationFormatter" />
            </PermissionSet>
        </member>
        <member name="T:LibLSLCC.LibraryData.Reflection.LSLMultiMethodFilter">
            <summary>
                Allows multiple <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLMethodFilter" /> objects to participate in filtering/mutating method
                signatures de-serialized from runtime types using <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" />.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLMultiMethodFilter.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.LibraryData.Reflection.LSLMultiMethodFilter" /> class.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.Reflection.LSLMultiMethodFilter.Filters">
            <summary>
                A modifiable collection of all <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLMethodFilter" /> objects participating in filtering.
            </summary>
            <value>
                The <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLMethodFilter" />'s being used to filter.
            </value>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLMultiMethodFilter.GetEnumerator">
            <summary>
                Returns an enumerator that enumerates through the <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLMethodFilter" /> objects that have been added to
                this <see cref="T:LibLSLCC.LibraryData.Reflection.LSLMultiMethodFilter" />.
            </summary>
            <returns>
                An enumerator over the <see cref="T:LibLSLCC.LibraryData.Reflection.ILSLMethodFilter" /> objects that have been added to this
                <see cref="T:LibLSLCC.LibraryData.Reflection.LSLMultiMethodFilter" />.
            </returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLMultiMethodFilter.PreFilter(LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.MethodInfo)">
            <summary>
                Allows <see cref="T:System.Reflection.MethodInfo" /> objects to be prematurely filtered from de-serialization output.  Returns
                <c>true</c> if the <see cref="T:System.Reflection.MethodInfo" /> should be filtered.
            </summary>
            <param name="serializer">The <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> this add-on belongs to.</param>
            <param name="info">The <see cref="T:System.Reflection.MethodInfo" /> object we may want to filter from the output.</param>
            <returns><c>true</c> if the method needs to be filtered from the results.</returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLMultiMethodFilter.MutateSignature(LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer,System.Reflection.MethodInfo,LibLSLCC.LibraryData.LSLLibraryFunctionSignature)">
            <summary>
                Allows modification a function signature after its basic information has been serialized, before its returned.
            </summary>
            <param name="serializer">The <see cref="T:LibLSLCC.LibraryData.Reflection.LSLLibraryDataReflectionSerializer" /> this add-on belongs to.</param>
            <param name="info">The <see cref="T:System.Reflection.MethodInfo" /> object the library function signature was serialized from.</param>
            <param name="signature">The signature.</param>
            <returns><c>true</c> if the method needs to be filtered from the results.</returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.Reflection.LSLMultiMethodFilter.Add(LibLSLCC.LibraryData.Reflection.ILSLMethodFilter)">
            <summary>
                Add's a filter to this multi filter, this here so list initializer syntax can be utilized to build a multi filter.
            </summary>
            <param name="filter">The filter to add.</param>
        </member>
        <member name="T:LibLSLCC.LibraryData.LSLDuplicateSignatureException">
            <summary>
                This exception is thrown by LSLLibraryDataProvider when a duplicate signature is added to
                a subset.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLDuplicateSignatureException.#ctor">
            <summary>
                Default constructor.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLDuplicateSignatureException.#ctor(System.String)">
            <summary>
                Construct with a message.
            </summary>
            <param name="message">The exception message.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLDuplicateSignatureException.#ctor(System.String,System.Exception)">
            <summary>
                Construct with a message and inner exception.
            </summary>
            <param name="message">The exception message.</param>
            <param name="inner">The inner exception.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLDuplicateSignatureException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Serializable constructor.
            </summary>
            <param name="info">SerializationInfo.</param>
            <param name="context">StreamingContext.</param>
        </member>
        <member name="T:LibLSLCC.LibraryData.LSLDuplicateSubsetDescriptionException">
            <summary>
                This exception is thrown by <see cref="T:LibLSLCC.LibraryData.LSLLibraryDataProvider" /> when a subset description for the same subset is
                added more than once.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLDuplicateSubsetDescriptionException.#ctor">
            <summary>
                Default constructor.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLDuplicateSubsetDescriptionException.#ctor(System.String)">
            <summary>
                Construct with a message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLDuplicateSubsetDescriptionException.#ctor(System.String,System.Exception)">
            <summary>
                Construct with a message and inner exception.
            </summary>
            <param name="message">The exception message.</param>
            <param name="inner">The inner exception.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLDuplicateSubsetDescriptionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Serializable constructor.
            </summary>
            <param name="info">SerializationInfo.</param>
            <param name="context">StreamingContext.</param>
        </member>
        <member name="T:LibLSLCC.LibraryData.LSLInvalidSubsetNameException">
            <summary>
                Thrown by functions that deal with subset names, when an invalid format for a subset name is encountered
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLInvalidSubsetNameException.#ctor">
            <summary>
                Default constructor.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLInvalidSubsetNameException.#ctor(System.String)">
            <summary>
                Construct with message.
            </summary>
            <param name="message">Exception message.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLInvalidSubsetNameException.#ctor(System.String,System.Exception)">
            <summary>
                Construct with message and inner exception.
            </summary>
            <param name="message">Exception message.</param>
            <param name="inner">Inner exception.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLInvalidSubsetNameException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Serializable constructor.
            </summary>
            <param name="info">SerializationInfo.</param>
            <param name="context">StreamingContext.</param>
        </member>
        <member name="T:LibLSLCC.LibraryData.LSLMissingSubsetDescriptionException">
            <summary>
                This exception is thrown by LSLLibraryDataProvider when a signature is added that belongs to a subset with no
                description
                a subset.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLMissingSubsetDescriptionException.#ctor">
            <summary>
                Default constructor.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLMissingSubsetDescriptionException.#ctor(System.String)">
            <summary>
                Construct with a message.
            </summary>
            <param name="message">The exception message.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLMissingSubsetDescriptionException.#ctor(System.String,System.Exception)">
            <summary>
                Construct with a message and inner exception.
            </summary>
            <param name="message">The exception message.</param>
            <param name="inner">The inner exception.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLMissingSubsetDescriptionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Serializable constructor.
            </summary>
            <param name="info">SerializationInfo.</param>
            <param name="context">StreamingContext.</param>
        </member>
        <member name="T:LibLSLCC.LibraryData.LSLLibraryDataProvider">
            <summary>
                The default base implementation of <see cref="T:LibLSLCC.LibraryData.ILSLLibraryDataProvider" /> which features optional live filtering of
                data
                and stores library information in memory.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.#ctor">
            <summary>
                Construct an <see cref="T:LibLSLCC.LibraryData.LSLLibraryDataProvider" />.
                <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.LiveFiltering"/> will be enabled by default.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.#ctor(System.Boolean)">
            <summary>
                Construct an <see cref="T:LibLSLCC.LibraryData.LSLLibraryDataProvider" />.
                Optionally enable <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.LiveFiltering" /> mode using the <paramref name="liveFiltering"/> parameter.
            </summary>
            <param name="liveFiltering">Whether or not to enable <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.LiveFiltering" /> mode.  Default value is true.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Construct an LSLLibraryDataProvider an initialize <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.ActiveSubsets" /> from the constructor parameter 'activeSubsets'.
                <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.LiveFiltering"/> will be enabled by default.
            </summary>
            <param name="activeSubsets">The subsets to add to the <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.ActiveSubsets" /> collection upon construction.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.#ctor(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
                Construct an LSLLibraryDataProvider an initialize <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.ActiveSubsets" /> from the constructor parameter 'activeSubsets'.
                Optionally enable <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.LiveFiltering" /> mode using the <paramref name="liveFiltering"/> parameter.
            </summary>
            <param name="activeSubsets">The subsets to add to the <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.ActiveSubsets" /> collection upon construction.</param>
            <param name="liveFiltering">Whether or not to enable <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.LiveFiltering" /> mode.  Default value is true.</param>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.DuplicateCheckingDuringReads">
            <summary>
            Whether or not to throw <see cref="T:LibLSLCC.LibraryData.LSLDuplicateSignatureException"/> when <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.LiveFiltering"/> is enabled,
            and a duplicate signature is detected among the <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.ActiveSubsets"/> when querying signatures from this provider. <para/>
            This is <c>true</c> by default.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.LiveFiltering">
            <summary>
                If this is <c>false</c>, functions, constants and events which do not belong to subsets in <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.ActiveSubsets"/>
                will be discarded upon adding them to the object.
            
                This properties default value is <c>true</c> when not specified in the constructor.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.ActiveSubsets">
            <summary>
                The subsets of library data to present during query's.
                <para>
                    If LiveFiltering is disabled, when classes that derive from this class try to call the Add* functions
                    to add signatures, the signatures will be discarded if their Subset property does not overlap with this
                    collection.
                    During live filtering, all data added from derived classes is accepted and kept in memory, the
                    <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.ActiveSubsets" /> collection will
                    then determine what subsets are actually presented during query's.
                    ActiveSubsets can only be changed after the construction of this object if LiveFiltering is enabled.
                    If you try to add a subset to the active subsets collection while LiveFiltering is enabled,
                    and an <see cref="T:LibLSLCC.LibraryData.LSLLibrarySubsetDescription" /> object has not been added for that subset name;  An
                    <see cref="T:LibLSLCC.LibraryData.LSLMissingSubsetDescriptionException" /> will be thrown by the collection.
                </para>
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.PossibleSubsets">
            <summary>
                All possible subset names in the library data currently loaded into this provider, taken from the
                <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.SubsetDescriptions" /> dictionary.
            </summary>
            <remarks>
                <para>
                    This is only really useful if LiveFiltering mode is enabled.
                    If the provider is not in live filtering mode, subset descriptions who's subsets do not overlap with the
                    <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.ActiveSubsets" /> collection are discarded when they are added;
                    Therefore they could never be a part of the <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.PossibleSubsets" /> collection.
                </para>
            </remarks>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.PossibleSubsetsFriendlyNames">
            <summary>
                Retrieves the friendly names of all the possible subsets that can be added to the <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.ActiveSubsets" />
                collection of this library data provider.
                The friendly name values are retrieved from the <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.SubsetDescriptions" /> dictionary.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.ActiveSubsetsFriendlyNames">
            <summary>
                Retrieves the friendly names of the active subsets in this library data provider.
                The friendly name values are retrieved from the <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.SubsetDescriptions" /> dictionary.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.SubsetDescriptions">
            <summary>
                Contains descriptions of all the subsets that signatures can possibly belong to.
            </summary>
            <remarks>
                <para>
                    The key to this dictionary is the subset name the description is associated with.
                    If a signature is added to the library data provider who's Subsets's property contains a subset
                    without a description in this dictionary, an <see cref="T:LibLSLCC.LibraryData.LSLMissingSubsetDescriptionException" /> is thrown.
                    You can add descriptions for subsets using the <see cref="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.AddSubsetDescription(LibLSLCC.LibraryData.LSLLibrarySubsetDescription)" /> method of this class.
                </para>
            </remarks>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.LibraryEvents">
            <summary>
                Returns all supported event handler signatures belonging to the current <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.ActiveSubsets" />.
                <exception cref="T:LibLSLCC.LibraryData.LSLDuplicateSignatureException">
                    If the current <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.ActiveSubsets" /> caused an event with a duplicate name to be loaded.
                    And that event was not shared across subsets.  This can only really happen when <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.LiveFiltering" /> is
                    enabled.
                </exception>
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.LibraryFunctions">
            <summary>
                Returns all supported function signature overloads belonging to the current <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.ActiveSubsets" />.
                <exception cref="T:LibLSLCC.LibraryData.LSLDuplicateSignatureException">
                    If the current <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.ActiveSubsets" /> caused a function signature with duplicate/ambiguous definition to
                    be retrieved.
                    And that function was not shared across subsets.  This can only really happen when <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.LiveFiltering" />
                    is enabled.
                </exception>
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.LibraryConstants">
            <summary>
                Returns all supported constant signatures for the current <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.ActiveSubsets" />.
                <exception cref="T:LibLSLCC.LibraryData.LSLDuplicateSignatureException">
                    If the current <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.ActiveSubsets" /> caused a constant with a duplicate name to be loaded.
                    And that constant was not shared across subsets.  This can only really happen when <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.LiveFiltering" />
                    is enabled.
                </exception>
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.EventHandlerExist(System.String)">
            <summary>
                Check if a library event handler with the given name is defined whiten this data provider.
            </summary>
            <param name="name">The name of the library event handler to query for existence.</param>
            <returns>True if the library event handler is defined, false if it is not.</returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.GetEventHandlerSignature(System.String)">
            <summary>
                Attempt to return a library event handler signature with the given name if it is defined in this data provider,
                other wise return null.
            </summary>
            <param name="name">The name of the library event handler signature to return.</param>
            <returns>The signature if an event with the given name is defined, otherwise null.</returns>
            <exception cref="T:LibLSLCC.LibraryData.LSLDuplicateSignatureException">
                Thrown if <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.LiveFiltering" /> is enabled and more than one active subset contains a definition of an event
                handler with this name that is not shared across those subsets.
            </exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.LibraryFunctionExist(System.String)">
            <summary>
                Check if a library function with the given name is defined whiten this data provider.
            </summary>
            <param name="name">The name of the library function to query for existence.</param>
            <returns>True if the library function is defined, false if it is not.</returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.GetLibraryFunctionSignatures(System.String)">
            <summary>
                Attempt to return a list of overloads for a function that might be defined in the library data provider given its
                name.
            </summary>
            <param name="name">The name of the function to attempt to return a list of overloads for.</param>
            <returns>
                A list of function signatures that represent the overloads among the active subsets for a function with a given
                name, or null if no function with that name exists.
                If the function exists but has no overloads, only one item will be returned in the list.
            </returns>
            <exception cref="T:LibLSLCC.LibraryData.LSLDuplicateSignatureException">
                Thrown if <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.LiveFiltering" /> is enabled and more than one active subset contains a duplicate definition
                of the function or one of its overloads,
                and the function/overload is not shared across those subsets.
            </exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.GetLibraryFunctionSignature(LibLSLCC.CodeValidator.ILSLFunctionSignature)">
            <summary>
                Attempt to return a library function signature from the active subsets with an exact signature match to the give
                signature.
            </summary>
            <param name="signatureToTest">
                The function signature that should match exactly with the library function signature you
                want to return from the provider.
            </param>
            <returns>
                A signature defined in the provider among the active subsets that matches exactly with the given signature, or
                null if none is found.
            </returns>
            <exception cref="T:LibLSLCC.LibraryData.LSLDuplicateSignatureException">
                Thrown if <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.ActiveSubsets" /> is enabled and more than one active subset contains a duplicate definition
                of the function or one of its overloads,
                and the function/overload is not shared across those subsets.
            </exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="signatureToTest"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.LibraryConstantExist(System.String)">
            <summary>
                Check whether a library constant with the given name is defined among the active subsets of this library data
                provider.
            </summary>
            <param name="name">The name of the constant to check the existence of.</param>
            <returns>True if the constant is defined among the current active subsets, or false if it is not.</returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.GetLibraryConstantSignature(System.String)">
            <summary>
                Attempt to return a library constant signature from the active subsets with the same name as the given name.
            </summary>
            <param name="name">The name of the library constant that you want to find among the active subsets.</param>
            <returns>A library constant signature with a matching name, or null if none is found.</returns>
            <exception cref="T:LibLSLCC.LibraryData.LSLDuplicateSignatureException">
                Thrown if <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.ActiveSubsets" /> is enabled and more than one active subset contains a constant with a
                duplicate name,
                and the constant is not shared across those subsets.
            </exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.ClearLibraryFunctions">
            <summary>
                Clear all library functions defined in this library data provider.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.ClearEventHandlers">
            <summary>
                Clear all library event handlers defined in this library data provider.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.ClearLibraryConstants">
            <summary>
                Clear all library constants defined in this library data provider.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.ClearSubsetDescriptions">
            <summary>
                Clear all subset descriptions defined in this library data provider.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.ClearLibraryData">
            <summary>
                Clears all library definitions and subset descriptions.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.AddSubsetDescription(LibLSLCC.LibraryData.LSLLibrarySubsetDescription)">
            <summary>
                Add a subset description to this library data provider.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.LiveFiltering" /> is not enabled, the subset description will be put into a holding area and not
                added to <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.SubsetDescriptions" /> until it is referenced by a signature.
            </remarks>
            <exception cref="T:LibLSLCC.LibraryData.LSLDuplicateSubsetDescriptionException">
                If a subset description for the same Subset name already
                exists.
            </exception>
            <param name="description">The subset description to add.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="description"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.AddSubsetDescriptions(System.Collections.Generic.IEnumerable{LibLSLCC.LibraryData.LSLLibrarySubsetDescription})">
            <summary>
                Adds multiple a subset descriptions to this library data provider.
            </summary>
            <remarks>
                If <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.LiveFiltering" /> is not enabled, the subset description will be put into a holding area and not
                added to <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.SubsetDescriptions" /> until it is referenced by a signature.
            </remarks>
            <exception cref="T:LibLSLCC.LibraryData.LSLDuplicateSubsetDescriptionException">
                If a subset description for the same Subset name already
                exists.
            </exception>
            <param name="descriptions">The subset descriptions to add.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="descriptions"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.DefineEventHandler(LibLSLCC.LibraryData.LSLLibraryEventSignature)">
            <summary>
                Define a library event handler signature
            </summary>
            <param name="signature">The LSLLibraryEventSignature representing the library event handler to be defined.</param>
            <exception cref="T:LibLSLCC.LibraryData.LSLMissingSubsetDescriptionException">
                Thrown if the event signatures
                <exception cref="P:LibLSLCC.LibraryData.LSLLibraryEventSignature.Subsets" /> property contains a subset that is not described in the
                library data providers <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.SubsetDescriptions" /> collection.
            </exception>
            <exception cref="T:LibLSLCC.LibraryData.LSLDuplicateSignatureException">
                If the event handler could not be defined because it's name existed in
                the same subset already.
            </exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="signature"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.DefineEventHandlers(System.Collections.Generic.IEnumerable{LibLSLCC.LibraryData.LSLLibraryEventSignature})">
            <summary>
                Define all the event handlers from the given enumerable.
            </summary>
            <param name="eventHandlersSignatures">The event handler signatures to define.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="eventHandlersSignatures"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.DefineFunctions(System.Collections.Generic.IEnumerable{LibLSLCC.LibraryData.LSLLibraryFunctionSignature})">
            <summary>
                Define all the function signatures from the given enumerable.
            </summary>
            <param name="functionSignatures">The function signatures to define.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="functionSignatures"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.DefineConstants(System.Collections.Generic.IEnumerable{LibLSLCC.LibraryData.LSLLibraryConstantSignature})">
            <summary>
                Defines all the constant signatures from the given enumerable.
            </summary>
            <param name="constantSignatures">The constant signatures to define.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="constantSignatures"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.DefineConstant(LibLSLCC.LibraryData.LSLLibraryConstantSignature)">
            <summary>
                Define a library constant signature
            </summary>
            <param name="signature">The LSLLibraryConstantSignature representing the library constant to be defined.</param>
            <exception cref="T:LibLSLCC.LibraryData.LSLMissingSubsetDescriptionException">
                Thrown if the constant signatures
                <exception cref="P:LibLSLCC.LibraryData.LSLLibraryConstantSignature.Subsets" /> property contains a subset that is not described in the
                library data providers <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.SubsetDescriptions" /> collection.
            </exception>
            <exception cref="T:LibLSLCC.LibraryData.LSLDuplicateSignatureException">
                If the constant could not be defined because it's name existed in the
                same subset already.
            </exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="signature"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryDataProvider.DefineFunction(LibLSLCC.LibraryData.LSLLibraryFunctionSignature)">
            <summary>
                Define a library function signature
            </summary>
            <param name="signature">The LSLLibraryFunctionSignature representing the library function to be defined.</param>
            <exception cref="T:LibLSLCC.LibraryData.LSLMissingSubsetDescriptionException">
                Thrown if the function signatures
                <exception cref="P:LibLSLCC.LibraryData.LSLLibraryFunctionSignature.Subsets" /> property contains a subset that is not described in the
                library data providers <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.SubsetDescriptions" /> collection.
            </exception>
            <exception cref="T:LibLSLCC.LibraryData.LSLDuplicateSignatureException">
                If the function could not be defined because a duplicate or ambiguous
                definition existed in the same subset already.
            </exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="signature"/> is <c>null</c>.</exception>
        </member>
        <member name="T:LibLSLCC.LibraryData.ILSLLibraryDataProvider">
            <summary>
                An interface for providing data about the standard LSL library.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.ILSLLibraryDataProvider.SubsetDescriptions">
            <summary>
                Gets a map of subset descriptions for subset's used by signatures in this data provider.
            </summary>
            <value>
                The subset description map.
            </value>
        </member>
        <member name="P:LibLSLCC.LibraryData.ILSLLibraryDataProvider.LibraryEvents">
            <summary>
                Enumerable of <see cref="T:LibLSLCC.LibraryData.LSLLibraryEventSignature" /> describing the event handlers supported according to this
                data provider
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.ILSLLibraryDataProvider.LibraryFunctions">
            <summary>
                Enumerable of the <see cref="T:LibLSLCC.LibraryData.LSLLibraryFunctionSignature" /> overloads defined according to this data provider
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.ILSLLibraryDataProvider.LibraryConstants">
            <summary>
                Enumerable of the <see cref="P:LibLSLCC.LibraryData.ILSLLibraryDataProvider.LibraryConstants" /> defined according to this data provider
            </summary>
        </member>
        <member name="T:LibLSLCC.LibraryData.LSLLibraryDataLoadOptions">
            <summary>
                Indicates to the XML library data provider what library data elements should be loaded.
            </summary>
        </member>
        <member name="F:LibLSLCC.LibraryData.LSLLibraryDataLoadOptions.All">
            <summary>
                Constants, Functions and Event handler definitions should all be loaded.
            </summary>
        </member>
        <member name="F:LibLSLCC.LibraryData.LSLLibraryDataLoadOptions.Functions">
            <summary>
                Load Function definitions.
            </summary>
        </member>
        <member name="F:LibLSLCC.LibraryData.LSLLibraryDataLoadOptions.Constants">
            <summary>
                Load Constant definitions.
            </summary>
        </member>
        <member name="F:LibLSLCC.LibraryData.LSLLibraryDataLoadOptions.Events">
            <summary>
                Load Event definitions.
            </summary>
        </member>
        <member name="T:LibLSLCC.LibraryData.LSLXmlLibraryDataProvider">
            <summary>
                A library data provider that reads LSL library data from XML
            </summary>
        </member>
        <member name="F:LibLSLCC.LibraryData.LSLXmlLibraryDataProvider.RootElementName">
            <summary>
                The root element name used for LSL Library Data XML
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLXmlLibraryDataProvider.#ctor">
            <summary>
                Construct an LSLXmlLibraryDataProvider with the option to enable or disable live filtering mode in the base class.
                <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.LiveFiltering"/> will be enabled by default.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLXmlLibraryDataProvider.#ctor(System.Boolean)">
            <summary>
                Construct an LSLXmlLibraryDataProvider with the option to enable or disable live filtering mode in the base class
            </summary>
            <param name="liveFiltering">Whether or not to enable live filtering mode in the base class.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLXmlLibraryDataProvider.#ctor(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
                Construct an LSLXmlLibraryDataProvider with the ability to set the active subsets in the base class, and optionally
                enable or disable live filtering mode.
            </summary>
            <param name="activeSubsets">The active subsets to set in the base class.</param>
            <param name="liveFiltering">Whether or not to enable live filtering mode in the base class.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLXmlLibraryDataProvider.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Construct an LSLXmlLibraryDataProvider with the ability to set the active subsets in the base class.
                <see cref="P:LibLSLCC.LibraryData.LSLLibraryDataProvider.LiveFiltering"/> will be enabled by default.
            </summary>
            <param name="activeSubsets">The active subsets to set in the base class.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLXmlLibraryDataProvider.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <summary>
                This method is reserved and should not be used. When implementing the IXmlSerializable interface, you should return
                null (Nothing in Visual Basic) from this method, and instead, if specifying a custom schema is required, apply the
                <see cref="T:System.Xml.Serialization.XmlSchemaProviderAttribute" /> to the class.
            </summary>
            <returns>
                An <see cref="T:System.Xml.Schema.XmlSchema" /> that describes the XML representation of the object that is
                produced by the <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> method
                and consumed by the <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />
                method.
            </returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLXmlLibraryDataProvider.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <summary>
                Generates an object from its XML representation.
            </summary>
            <param name="reader">The <see cref="T:System.Xml.XmlReader" /> stream from which the object is deserialized. </param>
            <exception cref="T:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException">If a syntax error was detected in the Library Data XML.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLXmlLibraryDataProvider.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <summary>
                Converts an object into its XML representation.
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> stream to which the object is serialized. </param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLXmlLibraryDataProvider._ReadXml(System.Xml.XmlReader,LibLSLCC.LibraryData.LSLLibraryDataLoadOptions)">
            <exception cref="T:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException">
                If a syntax error was detected in the XML (Attribute value did not
                pass pattern validation.. etc..)
            </exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLXmlLibraryDataProvider.WriteXml(System.Xml.XmlWriter,System.Boolean)">
            <summary>
                Converts an object into its XML representation.
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> stream to which the object is serialized. </param>
            <param name="writeRootElement">Whether or not to write the root element for this object</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLXmlLibraryDataProvider.FillFromXml(System.Xml.XmlReader,LibLSLCC.LibraryData.LSLLibraryDataLoadOptions)">
            <summary>
                Fills a library data provider from an XML reader object, the data provider is cleared of all definitions first.
            </summary>
            <param name="data">The XML reader to read from.</param>
            <param name="loadOptions">
                Optionally specifies what type's of library definitions will be loaded, defaults to
                <see cref="F:LibLSLCC.LibraryData.LSLLibraryDataLoadOptions.All" />
            </param>
            <exception cref="T:System.ArgumentNullException">When the 'data' parameter is <c>null</c>.</exception>
            <exception cref="T:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException">
                If a syntax error was detected in the XML (Attribute value did not
                pass pattern validation.. etc..)
            </exception>
            <exception cref="T:System.Xml.XmlException">If incorrect XML was encountered in the input stream.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLXmlLibraryDataProvider.AddFromXml(System.Xml.XmlReader,LibLSLCC.LibraryData.LSLLibraryDataLoadOptions)">
            <summary>
                Adds additional library data provider from an XML reader object, the data provider is not cleared first.
            </summary>
            <param name="data">The XML reader to read from.</param>
            <param name="loadOptions">
                Optionally specifies what type's of library definitions will be loaded, defaults to
                <see cref="F:LibLSLCC.LibraryData.LSLLibraryDataLoadOptions.All" />
            </param>
            <exception cref="T:System.ArgumentNullException">When the 'data' parameter is <c>null</c>.</exception>
            <exception cref="T:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException">
                If a syntax error was detected in the XML (Attribute value did not
                pass pattern validation.. etc..)
            </exception>
            <exception cref="T:System.Xml.XmlException">If incorrect XML was encountered in the input stream.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLXmlLibraryDataProvider.AddFromXml(System.String,LibLSLCC.LibraryData.LSLLibraryDataLoadOptions)">
            <summary>
                Adds additional library data provider from an XML file, the data provider is not cleared first.
                Encoding is detected using the BOM (Byte Order Mark) of the file.
            </summary>
            <param name="filename">The XML file to read library data from.</param>
            <param name="loadOptions">
                Optionally specifies what type's of library definitions will be loaded, defaults to
                <see cref="F:LibLSLCC.LibraryData.LSLLibraryDataLoadOptions.All" />
            </param>
            <exception cref="T:System.ArgumentException">When the 'filename' parameter is whitespace.</exception>
            <exception cref="T:System.ArgumentNullException">When the 'filename' parameter is <c>null</c>.</exception>
            <exception cref="T:System.IO.FileNotFoundException">When the file in the 'filename' parameter could not be found.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">
                When the path in the 'filename' parameter is invalid, such as being on an
                unmapped drive.
            </exception>
            <exception cref="T:System.IO.IOException">
                When the path in the 'filename' parameter includes an incorrect or invalid syntax for a
                file name, directory name, or volume label.
            </exception>
            <exception cref="T:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException">
                If a syntax error was detected in the XML (Attribute value did not
                pass pattern validation.. etc..)
            </exception>
            <exception cref="T:System.Xml.XmlException">If incorrect XML was encountered in the input stream.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLXmlLibraryDataProvider.AddFromXmlDirectory(System.String,LibLSLCC.LibraryData.LSLLibraryDataLoadOptions)">
            <summary>
                Adds additional library data by parsing every XML file in a given directory, the data provider is not cleared
                first.
            </summary>
            <param name="path">The directory path.</param>
            <param name="loadOptions">
                Optionally specifies what type's of library definitions will be loaded, defaults to
                <see cref="F:LibLSLCC.LibraryData.LSLLibraryDataLoadOptions.All" />
            </param>
            <exception cref="T:System.ArgumentNullException">path</exception>
            <exception cref="T:System.ArgumentException">path</exception>
            <exception cref="T:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException">
                If a syntax error was detected in an XML file (Attribute value did
                not pass pattern validation.. etc..)
            </exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">
                When the path in the 'path' parameter is invalid, such as being on an
                unmapped drive.
            </exception>
            <exception cref="T:System.IO.IOException">If an IOException occurs while reading a file.</exception>
            <exception cref="T:System.Security.SecurityException">
                The caller does not have the required permission.
                <see cref="M:System.IO.Directory.EnumerateFiles(System.String)" />.
            </exception>
            <exception cref="T:System.UnauthorizedAccessException">
                The caller does not have the required permission.
                <see cref="M:System.IO.Directory.EnumerateFiles(System.String)" />.
            </exception>
            <exception cref="T:System.Xml.XmlException">If incorrect XML was encountered in the input stream of a file.</exception>
            <exception cref="T:System.IO.PathTooLongException">
                A path, file name, or combined exceed the system-defined maximum length. For
                example, on Windows-based platforms, paths must be less than 248 characters and file names must be less than 260
                characters.
            </exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLXmlLibraryDataProvider.FillFromXmlDirectory(System.String,LibLSLCC.LibraryData.LSLLibraryDataLoadOptions)">
            <summary>
                Fills a library data provider by parsing every XML file in a given directory, the data provider is cleared of all
                definitions first.
            </summary>
            <param name="path">The directory path.</param>
            <param name="loadOptions">
                Optionally specifies what type's of library definitions will be loaded, defaults to
                <see cref="F:LibLSLCC.LibraryData.LSLLibraryDataLoadOptions.All" />
            </param>
            <exception cref="T:System.ArgumentNullException">path</exception>
            <exception cref="T:System.ArgumentException">path</exception>
            <exception cref="T:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException">
                If a syntax error was detected in an XML file (Attribute value did
                not pass pattern validation.. etc..)
            </exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">
                When the path in the 'path' parameter is invalid, such as being on an
                unmapped drive.
            </exception>
            <exception cref="T:System.IO.IOException">If an IOException occurs while reading a file.</exception>
            <exception cref="T:System.Security.SecurityException">
                The caller does not have the required permission.
                <see cref="M:System.IO.Directory.EnumerateFiles(System.String)" />.
            </exception>
            <exception cref="T:System.UnauthorizedAccessException">
                The caller does not have the required permission.
                <see cref="M:System.IO.Directory.EnumerateFiles(System.String)" />.
            </exception>
            <exception cref="T:System.Xml.XmlException">If incorrect XML was encountered in the input stream of a file.</exception>
            <exception cref="T:System.IO.PathTooLongException">
                A path, file name, or combined exceed the system-defined maximum length. For
                example, on Windows-based platforms, paths must be less than 248 characters and file names must be less than 260
                characters.
            </exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLXmlLibraryDataProvider.FillFromXml(System.String,LibLSLCC.LibraryData.LSLLibraryDataLoadOptions)">
            <summary>
                Fills a library data provider from an XML reader object, the data provider is cleared of all definitions first.
                Encoding is detected using the BOM (Byte Order Mark) of the file.
            </summary>
            <param name="filename">The XML file to read library data from.</param>
            <param name="loadOptions">
                Optionally specifies what type's of library definitions will be loaded, defaults to
                <see cref="F:LibLSLCC.LibraryData.LSLLibraryDataLoadOptions.All" />
            </param>
            <exception cref="T:System.ArgumentException">When the 'filename' parameter is whitespace.</exception>
            <exception cref="T:System.ArgumentNullException">When the 'filename' parameter is <c>null</c>.</exception>
            <exception cref="T:System.IO.FileNotFoundException">When the file in the 'filename' parameter could not be found.</exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">
                When the path in the 'filename' parameter is invalid, such as being on an
                unmapped drive.
            </exception>
            <exception cref="T:System.IO.IOException">
                When the path in the 'filename' parameter includes an incorrect or invalid syntax for a
                file name, directory name, or volume label.
            </exception>
            <exception cref="T:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException">
                If a syntax error was detected in the XML (Attribute value did not
                pass pattern validation.. etc..)
            </exception>
            <exception cref="T:System.Xml.XmlException">If incorrect XML was encountered in the input stream.</exception>
        </member>
        <member name="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature">
            <summary>
                Represents the signature of a constant provided from an <see cref="T:LibLSLCC.LibraryData.ILSLLibraryDataProvider" /> implementation
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryConstantSignature.#ctor(LibLSLCC.LibraryData.LSLLibraryConstantSignature)">
            <summary>
                Construct the <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" /> by cloning another one.
            </summary>
            <param name="other">The other <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" />.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryConstantSignature.#ctor(LibLSLCC.CodeValidator.LSLType,System.String)">
            <summary>
                Construct the LSLLibraryConstantSignature from a given <see cref="T:LibLSLCC.CodeValidator.LSLType" /> and constant name.
                <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.ValueString" /> is given the default
                value for the given <see cref="T:LibLSLCC.CodeValidator.LSLType" /> passed in <paramref name="type" />
            </summary>
            <param name="type">The constant type.</param>
            <param name="name">The constant name.</param>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException">If <paramref name="name" /> is an invalid LSL ID token.</exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidConstantTypeException">
                if <paramref name="type" /> is
                <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" />.
            </exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryConstantSignature.#ctor(LibLSLCC.CodeValidator.LSLType,System.String,System.String)">
            <summary>
                Construct the LSLLibraryConstantSignature from a given <see cref="T:LibLSLCC.CodeValidator.LSLType" />, constant name, and Value string.
            </summary>
            <param name="type">The constant type.</param>
            <param name="name">The constant name.</param>
            <param name="valueString">
                The string value that represents the constant.  Must be appropriate for
                <paramref name="type" />.
            </param>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException">If <paramref name="name" /> is an invalid LSL ID token.</exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidConstantTypeException">
                if <paramref name="type" /> is
                <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" />.
            </exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidConstantValueStringException">
                If <paramref name="valueString" /> is an invalid value for a float and <paramref name="type" /> is set to
                <see cref="F:LibLSLCC.CodeValidator.LSLType.Float" />
                or
                If <paramref name="valueString" /> is an invalid value for an integer and <paramref name="type" /> is set to
                <see cref="F:LibLSLCC.CodeValidator.LSLType.Integer" />
                or
                If <paramref name="valueString" /> is an invalid value for a vector and <paramref name="type" /> is set to
                <see cref="F:LibLSLCC.CodeValidator.LSLType.Vector" />
                or
                If <paramref name="valueString" /> is an invalid value for a rotation and <paramref name="type" /> is set to
                <see cref="F:LibLSLCC.CodeValidator.LSLType.Rotation" />
            </exception>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryConstantSignature.Expand">
            <summary>
                A hint to compilers, if Expand is true then the constant's value should be expanded and placed
                into the generated code, otherwise if Expand is false the constants value should be retrieved
                by referencing the constant by name in the current object or some other object where constants
                are stored.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryConstantSignature.Subsets">
            <summary>
                The library subsets this signature belongs to/is shared among.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryConstantSignature.Properties">
            <summary>
                Additional dynamic property values that can be attached to the constant signature and parsed from XML
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryConstantSignature.DocumentationString">
            <summary>
                Gets or sets the documentation string attached to this signature.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryConstantSignature.SignatureAndDocumentation">
            <summary>
                Combines the SignatureString and Documentation string.  The signature will
                have a trailing semi-colon, and if there is a documentation string a new-line will
                be inserted between the signature and documentation string.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryConstantSignature.Deprecated">
            <summary>
                Whether or not this constant is marked as deprecated.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryConstantSignature.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <summary>
                This method is reserved and should not be used. When implementing the IXmlSerializable interface, you should return
                null (Nothing in Visual Basic) from this method, and instead, if specifying a custom schema is required, apply the
                <see cref="T:System.Xml.Serialization.XmlSchemaProviderAttribute" /> to the class.
            </summary>
            <returns>
                An <see cref="T:System.Xml.Schema.XmlSchema" /> that describes the XML representation of the object that is
                produced by the <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> method
                and consumed by the <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />
                method.
            </returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryConstantSignature.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <summary>
                Fills a constant signature object from an XML fragment.
            </summary>
            <param name="reader">The XML reader containing the fragment to read.</param>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException">
                Thrown if the constants name does not abide by LSL symbol naming
                conventions.
            </exception>
            <exception cref="T:LibLSLCC.LibraryData.LSLInvalidSubsetNameException">
                Thrown if any of the given subset names in the CSV 'Subsets' string do
                not match the pattern ([a-zA-Z]+[a-zA-Z_0-9\\-]*).
            </exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidConstantTypeException">if 'Type' is <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" />.</exception>
            <exception cref="T:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException">
                On missing or unknown attributes.
                If the constant 'Type' is <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" />.
                If the constant 'Type' does not correspond to an <see cref="T:LibLSLCC.CodeValidator.LSLType" /> enumeration member.
                If a 'Properties' node 'Name' is <c>null</c> or whitespace.
                If a 'Properties' node 'Name' is used more than once.
                If a 'Properties' node 'Value' is <c>null</c> or whitespace.
            </exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidConstantValueStringException">
                If 'Value' is an invalid value for a float and <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" /> is set to <see cref="F:LibLSLCC.CodeValidator.LSLType.Float" />
                or
                If 'Value' is an invalid value for an integer and <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" /> is set to <see cref="F:LibLSLCC.CodeValidator.LSLType.Integer" />
                or
                If 'Value' is an invalid value for a vector and <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" /> is set to <see cref="F:LibLSLCC.CodeValidator.LSLType.Vector" />
                or
                If 'Value' is an invalid value for a rotation and <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" /> is set to <see cref="F:LibLSLCC.CodeValidator.LSLType.Rotation" />
            </exception>
            <exception cref="T:System.Xml.XmlException">Incorrect XML encountered in the input stream. </exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryConstantSignature.WriteXml(System.Xml.XmlWriter)">
            <summary>
                Converts this <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" /> into its XML representation.
                The root element name is not written, this is due to <see cref="T:System.Xml.Serialization.IXmlSerializable" /> implementation requirements.
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> stream to which the object is serialized. </param>
            <exception cref="T:System.InvalidOperationException"><paramref name="writer" /> is closed.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="writer" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryConstantSignature.FromXmlFragment(System.Xml.XmlReader)">
            <summary>
                Creates a constant signature object from an XML fragment.
            </summary>
            <param name="reader">The XML reader containing the fragment to read.</param>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException">
                Thrown if the constants name does not abide by LSL symbol naming
                conventions.
            </exception>
            <exception cref="T:LibLSLCC.LibraryData.LSLInvalidSubsetNameException">
                Thrown if any of the given subset names in the CSV 'Subsets' string do
                not match the pattern ([a-zA-Z]+[a-zA-Z_0-9\\-]*).
            </exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidConstantTypeException">if 'Type' is <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" />.</exception>
            <exception cref="T:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException">
                On missing or unknown attributes.
                If the constant 'Type' is <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" />.
                If the constant 'Type' does not correspond to an <see cref="T:LibLSLCC.CodeValidator.LSLType" /> enumeration member.
                If a 'Properties' node 'Name' is <c>null</c> or whitespace.
                If a 'Properties' node 'Name' is used more than once.
                If a 'Properties' node 'Value' is <c>null</c> or whitespace.
            </exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidConstantValueStringException">
                If 'Value' is an invalid value for a float and <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" /> is set to <see cref="F:LibLSLCC.CodeValidator.LSLType.Float" />
                or
                If 'Value' is an invalid value for an integer and <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" /> is set to <see cref="F:LibLSLCC.CodeValidator.LSLType.Integer" />
                or
                If 'Value' is an invalid value for a vector and <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" /> is set to <see cref="F:LibLSLCC.CodeValidator.LSLType.Vector" />
                or
                If 'Value' is an invalid value for a rotation and <see cref="P:LibLSLCC.CodeValidator.LSLConstantSignature.Type" /> is set to <see cref="F:LibLSLCC.CodeValidator.LSLType.Rotation" />
            </exception>
            <exception cref="T:System.Xml.XmlException">Incorrect XML encountered in the input stream. </exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader" /> is <c>null</c>.</exception>
            <returns>The parsed <see cref="T:LibLSLCC.LibraryData.LSLLibraryConstantSignature" /> object.</returns>
        </member>
        <member name="T:LibLSLCC.LibraryData.LSLLibraryEventSignature">
            <summary>
                Represents a library event handler returned from an <see cref="T:LibLSLCC.LibraryData.ILSLLibraryDataProvider" /> implementation.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryEventSignature.#ctor(LibLSLCC.CodeValidator.ILSLEventSignature)">
            <summary>
                Construct an LSLLibraryEventSignature by copying the signature details from an <see cref="T:LibLSLCC.CodeValidator.ILSLEventSignature" />
                object.
            </summary>
            <param name="sig">The <see cref="T:LibLSLCC.CodeValidator.ILSLEventSignature" /> object to copy signatures details from.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryEventSignature.#ctor(LibLSLCC.LibraryData.LSLLibraryEventSignature)">
            <summary>
                Construct an LSLLibraryEventSignature by cloning another LSLLibraryEventSignature object.
            </summary>
            <param name="other">The LSLLibraryEventSignature to copy construct from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryEventSignature.#ctor(System.String,System.Collections.Generic.IEnumerable{LibLSLCC.CodeValidator.LSLParameterSignature})">
            <summary>
                Construct an LSLLibraryEventSignature by providing a Name and a list of <see cref="T:LibLSLCC.CodeValidator.LSLParameterSignature" /> objects that
                belong to the signature.
            </summary>
            <param name="name">The name of the event handler.</param>
            <param name="parameters">The list of parameters that belong to this signature.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryEventSignature.#ctor(System.String)">
            <summary>
                Construct an LSLLibraryEventSignature with no parameters by providing an event Name only.
            </summary>
            <param name="name">The name of the event Handler.</param>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryEventSignature.Subsets">
            <summary>
                The library subsets that this LSLLibraryEventSignature belongs to.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryEventSignature.Properties">
            <summary>
                Additional dynamic property values that can be attached to the constant signature and parsed from XML
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryEventSignature.DocumentationString">
            <summary>
                Returns the documentation string attached to this library signature.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryEventSignature.SignatureAndDocumentation">
            <summary>
                Returns a formated string containing the signature and documentation for this library signature.
                It consists of the SignatureString followed by a semi-colon, and then followed by a new-line and
                DocumentationString
                if the documentation string is not null.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryEventSignature.Deprecated">
            <summary>
                Whether or not this library signature is marked as deprecated or not.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryEventSignature.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <summary>
                This method is reserved and should not be used. When implementing the IXmlSerializable interface, you should return
                null (Nothing in Visual Basic) from this method, and instead, if specifying a custom schema is required, apply the
                <see cref="T:System.Xml.Serialization.XmlSchemaProviderAttribute" /> to the class.
            </summary>
            <returns>
                An <see cref="T:System.Xml.Schema.XmlSchema" /> that describes the XML representation of the object that is
                produced by the <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> method
                and consumed by the <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />
                method.
            </returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryEventSignature.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <summary>
                Fills an event signature object from an XML fragment.
            </summary>
            <param name="reader">The XML reader containing the fragment to read.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="reader" /> is <c>null</c>.</exception>
            <exception cref="T:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException">
                On missing or unknown attributes.
                If a parameter 'Name' is used more than once.
                If a parameter 'Name' is whitespace.
                If a parameter 'Type' is <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" />.
                If a parameter 'Type' does not correspond to an <see cref="T:LibLSLCC.CodeValidator.LSLType" /> enumeration member.
                If a 'Properties' node 'Name' is <c>null</c> or whitespace.
                If a 'Properties' node 'Name' is used more than once.
                If a 'Properties' node 'Value' is <c>null</c> or whitespace.
            </exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException">
                Thrown if the event signatures name or any of its parameters names do
                not abide by LSL symbol naming conventions.
            </exception>
            <exception cref="T:System.Xml.XmlException">Incorrect XML encountered in the input stream. </exception>
            <exception cref="T:LibLSLCC.LibraryData.LSLInvalidSubsetNameException">
                Thrown if any of the given subset names in the 'Subsets' CSV string do
                not match the pattern ([a-zA-Z]+[a-zA-Z_0-9\\-]*).
            </exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryEventSignature.WriteXml(System.Xml.XmlWriter)">
            <summary>
                Converts this <see cref="T:LibLSLCC.LibraryData.LSLLibraryEventSignature" /> into its XML representation.
                The root element name is not written, this is due to <see cref="T:System.Xml.Serialization.IXmlSerializable" /> implementation requirements.
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> stream to which the object is serialized. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="writer" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryEventSignature.Parse(System.String)">
            <summary>
                Attempts to parse the signature from a formated string.
                Such as:  listen( integer channel, string name, key id, string message )
                Trailing semi-colon is optional.
            </summary>
            <param name="str"></param>
            <exception cref="T:System.ArgumentException">Thrown if the string could not be parsed.</exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <returns>The Parsed LSLLibraryEventSignature</returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryEventSignature.FromXmlFragment(System.Xml.XmlReader)">
            <summary>
                Reads an event signature object from an XML fragment.
            </summary>
            <param name="reader">The XML reader containing the fragment to read.</param>
            <exception cref="T:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException">
                On missing or unknown attributes.
                If a parameter 'Name' is used more than once.
                If a parameter 'Name' is whitespace.
                If a parameter 'Type' is <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" />.
                If a parameter 'Type' does not correspond to an <see cref="T:LibLSLCC.CodeValidator.LSLType" /> enumeration member.
                If a 'Properties' node 'Name' is <c>null</c> or whitespace.
                If a 'Properties' node 'Name' is used more than once.
                If a 'Properties' node 'Value' is <c>null</c> or whitespace.
            </exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException">
                Thrown if the event signatures name or any of its parameters names do
                not abide by LSL symbol naming conventions.
            </exception>
            <exception cref="T:System.Xml.XmlException">Incorrect XML encountered in the input stream. </exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader" /> is <c>null</c>.</exception>
            <exception cref="T:LibLSLCC.LibraryData.LSLInvalidSubsetNameException">
                Thrown if any of the given subset names in the 'Subsets' CSV string do
                not match the pattern ([a-zA-Z]+[a-zA-Z_0-9\\-]*).
            </exception>
            <returns>The parsed <see cref="T:LibLSLCC.LibraryData.LSLLibraryEventSignature" /> object.</returns>
        </member>
        <member name="T:LibLSLCC.LibraryData.LSLLibraryFunctionSignature">
            <summary>
                Represents a library function signature returned from an implementation of <see cref="T:LibLSLCC.LibraryData.ILSLLibraryDataProvider" />.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryFunctionSignature.#ctor(LibLSLCC.CodeValidator.LSLFunctionSignature)">
            <summary>
                Construct a library function signature by copying the details from a basic function signature.
            </summary>
            <param name="other">The basic <see cref="T:LibLSLCC.CodeValidator.LSLFunctionSignature" /> to copy details from.</param>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryFunctionSignature.#ctor(LibLSLCC.LibraryData.LSLLibraryFunctionSignature)">
            <summary>
                Construct a library function signature by cloning another LSLLibraryFunctionSignature object.
            </summary>
            <param name="other">The <see cref="T:LibLSLCC.LibraryData.LSLLibraryFunctionSignature"/> to clone from.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryFunctionSignature.#ctor(LibLSLCC.CodeValidator.LSLType,System.String,System.Collections.Generic.IEnumerable{LibLSLCC.CodeValidator.LSLParameterSignature})">
            <summary>
                Construct a library function signature by supplying an LSLType for the return type, a function Name and an optional
                enumerable of LSLParameters.
            </summary>
            <param name="returnType">The return type associated with the function signature.</param>
            <param name="name">The name of the function.</param>
            <param name="parameters">An optional enumerable of <see cref="T:LibLSLCC.CodeValidator.LSLParameterSignature"/> to initialize the function signature with.</param>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryFunctionSignature.ModInvoke">
            <summary>
                Determines whether or not this LSLLibraryFunctionSignature will need to be called using OpenSims modInvoke* API.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryFunctionSignature.Subsets">
            <summary>
                The library subsets this signature belongs to/is shared among.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryFunctionSignature.Properties">
            <summary>
                Additional dynamic property values that can be attached to the constant signature and parsed from XML
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryFunctionSignature.DocumentationString">
            <summary>
                Returns the documentation string attached to this library signature.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryFunctionSignature.SignatureAndDocumentation">
            <summary>
                Returns a formated string containing the signature and documentation for this library signature.
                It consists of the SignatureString followed by a semi-colon, and then followed by a new-line and
                DocumentationString
                if the documentation string is not null.
            </summary>
        </member>
        <member name="P:LibLSLCC.LibraryData.LSLLibraryFunctionSignature.Deprecated">
            <summary>
                Whether or not this library signature is marked as deprecated or not.
            </summary>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryFunctionSignature.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <summary>
                This method is reserved and should not be used. When implementing the IXmlSerializable interface, you should return
                null (Nothing in Visual Basic) from this method, and instead, if specifying a custom schema is required, apply the
                <see cref="T:System.Xml.Serialization.XmlSchemaProviderAttribute" /> to the class.
            </summary>
            <returns>
                An <see cref="T:System.Xml.Schema.XmlSchema" /> that describes the XML representation of the object that is
                produced by the <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> method
                and consumed by the <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />
                method.
            </returns>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryFunctionSignature.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <summary>
                Fills a function signature object from an XML fragment.
            </summary>
            <param name="reader">The XML reader containing the fragment to read.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="reader" /> is <c>null</c>.</exception>
            <exception cref="T:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException">
                On missing or unknown attributes.
                If a parameter 'Name' is used more than once.
                If a parameter 'Name' is whitespace.
                If a parameter 'Type' is <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" /> and not Variadic.
                If a parameter 'Type' does not correspond to an <see cref="T:LibLSLCC.CodeValidator.LSLType" /> enumeration member.
                If a 'Properties' node 'Name' is <c>null</c> or whitespace.
                If a 'Properties' node 'Name' is used more than once.
                If a 'Properties' node 'Value' is <c>null</c> or whitespace.
            </exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException">
                Thrown if the function signatures name or any of its parameters names
                do not abide by LSL symbol naming conventions.
            </exception>
            <exception cref="T:System.Xml.XmlException">Incorrect XML encountered in the input stream. </exception>
            <exception cref="T:LibLSLCC.LibraryData.LSLInvalidSubsetNameException">
                Thrown if any of the given subset names in the 'Subsets' CSV string do
                not match the pattern ([a-zA-Z]+[a-zA-Z_0-9\\-]*).
            </exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryFunctionSignature.WriteXml(System.Xml.XmlWriter)">
            <summary>
                Converts this <see cref="T:LibLSLCC.LibraryData.LSLLibraryFunctionSignature" /> into its XML representation.
                The root element name is not written, this is due to <see cref="T:System.Xml.Serialization.IXmlSerializable" /> implementation requirements.
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter" /> stream to which the object is serialized. </param>
            <exception cref="T:System.InvalidOperationException">The <paramref name="writer" /> is closed. </exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="writer" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryFunctionSignature.Parse(System.String)">
            <summary>
                Attempt to parse a function signature from a formated string.
                Such as: float llAbs(float value) or llOwnerSay(string message);
            </summary>
            <param name="str">The string containing the formated function signature.</param>
            <returns>The LSLLibraryFunctionSignature that was parsed from the string, or null.</returns>
            <exception cref="T:System.ArgumentException">If there was a syntax error while parsing the function signature.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="str" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.LibraryData.LSLLibraryFunctionSignature.FromXmlFragment(System.Xml.XmlReader)">
            <summary>
                Reads a function signature object from an XML fragment.
            </summary>
            <param name="reader">The XML reader containing the fragment to read.</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="reader" /> is <c>null</c>.</exception>
            <exception cref="T:LibLSLCC.LibraryData.LSLLibraryDataXmlSyntaxException">
                On missing or unknown attributes.
                If a parameter 'Name' is used more than once.
                If a parameter 'Name' is whitespace.
                If a parameter 'Type' is <see cref="F:LibLSLCC.CodeValidator.LSLType.Void" /> and not Variadic.
                If a parameter 'Type' does not correspond to an <see cref="T:LibLSLCC.CodeValidator.LSLType" /> enumeration member.
                If a 'Properties' node 'Name' is <c>null</c> or whitespace.
                If a 'Properties' node 'Name' is used more than once.
                If a 'Properties' node 'Value' is <c>null</c> or whitespace.
            </exception>
            <exception cref="T:LibLSLCC.CodeValidator.LSLInvalidSymbolNameException">
                Thrown if the function signatures name or any of its parameters names
                do not abide by LSL symbol naming conventions.
            </exception>
            <exception cref="T:System.Xml.XmlException">Incorrect XML encountered in the input stream. </exception>
            <exception cref="T:LibLSLCC.LibraryData.LSLInvalidSubsetNameException">
                Thrown if any of the given subset names in the 'Subsets' CSV string do
                not match the pattern ([a-zA-Z]+[a-zA-Z_0-9\\-]*).
            </exception>
            <returns>The parsed <see cref="T:LibLSLCC.LibraryData.LSLLibraryFunctionSignature" /> object.</returns>
        </member>
        <member name="T:LibLSLCC.Settings.CloningDefaultValueFactory`1">
            <summary>
                An implementation of <see cref="T:LibLSLCC.Settings.IDefaultSettingsValueFactory" /> that gets its
                default values by cloning from a static instance of the provided generic type.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:LibLSLCC.Settings.CloningDefaultValueFactory`1.CheckForNecessaryResets(System.Reflection.MemberInfo,System.Object,System.Object)">
            <summary>
                The default implementation simply checks the property value for <c>null</c>.
            </summary>
            <param name="member">The member of the settings field/property being checked for a necessary reset.</param>
            <param name="objectInstance">The object instance the settings field/property belongs to.</param>
            <param name="settingValue">The value of the settings field/property being checked.</param>
            <returns>Whether or not <paramref name="settingValue"/> equals <c>null</c>.</returns>
        </member>
        <member name="M:LibLSLCC.Settings.CloningDefaultValueFactory`1.GetDefaultValue(System.Reflection.MemberInfo,System.Object)">
            <summary>
                Returns the default value for a given settings member (field/property).
            </summary>
            <param name="member">The <see cref="T:System.Reflection.FieldInfo" /> or <see cref="T:System.Reflection.PropertyInfo" /> of the settings field/property.</param>
            <param name="objectInstance">The settings object instance.</param>
            <returns>The default value for the field/property.</returns>
            <exception cref="T:System.ArgumentException">
                Thrown if <paramref name="member" /> is not a <see cref="T:System.Reflection.FieldInfo" /> or
                <see cref="T:System.Reflection.PropertyInfo" /> object.
            </exception>
        </member>
        <member name="T:LibLSLCC.Settings.DefaultCloner">
            <summary>
                The default implementation of <see cref="T:LibLSLCC.Settings.ICloner" />.
                This implementation clones an object by using its <see cref="T:System.ICloneable" /> interface, or searching directly for a
                method named "Clone" with zero parameters.
            </summary>
        </member>
        <member name="M:LibLSLCC.Settings.DefaultCloner.Clone(System.Object)">
            <summary>
                Create a clone of the object <paramref name="instance" /> using its <see cref="T:System.ICloneable" /> interface, or by
                searching directly for a method named "Clone" with zero parameters.
            </summary>
            <param name="instance">The object to clone.</param>
            <returns>The cloned object.</returns>
        </member>
        <member name="T:LibLSLCC.Settings.ICloner">
            <summary>
                Interface for an object that can clone another object.
            </summary>
        </member>
        <member name="M:LibLSLCC.Settings.ICloner.Clone(System.Object)">
            <summary>
                Create a clone of the object <paramref name="instance" />.
            </summary>
            <param name="instance">The object to clone.</param>
            <returns>The cloned object.</returns>
        </member>
        <member name="T:LibLSLCC.Settings.MemberClonerAttribute">
            <summary>
                An attribute to specify a specific <see cref="T:LibLSLCC.Settings.ICloner" /> implementation for a field/property in an object derived
                from <see cref="T:LibLSLCC.Settings.SettingsBaseClass`1" />.
            </summary>
            <seealso cref="T:LibLSLCC.Settings.SettingsBaseClass`1" />
            <seealso cref="M:LibLSLCC.Settings.SettingsBaseClass`1.Clone" />
        </member>
        <member name="M:LibLSLCC.Settings.MemberClonerAttribute.#ctor(System.Type)">
            <summary>
                Construct an <see cref="T:LibLSLCC.Settings.MemberClonerAttribute" /> with a given <see cref="T:System.Type" />.
                The <see cref="T:System.Type" /> should implement <see cref="T:LibLSLCC.Settings.ICloner" />.
            </summary>
            <param name="clonerType">
                The <see cref="T:System.Type" /> which implements <see cref="T:LibLSLCC.Settings.ICloner" /> and will preform the clone
                operation for a given field/property.
            </param>
        </member>
        <member name="P:LibLSLCC.Settings.MemberClonerAttribute.ClonerType">
            <summary>
                The <see cref="T:System.Type" /> which implements <see cref="T:LibLSLCC.Settings.ICloner" />
            </summary>
        </member>
        <member name="T:LibLSLCC.Settings.DefaultValueFactoryAttribute">
            <summary>
                An attribute for defining a default value factory for a field or property.
            </summary>
            <seealso cref="T:LibLSLCC.Settings.DefaultValueInitializer" />
        </member>
        <member name="M:LibLSLCC.Settings.DefaultValueFactoryAttribute.#ctor(System.Type,System.Int32)">
            <summary>
                Construct the <see cref="T:LibLSLCC.Settings.DefaultValueFactoryAttribute" /> using a given type and <paramref name="initOrder" />.
            </summary>
            <param name="factoryType">
                The <see cref="T:System.Type" /> for producing default field/property values, which should derive from
                <see cref="T:LibLSLCC.Settings.IDefaultSettingsValueFactory" />.
            </param>
            <param name="initOrder">
                The priority of default value initialization for this field/property when
                <see cref="M:LibLSLCC.Settings.DefaultValueInitializer.Init``1(``0)" /> is used.
            </param>
            <exception cref="T:System.ArgumentException">
                Thrown if <paramref name="factoryType" /> does not implement
                <see cref="T:LibLSLCC.Settings.IDefaultSettingsValueFactory" />.
            </exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="factoryType"/> is <c>null</c>.</exception>
        </member>
        <member name="P:LibLSLCC.Settings.DefaultValueFactoryAttribute.FactoryType">
            <summary>
                The <see cref="T:System.Type" /> of the default value factory used to create a default value for the field/property.
            </summary>
        </member>
        <member name="P:LibLSLCC.Settings.DefaultValueFactoryAttribute.InitOrder">
            <summary>
                The priority of default value initialization for this field/property when
                <see cref="M:LibLSLCC.Settings.DefaultValueInitializer.Init``1(``0)" /> is used.
            </summary>
        </member>
        <member name="P:LibLSLCC.Settings.DefaultValueFactoryAttribute.Factory">
            <summary>
                An instance of the default value factory type, specified by <see cref="P:LibLSLCC.Settings.DefaultValueFactoryAttribute.FactoryType" />.
            </summary>
        </member>
        <member name="T:LibLSLCC.Settings.DefaultValueInitializer">
            <summary>
                A static class with utilities for initializing an objects field/property's with default values.
            </summary>
            <seealso cref="T:LibLSLCC.Settings.IDefaultSettingsValueFactory" />
            <seealso cref="T:LibLSLCC.Settings.DefaultValueFactoryAttribute" />
            <seealso cref="T:System.ComponentModel.DefaultValueAttribute" />
        </member>
        <member name="M:LibLSLCC.Settings.DefaultValueInitializer.GetDefaultValue``1(``0,System.String)">
            <summary>
                Get the default value for a given public instance field/property in an object instance.
            </summary>
            <param name="instance">The object instance.</param>
            <param name="memberName">The field/property name.</param>
            <typeparam name="T">The <see cref="T:System.Type" /> of <paramref name="instance" /></typeparam>
            <returns>The default value for the public field/property specified by <paramref name="memberName" />.</returns>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    If <paramref name="instance" /> or <paramref name="memberName" /> are <c>null</c>.
                </para>
            </exception>
            <exception cref="T:System.ArgumentException">
                <para>
                    If <paramref name="memberName" /> is a property that is not both readable and writable.
                </para>
                <para>
                    If <paramref name="memberName" /> is all whitespace.
                </para>
                <para>
                    If <paramref name="memberName" /> does not exist in <paramref name="instance" />.
                </para>
            </exception>
            <exception cref="T:System.InvalidOperationException">
                <para>
                    If the field/property does not possess a <see cref="T:LibLSLCC.Settings.DefaultValueFactoryAttribute" /> or
                    <see cref="T:System.ComponentModel.DefaultValueAttribute" /> and
                    its declared type possesses no default constructor.
                </para>
                <para>
                    If the field/property possesses both <see cref="T:LibLSLCC.Settings.DefaultValueFactoryAttribute" /> and
                    <see cref="T:System.ComponentModel.DefaultValueAttribute" /> at once.
                </para>
            </exception>
            <seealso cref="T:LibLSLCC.Settings.IDefaultSettingsValueFactory" />
            <seealso cref="T:LibLSLCC.Settings.DefaultValueFactoryAttribute" />
            <seealso cref="T:System.ComponentModel.DefaultValueAttribute" />
        </member>
        <member name="M:LibLSLCC.Settings.DefaultValueInitializer.SetToDefault``1(``0,System.String)">
            <summary>
                Sets a field/property of <paramref name="instance" /> to its default value.
            </summary>
            <param name="instance">The instance of the object containing the field/property.</param>
            <param name="memberName">The member name of the field/property.</param>
            <typeparam name="T">The <see cref="T:System.Type" /> of <paramref name="instance" /></typeparam>
            <returns>
                <paramref name="instance" />
            </returns>
            <exception cref="T:System.ArgumentNullException">
                If <paramref name="instance" /> or <paramref name="memberName" /> are
                <c>null</c>.
            </exception>
            <exception cref="T:System.ArgumentException">
                <para>
                    If <paramref name="memberName" /> is a property that is not both readable and writable.
                </para>
                <para>
                    If <paramref name="memberName" /> is all whitespace.
                </para>
                <para>
                    If <paramref name="memberName" /> does not exist in <paramref name="instance" />.
                </para>
            </exception>
            <exception cref="T:System.InvalidOperationException">
                <para>
                    If the field/property does not possess a <see cref="T:LibLSLCC.Settings.DefaultValueFactoryAttribute" /> or
                    <see cref="T:System.ComponentModel.DefaultValueAttribute" /> and
                    its declared type possesses no default constructor.
                </para>
                <para>
                    If the field/property possesses both <see cref="T:LibLSLCC.Settings.DefaultValueFactoryAttribute" /> and
                    <see cref="T:System.ComponentModel.DefaultValueAttribute" /> at once.
                </para>
            </exception>
            <seealso cref="T:LibLSLCC.Settings.IDefaultSettingsValueFactory" />
            <seealso cref="T:LibLSLCC.Settings.DefaultValueFactoryAttribute" />
            <seealso cref="T:System.ComponentModel.DefaultValueAttribute" />
        </member>
        <member name="M:LibLSLCC.Settings.DefaultValueInitializer.DoNeccessaryResets``1(``0)">
            <summary>
                <para>
                    Checks for necessary resets on fields/properties of an object using
                    <see cref="M:LibLSLCC.Settings.IDefaultSettingsValueFactory.CheckForNecessaryResets(System.Reflection.MemberInfo,System.Object,System.Object)" />,
                    then resets them to their default value using <see cref="M:LibLSLCC.Settings.IDefaultSettingsValueFactory.GetDefaultValue(System.Reflection.MemberInfo,System.Object)" /> if
                    necessary.
                </para>
                <para>
                    This only affects fields/properties possessing a <see cref="T:LibLSLCC.Settings.DefaultValueFactoryAttribute" />.
                </para>
            </summary>
            <param name="instance">The object instance to check for and preform necessary field/property resets on.</param>
            <typeparam name="T">The <see cref="T:System.Type" /> of <paramref name="instance" />.</typeparam>
            <returns>
                <paramref name="instance" />
            </returns>
            <exception cref="T:System.InvalidOperationException">
                Thrown if a field/property possesses both <see cref="T:LibLSLCC.Settings.DefaultValueFactoryAttribute" /> and
                <see cref="T:System.ComponentModel.DefaultValueAttribute" /> at once.
            </exception>
            <seealso cref="T:LibLSLCC.Settings.IDefaultSettingsValueFactory" />
            <seealso cref="T:LibLSLCC.Settings.DefaultValueFactoryAttribute" />
            <seealso cref="T:System.ComponentModel.DefaultValueAttribute" />
        </member>
        <member name="M:LibLSLCC.Settings.DefaultValueInitializer.Init``1(``0)">
            <summary>
                Initializes all fields/properties in a given object to their default values.
            </summary>
            <param name="instance">The object instance do the field/property reset on.</param>
            <typeparam name="T">The <see cref="T:System.Type" /> of <paramref name="instance" />.</typeparam>
            <returns>
                <paramref name="instance" />
            </returns>
            <exception cref="T:System.InvalidOperationException">
                Thrown if the field/property possesses both <see cref="T:LibLSLCC.Settings.DefaultValueFactoryAttribute" /> and
                <see cref="T:System.ComponentModel.DefaultValueAttribute" /> at once.
            </exception>
            <seealso cref="T:LibLSLCC.Settings.IDefaultSettingsValueFactory" />
            <seealso cref="T:LibLSLCC.Settings.DefaultValueFactoryAttribute" />
            <seealso cref="T:System.ComponentModel.DefaultValueAttribute" />
        </member>
        <member name="T:LibLSLCC.Settings.IDefaultSettingsValueFactory">
            <summary>
                An interface for objects that produce default values for a field/property in another object.
            </summary>
            <seealso cref="T:LibLSLCC.Settings.DefaultValueInitializer" />
        </member>
        <member name="M:LibLSLCC.Settings.IDefaultSettingsValueFactory.CheckForNecessaryResets(System.Reflection.MemberInfo,System.Object,System.Object)">
            <summary>
                Determines whether or not a given field/property needs to be reset to a default value.
            </summary>
            <param name="member">The <see cref="T:System.Reflection.MemberInfo" /> of the field/property.</param>
            <param name="objectInstance">The object instance that owns the field/property.</param>
            <param name="settingValue">The current value of the field/property.</param>
            <returns>Whether or not a given field/property needs to be reset to a default value.</returns>
        </member>
        <member name="M:LibLSLCC.Settings.IDefaultSettingsValueFactory.GetDefaultValue(System.Reflection.MemberInfo,System.Object)">
            <summary>
                Gets the default value of a given field/property in an object.
            </summary>
            <param name="member">The <see cref="T:System.Reflection.MemberInfo" /> of the field/property.</param>
            <param name="objectInstance">The object instance that owns the field/property.</param>
            <returns>The default value of the field/property.</returns>
        </member>
        <member name="T:LibLSLCC.Settings.ObservableSettingsHashSet`1">
            <summary>
                An observable hash set collection that is usable as a member in classes deriving from
                <see cref="T:LibLSLCC.Settings.SettingsBaseClass`1" />
            </summary>
            <typeparam name="T">The type of elements this <see cref="T:LibLSLCC.Settings.ObservableSettingsHashSet`1" /> contains.</typeparam>
        </member>
        <member name="M:LibLSLCC.Settings.ObservableSettingsHashSet`1.#ctor">
            <summary>
                Construct an empty <see cref="T:LibLSLCC.Settings.ObservableSettingsHashSet`1" />
            </summary>
        </member>
        <member name="M:LibLSLCC.Settings.ObservableSettingsHashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
                Construct an <see cref="T:LibLSLCC.Settings.ObservableSettingsHashSet`1" /> containing the elements from
                <paramref name="collection" />.
            </summary>
            <param name="collection">
                The <see cref="T:System.Collections.Generic.IEnumerable`1" /> to fill the <see cref="T:LibLSLCC.Settings.ObservableSettingsHashSet`1" />
                with.
            </param>
        </member>
        <member name="M:LibLSLCC.Settings.ObservableSettingsHashSet`1.GetHashCode">
            <summary>
                Calculates the hash code for this <see cref="T:LibLSLCC.Settings.ObservableSettingsHashSet`1" /> by considering the hash code of every
                element.
            </summary>
            <returns>The generated hash code.</returns>
        </member>
        <member name="M:LibLSLCC.Settings.ObservableSettingsHashSet`1.Equals(System.Object)">
            <summary>
                Determines if every element in this <see cref="T:LibLSLCC.Settings.ObservableSettingsHashSet`1" /> is equal to the elements in
                another, using SequenceEqual.
                If <paramref name="obj" /> is not an <see cref="T:LibLSLCC.Settings.ObservableSettingsHashSet`1" /> object, then this function will
                return <c>false</c>.
            </summary>
            <param name="obj">The object to test for equality with.</param>
            <returns>
                <c>true</c> if <paramref name="obj" /> is an <see cref="T:LibLSLCC.Settings.ObservableSettingsHashSet`1" /> where
                this.SequenceEqual(obj) returns <c>true</c>.
            </returns>
        </member>
        <member name="M:LibLSLCC.Settings.ObservableSettingsHashSet`1.Clone">
            <summary>
                Creates a shallow copy of this <see cref="T:LibLSLCC.Settings.ObservableSettingsHashSet`1"/>..
            </summary>
            <returns>A shallow copy of this <see cref="T:LibLSLCC.Settings.ObservableSettingsHashSet`1"/>.</returns>
        </member>
        <member name="T:LibLSLCC.Settings.SettingsBaseClassTools">
            <summary>
                Misc tools for dealing with classes that derive from <see cref="T:LibLSLCC.Settings.SettingsBaseClass`1" />
            </summary>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsBaseClassTools.HasSettingsBase(System.Type,System.Type@)">
            <summary>
                Detects if a type derives from the generic <see cref="T:LibLSLCC.Settings.SettingsBaseClass`1" />
            </summary>
            <param name="type">The type to test.</param>
            <param name="baseType">
                Outputs the full generic type of the <see cref="T:LibLSLCC.Settings.SettingsBaseClass`1" /> if the class derives
                from it, otherwise <c>null</c>.
            </param>
            <returns><c>true</c> if the class derives from a form of <see cref="T:LibLSLCC.Settings.SettingsBaseClass`1" /></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="type"/> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsBaseClassTools.HasSettingsBase(System.Type)">
            <summary>
                Detects if a type derives from the generic <see cref="T:LibLSLCC.Settings.SettingsBaseClass`1" />
            </summary>
            <param name="type">The type to test.</param>
            <returns><c>true</c> if the class derives from a form of <see cref="T:LibLSLCC.Settings.SettingsBaseClass`1" /></returns>
        </member>
        <member name="T:LibLSLCC.Settings.SettingsManager`1">
            <summary>
                Manages loading a serializable settings object to and from disk.  <see cref="T:LibLSLCC.Settings.SettingsBaseClass`1" />
            </summary>
            <typeparam name="T">The type of settings object to manage; typically an object derived from <see cref="T:LibLSLCC.Settings.SettingsBaseClass`1" />.</typeparam>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsManager`1.#ctor(`0)">
            <summary>
                Create a <see cref="T:LibLSLCC.Settings.SettingsManager`1" /> around an initial settings object.
            </summary>
            <param name="settings">The initial settings object.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="settings" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsManager`1.#ctor">
            <summary>
                Create a <see cref="T:LibLSLCC.Settings.SettingsManager`1" /> with no initial settings object.
            </summary>
        </member>
        <member name="P:LibLSLCC.Settings.SettingsManager`1.Settings">
            <summary>
                The settings object being managed.
            </summary>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsManager`1.Save(System.String)">
            <summary>
                Save the settings object to disk.
            </summary>
            <param name="file">The name of the file name to save to.</param>
            <exception cref="T:System.UnauthorizedAccessException">
                The caller does not have the required permission.-or-
                <paramref name="file" /> specified a file that is read-only.
            </exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid (for example, it is on an unmapped drive). </exception>
            <exception cref="T:System.IO.IOException">An I/O error occurred while creating the file. </exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="file" /> is a zero-length string, contains only white space, or
                contains one or more invalid characters as defined by <see cref="F:System.IO.Path.InvalidPathChars" />.
            </exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="file" /> is <c>null</c>. </exception>
            <exception cref="T:System.IO.PathTooLongException">
                The specified path, file name, or both exceed the system-defined maximum length.
                For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than
                260 characters.
            </exception>
            <exception cref="T:System.NotSupportedException"><paramref name="file" /> is in an invalid path format. </exception>
            <exception cref="T:System.InvalidOperationException">
                An error occurred during serialization. The original exception is available
                using the <see cref="P:System.Exception.InnerException" /> property.
            </exception>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsManager`1.Save(System.IO.Stream,System.Boolean)">
            <summary>
                Save the settings object to a stream.
            </summary>
            <param name="stream">The stream to save the settings to.</param>
            <param name="closeOutput"><c>true</c> if <paramref name="stream"/> should be closed by this function, default is <c>false</c>.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="stream" /> value is null.</exception>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsManager`1.ApplyDefaults">
            <summary>
                Reset all settings properties to default in the settings managed settings object.
            </summary>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsManager`1.Load(System.String)">
            <summary>
                Load the settings object from the specified file.
            </summary>
            <param name="file">The file to load the managed settings object from.</param>
            <exception cref="T:System.ArgumentException">
                <paramref name="file" /> is a zero-length string, contains only white space, or
                contains one or more invalid characters as defined by <see cref="F:System.IO.Path.InvalidPathChars" />.
            </exception>
            <exception cref="T:System.NotSupportedException"><paramref name="file" /> is in an invalid path format. </exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="file" /> is <c>null</c>. </exception>
            <exception cref="T:System.IO.PathTooLongException">
                The specified path, file name, or both exceed the system-defined maximum length.
                For example, on Windows-based platforms, paths must be less than 248 characters, and file names must be less than
                260 characters.
            </exception>
            <exception cref="T:System.IO.FileNotFoundException">The file specified in <paramref name="file" /> was not found. </exception>
            <exception cref="T:System.IO.DirectoryNotFoundException">The specified path is invalid, (for example, it is on an unmapped drive). </exception>
            <exception cref="T:System.UnauthorizedAccessException">
                <paramref name="file" /> specified a directory.-or- The caller does not
                have the required permission.
            </exception>
            <exception cref="T:System.InvalidOperationException">An error occurred during deserialization. The original exception is available using the <see cref="P:System.Exception.InnerException" /> property. </exception>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsManager`1.Load(System.IO.Stream,System.Boolean)">
            <summary>
                Load the settings object from the specified file.
            </summary>
            <param name="input">The stream to read the managed settings object from.</param>
            <param name="closeInput">whether or not this function should close <paramref name="input"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="input" /> is null. </exception>
            <exception cref="T:System.InvalidOperationException">An error occurred during deserialization. The original exception is available using the <see cref="P:System.Exception.InnerException" /> property. </exception>
        </member>
        <member name="T:LibLSLCC.Settings.SettingsPropertyChangedEventArgs`1">
            <summary>
                Event arguments for when a settings property is changing.  <see cref="T:LibLSLCC.Settings.SettingsBaseClass`1" />
            </summary>
            <typeparam name="TSetting"></typeparam>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsPropertyChangedEventArgs`1.#ctor(`0,System.Object,System.String,System.Object,System.Object)">
            <summary>
                Construct the settings property changed event args.
            </summary>
            <param name="propertyOwner">The object that contains the property that has changed.</param>
            <param name="subscriber">The subscriber object that is subscribed to receive the changed event.</param>
            <param name="propertyName">The name of the property that has changed.</param>
            <param name="oldValue">The old value of the property.</param>
            <param name="newValue">The new value of the property.</param>
        </member>
        <member name="P:LibLSLCC.Settings.SettingsPropertyChangedEventArgs`1.PropertyOwner">
            <summary>
                The object that contains the property that has changed.
            </summary>
        </member>
        <member name="P:LibLSLCC.Settings.SettingsPropertyChangedEventArgs`1.Subscriber">
            <summary>
                The subscriber object that is subscribed to receive the changed event.
            </summary>
        </member>
        <member name="P:LibLSLCC.Settings.SettingsPropertyChangedEventArgs`1.PropertyName">
            <summary>
                The name of the property that has changed.
            </summary>
        </member>
        <member name="P:LibLSLCC.Settings.SettingsPropertyChangedEventArgs`1.OldValue">
            <summary>
                The old value of the property.
            </summary>
        </member>
        <member name="P:LibLSLCC.Settings.SettingsPropertyChangedEventArgs`1.NewValue">
            <summary>
                The new value of the property.
            </summary>
        </member>
        <member name="T:LibLSLCC.Settings.SettingsPropertyChangingEventArgs`1">
            <summary>
                Event arguments for when a settings property is changing.  <see cref="T:LibLSLCC.Settings.SettingsBaseClass`1" />
            </summary>
            <typeparam name="TSetting"></typeparam>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsPropertyChangingEventArgs`1.#ctor(`0,System.Object,System.String,System.Object,System.Object)">
            <summary>
                Construct the settings property changing event args.
            </summary>
            <param name="propertyOwner">The object that contains the property that is changing.</param>
            <param name="subscriber">The subscriber object that is subscribed to receive the changing event.</param>
            <param name="propertyName">The name of the property that is changing.</param>
            <param name="oldValue">The old value of the property.</param>
            <param name="newValue">The new value of the property.</param>
        </member>
        <member name="P:LibLSLCC.Settings.SettingsPropertyChangingEventArgs`1.PropertyOwner">
            <summary>
                The object that contains the property that is changing.
            </summary>
        </member>
        <member name="P:LibLSLCC.Settings.SettingsPropertyChangingEventArgs`1.Subscriber">
            <summary>
                The subscriber object that is subscribed to receive the changing event.
            </summary>
        </member>
        <member name="P:LibLSLCC.Settings.SettingsPropertyChangingEventArgs`1.PropertyName">
            <summary>
                The name of the property that is changing.
            </summary>
        </member>
        <member name="P:LibLSLCC.Settings.SettingsPropertyChangingEventArgs`1.OldValue">
            <summary>
                The old value of the property.
            </summary>
        </member>
        <member name="P:LibLSLCC.Settings.SettingsPropertyChangingEventArgs`1.NewValue">
            <summary>
                The new value of the property.
            </summary>
        </member>
        <member name="T:LibLSLCC.Settings.SettingsBaseClass`1">
            <summary>
                A base class for settings objects.
            </summary>
            <typeparam name="TSetting"></typeparam>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsBaseClass`1.System#ICloneable#Clone">
            <summary>
                Deep clones this settings object.
            </summary>
            <returns>A deep clone of this settings object.</returns>
        </member>
        <member name="E:LibLSLCC.Settings.SettingsBaseClass`1.PropertyChanged">
            <summary>
                The property changed event, fired when a settings property has changed.
            </summary>
        </member>
        <member name="E:LibLSLCC.Settings.SettingsBaseClass`1.PropertyChanging">
            <summary>
                The property changing event, fired when a settings property is about to change, but has not changed yet.
            </summary>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsBaseClass`1.OnPropertyChanging(System.String,System.Object,System.Object)">
            <summary>
                Occurs when a property is about to change but has not changed yet.
            </summary>
            <param name="propertyName">The name of the property that is fixing to change.</param>
            <param name="oldValue">The old value of the property.</param>
            <param name="newValue">The new value of the property.</param>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsBaseClass`1.SubscribePropertyChangedRecursive(System.Object,System.Action{LibLSLCC.Settings.SettingsPropertyChangedEventArgs{System.Object}})">
            <summary>
                Subscribe to the property changed event on this settings object and all child settings objects recursively.
            </summary>
            <param name="owner">The object that is subscribing to the changed event.</param>
            <param name="handler">The changed event handler.</param>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsBaseClass`1.SubscribePropertyChanged(System.Object,System.Action{LibLSLCC.Settings.SettingsPropertyChangedEventArgs{`0}})">
            <summary>
                Subscribe to the property changed event on this settings object.
            </summary>
            <param name="owner">The object that is subscribing to the changed event.</param>
            <param name="handler">The changed event handler.</param>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsBaseClass`1.SubscribePropertyChanged(System.Object,System.String,System.Action{LibLSLCC.Settings.SettingsPropertyChangedEventArgs{`0}})">
            <summary>
                Subscribe to the property changed event on this settings object for a specific property.
            </summary>
            <param name="owner">The object that is subscribing to the changed event.</param>
            <param name="propertyName">The name of the property to subscribe to.</param>
            <param name="handler">The changed event handler.</param>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsBaseClass`1.UnSubscribePropertyChangedRecursive(System.Object)">
            <summary>
                Remove all property changed subscriptions belonging to an object from this settings object and all child settings
                objects recursively.
            </summary>
            <param name="owner">The subscriber to remove subscriptions for.</param>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsBaseClass`1.UnSubscribePropertyChanged(System.Object)">
            <summary>
                Remove a property changed subscription from this settings object given the subscriber object.
            </summary>
            <param name="owner">The subscriber to remove the subscription for.</param>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsBaseClass`1.UnSubscribePropertyChanged(System.Object,System.String)">
            <summary>
                Remove a specific property changed subscription from this settings object given the subscriber object and the
                property name.
            </summary>
            <param name="owner">The subscriber to remove the subscription for.</param>
            <param name="propertyName">The property name to remove the subscription for.</param>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsBaseClass`1.SubscribePropertyChangingRecursive(System.Object,System.Action{LibLSLCC.Settings.SettingsPropertyChangingEventArgs{System.Object}})">
            <summary>
                Subscribe to the property changing event on this settings object and all child settings objects recursively.
            </summary>
            <param name="owner">The object that is subscribing to the changing event.</param>
            <param name="handler">The changing event handler.</param>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsBaseClass`1.SubscribePropertyChanging(System.Object,System.Action{LibLSLCC.Settings.SettingsPropertyChangingEventArgs{`0}})">
            <summary>
                Subscribe to the property changing event on this settings object.
            </summary>
            <param name="owner">The object that is subscribing to the changing event.</param>
            <param name="handler">The changing event handler.</param>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsBaseClass`1.SubscribePropertyChanging(System.Object,System.String,System.Action{LibLSLCC.Settings.SettingsPropertyChangingEventArgs{`0}})">
            <summary>
                Subscribe to the property changing event on this settings object for a specific property.
            </summary>
            <param name="owner">The object that is subscribing to the changing event.</param>
            <param name="propertyName">The name of the property to subscribe to.</param>
            <param name="handler">The changing event handler.</param>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsBaseClass`1.UnSubscribePropertyChangingRecursive(System.Object)">
            <summary>
                Remove all property changing subscriptions belonging to an object from this settings object and all child settings
                objects recursively.
            </summary>
            <param name="owner">The subscriber to remove subscriptions for.</param>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsBaseClass`1.UnSubscribePropertyChanging(System.Object)">
            <summary>
                Remove a property changing subscription from this settings object given the subscriber object.
            </summary>
            <param name="owner">The subscriber to remove the subscription for.</param>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsBaseClass`1.UnSubscribePropertyChanging(System.Object,System.String)">
            <summary>
                Remove a specific property changing subscription from this settings object given the subscriber object and the
                property name.
            </summary>
            <param name="owner">The subscriber to remove the subscription for.</param>
            <param name="propertyName">The property name to remove the subscription for.</param>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsBaseClass`1.OnPropertyChanged(System.String,System.Object,System.Object)">
            <summary>
                Occurs when after a property has changed.
            </summary>
            <param name="propertyName">The name of the property that has changed.</param>
            <param name="oldValue">The old value of the property.</param>
            <param name="newValue">The new value of the property.</param>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsBaseClass`1.SetField``1(``0@,``0,System.String)">
            <summary>
                A tool for implementing the property changed/changing interface that goes in a public properties set handler.
                This should be used in properties that wish to abide by the property changed/changing interface.
            </summary>
            <typeparam name="T">The fields type.</typeparam>
            <param name="field">The backing field of the property.</param>
            <param name="value">The new value the property is being set to.</param>
            <param name="propertyName">Name of the property being set.</param>
            <returns></returns>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsBaseClass`1.GetHashCode">
            <summary>
                Returns a hash code for this settings object.  This uses the hash code all public instance fields and properties to
                generate a hash.
            </summary>
            <returns>
                A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
            </returns>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsBaseClass`1.Equals(System.Object)">
            <summary>
                Determines whether the specified <see cref="T:LibLSLCC.Settings.SettingsBaseClass`1" />, is equal to this instance by comparing its
                public instance fields and properties.
            </summary>
            <param name="other">The <see cref="T:LibLSLCC.Settings.SettingsBaseClass`1" /> to compare with this instance.</param>
            <returns>
                <c>true</c> if the specified <see cref="T:LibLSLCC.Settings.SettingsBaseClass`1" /> is equal to this instance; otherwise, <c>false</c>
                .
            </returns>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsBaseClass`1.Clone">
            <summary>
                Deep clones this settings object.
            </summary>
            <returns>A deep clone of this settings object.</returns>
        </member>
        <member name="M:LibLSLCC.Settings.SettingsBaseClass`1.MemberwiseAssign(`0)">
            <summary>
                Assign all settings properties with a naive memberwise assignment.
            </summary>
            <param name="other">The other object to attempt a memberwise assign from.</param>
        </member>
        <member name="T:LibLSLCC.Utility.ListParser.ILSLListExpr">
            <summary>
                Interface for parsed list elements.
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.ILSLListExpr.IsVariableReference">
            <summary>
                True if this list item represents a variable reference.
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.ILSLListExpr.Type">
            <summary>
                The list item type, it will be void if its a variable reference
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.ILSLListExpr.ValueString">
            <summary>
                Gets string representing the element, with quoting characters for the type.
            </summary>
            <value>
                The value string.
            </value>
        </member>
        <member name="T:LibLSLCC.Utility.ListParser.LSLListFloatExpr">
            <summary>
                Float list item.
            </summary>
        </member>
        <member name="M:LibLSLCC.Utility.ListParser.LSLListFloatExpr.#ctor(System.String,System.Boolean)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Utility.ListParser.LSLListFloatExpr" /> class.
            </summary>
            <param name="val">The value.</param>
            <param name="hex">if set to <c>true</c> val is parsed from hexadecimal notation.</param>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListFloatExpr.Value">
            <summary>
                The float value
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListFloatExpr.IsVariableReference">
            <summary>
                True if this list item represents a variable reference.
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListFloatExpr.Type">
            <summary>
                The list item type, it will be void if its a variable reference
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListFloatExpr.ValueString">
            <summary>
                Gets string representing the element, with quoting characters for the type.
            </summary>
            <value>
                The value string.
            </value>
        </member>
        <member name="T:LibLSLCC.Utility.ListParser.LSLListIntegerExpr">
            <summary>
                Integer list item.
            </summary>
        </member>
        <member name="M:LibLSLCC.Utility.ListParser.LSLListIntegerExpr.#ctor(System.String,System.Boolean)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Utility.ListParser.LSLListIntegerExpr" /> class.
            </summary>
            <param name="val">The value.</param>
            <param name="hex">if set to <c>true</c> [hexadecimal].</param>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListIntegerExpr.Value">
            <summary>
                The integer value.
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListIntegerExpr.IsVariableReference">
            <summary>
                True if this list item represents a variable reference.
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListIntegerExpr.Type">
            <summary>
                The list item type, it will be void if its a variable reference
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListIntegerExpr.ValueString">
            <summary>
                Gets string representing the element, with quoting characters for the type.
            </summary>
            <value>
                The value string.
            </value>
        </member>
        <member name="T:LibLSLCC.Utility.ListParser.LSLListKeyExpr">
            <summary>
                Key List item, they can be created by specifying '(key)""' as  list item, using a cast expression.
            </summary>
        </member>
        <member name="M:LibLSLCC.Utility.ListParser.LSLListKeyExpr.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Utility.ListParser.LSLListKeyExpr" /> class.
            </summary>
            <param name="val">The value.</param>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListKeyExpr.Value">
            <summary>
                The raw value of the key, without quotes.
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListKeyExpr.IsVariableReference">
            <summary>
                True if this list item represents a variable reference.
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListKeyExpr.Type">
            <summary>
                The list item type, it will be void if its a variable reference
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListKeyExpr.ValueString">
            <summary>
                Gets string representing the element, with quoting characters for the type.
            </summary>
            <value>
                The value string.
            </value>
        </member>
        <member name="T:LibLSLCC.Utility.ListParser.LSLListParser">
            <summary>
                Tool for parsing LSL list from source code styled strings.
            </summary>
        </member>
        <member name="T:LibLSLCC.Utility.ListParser.LSLListParser.LSLListParsingFlags">
            <summary>
                List parsing option flags.
            </summary>
        </member>
        <member name="F:LibLSLCC.Utility.ListParser.LSLListParser.LSLListParsingFlags.None">
            <summary>
                No options selected
            </summary>
        </member>
        <member name="F:LibLSLCC.Utility.ListParser.LSLListParser.LSLListParsingFlags.AllowVariableReferencesInList">
            <summary>
                The allow variable references to appear in the list at the top level.
            </summary>
        </member>
        <member name="F:LibLSLCC.Utility.ListParser.LSLListParser.LSLListParsingFlags.AllowVariableReferencesInVectors">
            <summary>
                The allow variable references to appear in vectors that are elements of the list.
            </summary>
        </member>
        <member name="F:LibLSLCC.Utility.ListParser.LSLListParser.LSLListParsingFlags.AllowVariableReferencesInRotations">
            <summary>
                The allow variable references to appear in rotations that are elements of the list.
            </summary>
        </member>
        <member name="M:LibLSLCC.Utility.ListParser.LSLListParser.TryParseList(System.String,System.Collections.Generic.List{LibLSLCC.Utility.ListParser.ILSLListExpr}@,LibLSLCC.Utility.ListParser.LSLListParser.LSLListParsingFlags)">
            <summary>
                Attempts to parse an LSL list from a string and returns true if the parse succeeded.
            </summary>
            <param name="list">The string containing the list.</param>
            <param name="expressions">
                The resulting expression list will be put at this location if the parse succeeded, otherwise
                it will be <c>null</c>.
            </param>
            <param name="parsingFlags">Optional parsing flags.</param>
            <returns><c>true</c> if the string representation of the LSL list was successfully parsed; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:LibLSLCC.Utility.ListParser.LSLListParser.Format(System.Collections.Generic.IEnumerable{LibLSLCC.Utility.ListParser.ILSLListExpr},System.Boolean)">
            <summary>
                Formats the specified expressions into the string representation of an LSL list.
            </summary>
            <param name="expressions">The expressions to format.</param>
            <param name="brackets">
                if set to <c>true</c> place brackets around the formated list, otherwise just return the CSV
                list content.
            </param>
            <returns>The formatted LSL list representation of the given enumerable of expression nodes.</returns>
        </member>
        <member name="M:LibLSLCC.Utility.ListParser.LSLListParser.Format(System.String,System.Boolean)">
            <summary>
                Formats the specified list string by parsing it with <see cref="M:LibLSLCC.Utility.ListParser.LSLListParser.ParseList(System.String,LibLSLCC.Utility.ListParser.LSLListParser.LSLListParsingFlags)" /> and passing the resulting enumerable
                to <see cref="M:LibLSLCC.Utility.ListParser.LSLListParser.Format(System.Collections.Generic.IEnumerable{LibLSLCC.Utility.ListParser.ILSLListExpr},System.Boolean)" />.
            </summary>
            <param name="listString">The string containing the list to parse and format.</param>
            <param name="brackets">
                if set to <c>true</c> place brackets around the formated list, otherwise just return the CSV
                list content.
            </param>
            <returns>The formatted LSL list representation of the given enumerable of expression nodes.</returns>
        </member>
        <member name="M:LibLSLCC.Utility.ListParser.LSLListParser.ParseList(System.String,LibLSLCC.Utility.ListParser.LSLListParser.LSLListParsingFlags)">
            <summary>
                Parses an LSL list from a string and returns the simple expressions it contains as an enumerable.
                <remarks>
                    Take note that parsing wont start to occur until you begin enumerating the returned value.
                </remarks>
            </summary>
            <param name="list">The string containing the list.</param>
            <param name="parsingFlags">Optional parsing flags.</param>
            <returns>An enumerable of <see cref="T:LibLSLCC.Utility.ListParser.ILSLListExpr"/> nodes parsed from the list string.</returns>
            <exception cref="T:LibLSLCC.Utility.ListParser.LSLListParserOptionsConstraintException">
                When an
                <see cref="T:LibLSLCC.Utility.ListParser.LSLListParser.LSLListParsingFlags" /> constraint is violated.
            </exception>
            <exception cref="T:LibLSLCC.Utility.ListParser.LSLListParserSyntaxException">
                Rotations must contain only literal values to be parsed, and cannot contain these types of expressions: rotations,
                vectors, lists or strings.
                or
                Vectors must contain only literal values to be parsed, and cannot contain these types of expressions: rotations,
                vectors, lists or strings.
                or
                Lists cannot contain other lists.
                or
                Cast expressions can only be used to specify that a list element is a 'key' and not a 'string'
                or
                Encountered an un-parseable expression in the list, only literal values and possibly variable names are acceptable
                when parsing.
            </exception>
        </member>
        <member name="T:LibLSLCC.Utility.ListParser.LSLListParserOptionsConstraintException">
            <summary>
                Thrown when an <see cref="T:LibLSLCC.Utility.ListParser.LSLListParser.LSLListParsingFlags" /> constraint is violated.
            </summary>
        </member>
        <member name="M:LibLSLCC.Utility.ListParser.LSLListParserOptionsConstraintException.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Utility.ListParser.LSLListParserOptionsConstraintException" /> class.
            </summary>
        </member>
        <member name="M:LibLSLCC.Utility.ListParser.LSLListParserOptionsConstraintException.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Utility.ListParser.LSLListParserOptionsConstraintException" /> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:LibLSLCC.Utility.ListParser.LSLListParserOptionsConstraintException.#ctor(System.String,System.Exception)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Utility.ListParser.LSLListParserOptionsConstraintException" /> class.
            </summary>
            <param name="message">The message.</param>
            <param name="inner">The inner.</param>
        </member>
        <member name="M:LibLSLCC.Utility.ListParser.LSLListParserOptionsConstraintException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Utility.ListParser.LSLListParserOptionsConstraintException" /> class.
            </summary>
            <param name="info">
                The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object
                data about the exception being thrown.
            </param>
            <param name="context">
                The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual
                information about the source or destination.
            </param>
        </member>
        <member name="T:LibLSLCC.Utility.ListParser.LSLListParserSyntaxException">
            <summary>
                Thrown when an <see cref="T:LibLSLCC.Utility.ListParser.LSLListParser" /> encounters a syntax error while parsing.
            </summary>
        </member>
        <member name="M:LibLSLCC.Utility.ListParser.LSLListParserSyntaxException.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Utility.ListParser.LSLListParserSyntaxException" /> class.
            </summary>
        </member>
        <member name="M:LibLSLCC.Utility.ListParser.LSLListParserSyntaxException.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Utility.ListParser.LSLListParserSyntaxException" /> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:LibLSLCC.Utility.ListParser.LSLListParserSyntaxException.#ctor(System.String,System.Exception)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Utility.ListParser.LSLListParserSyntaxException" /> class.
            </summary>
            <param name="message">The message.</param>
            <param name="inner">The inner.</param>
        </member>
        <member name="M:LibLSLCC.Utility.ListParser.LSLListParserSyntaxException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Utility.ListParser.LSLListParserSyntaxException" /> class.
            </summary>
            <param name="info">
                The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object
                data about the exception being thrown.
            </param>
            <param name="context">
                The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual
                information about the source or destination.
            </param>
        </member>
        <member name="T:LibLSLCC.Utility.ListParser.LSLListRotationExpr">
            <summary>
                Rotation list item.
            </summary>
        </member>
        <member name="M:LibLSLCC.Utility.ListParser.LSLListRotationExpr.#ctor(LibLSLCC.Utility.ListParser.ILSLListExpr,LibLSLCC.Utility.ListParser.ILSLListExpr,LibLSLCC.Utility.ListParser.ILSLListExpr,LibLSLCC.Utility.ListParser.ILSLListExpr)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Utility.ListParser.LSLListRotationExpr" /> class.
            </summary>
            <param name="x">The x component.</param>
            <param name="y">The y component.</param>
            <param name="z">The z component.</param>
            <param name="s">The s component.</param>
            <exception cref="T:System.ArgumentException">
                X is not an LSLFloat or LSLVariable.;x
                or
                Y is not an LSLFloat or LSLVariable.;y
                or
                Z is not an LSLFloat or LSLVariable.;z
                or
                S is not an LSLFloat or LSLVariable.;s
            </exception>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListRotationExpr.X">
            <summary>
                The X component.
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListRotationExpr.Y">
            <summary>
                The Y component.
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListRotationExpr.Z">
            <summary>
                The Z component.
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListRotationExpr.S">
            <summary>
                The S component.
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListRotationExpr.IsVariableReference">
            <summary>
                True if this list item represents a variable reference.
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListRotationExpr.Type">
            <summary>
                The list item type, it will be void if its a variable reference
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListRotationExpr.ValueString">
            <summary>
                Gets string representing the element, with quoting characters for the type.
            </summary>
            <value>
                The value string.
            </value>
        </member>
        <member name="T:LibLSLCC.Utility.ListParser.LSLListStringExpr">
            <summary>
                String list item.
            </summary>
        </member>
        <member name="M:LibLSLCC.Utility.ListParser.LSLListStringExpr.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Utility.ListParser.LSLListStringExpr" /> class.
            </summary>
            <param name="val">The value.</param>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListStringExpr.Value">
            <summary>
                The raw value of the string, without quotes.
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListStringExpr.IsVariableReference">
            <summary>
                True if this list item represents a variable reference.
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListStringExpr.Type">
            <summary>
                The list item type, it will be void if its a variable reference
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListStringExpr.ValueString">
            <summary>
                Gets string representing the element, with quoting characters for the type.
            </summary>
            <value>
                The value string.
            </value>
        </member>
        <member name="T:LibLSLCC.Utility.ListParser.LSLListVariableExpr">
            <summary>
                Variable reference list item.
            </summary>
        </member>
        <member name="M:LibLSLCC.Utility.ListParser.LSLListVariableExpr.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Utility.ListParser.LSLListVariableExpr" /> class.
            </summary>
            <param name="name">The name.</param>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListVariableExpr.Name">
            <summary>
                Name of the variable referenced
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListVariableExpr.IsVariableReference">
            <summary>
                True if this list item represents a variable reference.
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListVariableExpr.Type">
            <summary>
                The list item type, it will be void if its a variable reference
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListVariableExpr.ValueString">
            <summary>
                Gets string representing the element, with quoting characters for the type.
            </summary>
            <value>
                The value string.
            </value>
        </member>
        <member name="T:LibLSLCC.Utility.ListParser.LSLListVectorExpr">
            <summary>
                Vector list item.
            </summary>
        </member>
        <member name="M:LibLSLCC.Utility.ListParser.LSLListVectorExpr.#ctor(LibLSLCC.Utility.ListParser.ILSLListExpr,LibLSLCC.Utility.ListParser.ILSLListExpr,LibLSLCC.Utility.ListParser.ILSLListExpr)">
            <summary>
                Initializes a new instance of the <see cref="T:LibLSLCC.Utility.ListParser.LSLListVectorExpr" /> class.
            </summary>
            <param name="x">The x component.</param>
            <param name="y">The y component.</param>
            <param name="z">The z component.</param>
            <exception cref="T:System.ArgumentException">
                X is not an LSLFloat or LSLVariable.;x
                or
                Y is not an LSLFloat or LSLVariable.;y
                or
                Z is not an LSLFloat or LSLVariable.;z
            </exception>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListVectorExpr.X">
            <summary>
                The X component.
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListVectorExpr.Y">
            <summary>
                The Y component.
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListVectorExpr.Z">
            <summary>
                The Z component.
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListVectorExpr.IsVariableReference">
            <summary>
                True if this list item represents a variable reference.
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListVectorExpr.Type">
            <summary>
                The list item type, it will be void if its a variable reference
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.ListParser.LSLListVectorExpr.ValueString">
            <summary>
                Gets string representing the element, with quoting characters for the type.
            </summary>
            <value>
                The value string.
            </value>
        </member>
        <member name="T:LibLSLCC.Utility.LambdaEqualityComparer`1">
            <summary>
                Implements the generic IEqualityComparer interface by delegating comparisons and hash
                code generation to function objects that have the capability of being lambdas.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:LibLSLCC.Utility.LambdaEqualityComparer`1.#ctor(System.Func{`0,`0,System.Boolean},System.Func{`0,System.Int32})">
            <summary>
                Construct a LambdaEqualityComparer using a comparison function, and an optional hash code generation function.
                If a hash code generation function is not provided, hash code generation is implemented by calling GetHashCode()
                on the given object.
            </summary>
            <param name="comparerFunc">The comparison function to use.</param>
            <param name="hashFunc">The optional hash code generation function to use.</param>
        </member>
        <member name="P:LibLSLCC.Utility.LambdaEqualityComparer`1.HashFunc">
            <summary>
                The function object that is used to generate hash codes.
            </summary>
        </member>
        <member name="P:LibLSLCC.Utility.LambdaEqualityComparer`1.ComparerFunc">
            <summary>
                The function object that is used for comparisons.
            </summary>
        </member>
        <member name="M:LibLSLCC.Utility.LambdaEqualityComparer`1.Equals(`0,`0)">
            <summary>
                Determines whether the specified objects are equal.
            </summary>
            <returns>
                true if the specified objects are equal; otherwise, false.
            </returns>
            <param name="x">The first object of type <typeparamref name="T" /> to compare.</param>
            <param name="y">The second object of type <typeparamref name="T" /> to compare.</param>
        </member>
        <member name="M:LibLSLCC.Utility.LambdaEqualityComparer`1.GetHashCode(`0)">
            <summary>
                Returns a hash code for the specified object.
            </summary>
            <returns>
                A hash code for the specified object.
            </returns>
            <param name="obj">The <see cref="T:System.Object" /> for which a hash code is to be returned.</param>
            <exception cref="T:System.ArgumentNullException">
                The type of <paramref name="obj" /> is a reference type and
                <paramref name="obj" /> is <c>null</c>.
            </exception>
        </member>
        <member name="T:LibLSLCC.Utility.LSLTokenTools">
            <summary>
                Tools for dealing with LSL token strings, mostly symbol names.
            </summary>
        </member>
        <member name="F:LibLSLCC.Utility.LSLTokenTools.IDRegexString">
            <summary>
                A raw string copy of a regex that matches/validates LSL ID Tokens, IE: variable names, state names, label names,
                function names
            </summary>
        </member>
        <member name="F:LibLSLCC.Utility.LSLTokenTools.FloatRegexString">
            <summary>
                A raw string copy of a regex that matches/validates LSL Float tokens, the regex string is not anchored.
            </summary>
        </member>
        <member name="F:LibLSLCC.Utility.LSLTokenTools.FloatRegex">
            <summary>
                This regex matches/validates LSL Float Tokens, the regex is not anchord.
            </summary>
        </member>
        <member name="F:LibLSLCC.Utility.LSLTokenTools.FloatRegexAnchored">
            <summary>
                This regex matches/validates LSL Float Tokens.
            </summary>
        </member>
        <member name="F:LibLSLCC.Utility.LSLTokenTools.IDRegex">
            <summary>
                This regex matches/validates LSL ID Tokens, IE: variable names, state names, label names, function names
            </summary>
        </member>
        <member name="F:LibLSLCC.Utility.LSLTokenTools.IDRegexAnchored">
            <summary>
                This regex matches/validates LSL ID Tokens, IE: variable names, state names, label names, function names
                It is anchored with ^ and $ at the beginning and end respectively.
            </summary>
        </member>
        <member name="F:LibLSLCC.Utility.LSLTokenTools.IDStartCharRegexString">
            <summary>
                A raw string copy of a regex that matches/validates that a character is a valid starting character for an ID Token
            </summary>
        </member>
        <member name="F:LibLSLCC.Utility.LSLTokenTools.IDStartCharRegex">
            <summary>
                This regex matches/validates that a character is a valid starting character for an ID Token
            </summary>
        </member>
        <member name="F:LibLSLCC.Utility.LSLTokenTools.IDTrailingCharRegexString">
            <summary>
                A raw string copy of a regex matches/validates that a character is a valid trailing character after the first
                character of an ID Token
            </summary>
        </member>
        <member name="F:LibLSLCC.Utility.LSLTokenTools.IDTrailingCharRegex">
            <summary>
                This regex matches/validates that a character is a valid trailing character after the first character of an ID
                Token
            </summary>
        </member>
        <member name="F:LibLSLCC.Utility.LSLTokenTools.IDAnyCharRegexString">
            <summary>
                A raw string copy of a regex that matches/validates that a character is either a valid starting OR trailing
                character in an ID token
            </summary>
        </member>
        <member name="F:LibLSLCC.Utility.LSLTokenTools.IDAnyCharRegex">
            <summary>
                This regex matches/validates that a character is either a valid starting OR trailing character in an ID token
            </summary>
        </member>
        <member name="T:LibLSLCC.Utility.LSLFormatTools">
            <summary>
                Various utilities for formatting string that are useful for generating/dealing with
                indented code and escaped strings.
            </summary>
        </member>
        <member name="M:LibLSLCC.Utility.LSLFormatTools.GetStringSpacesIndented(System.String,System.Int32)">
            <summary>
                Gets the number of spaces required to match the length of the whitespace leading up to the first non-whitespace
                character in a string (new line is not considered whitespace here).
            </summary>
            <param name="str">The string to consider</param>
            <param name="tabSize">The size of a tab character in spaces</param>
            <returns>
                The number of space characters required to match the length of all the whitespace characters at the end of the
                string (except newlines)
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="str" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.Utility.LSLFormatTools.FormatFloatString(System.String)">
            <summary>
                Format an LSL floating point number string of arbitrary precision from LSL float token format to an equivelant
                string compatiblity with C# float token syntax.<br />
                Specifiers such as 'f' and 'e' are guaranteed to be formatted as lower case characters.  A trailing 'f' specifier
                will remain in the string if present.<br />
                Type specifiers other than 'f' are not accepted.<br />
                <para>
                    Example Output:<br />
                    "-.00" ->  "-0.0",<br /><br />
                    "0.0300" -> "0.03",<br /><br />
                    "-3." -> "-3.0",<br /><br />
                    ".4E04" -> "0.4e4",<br /><br />
                    "4E040" -> "4e40",<br /><br />
                    "56.F" -> "56.0f",<br /><br />
                    etc...
                </para>
            </summary>
            <param name="floatStr">The float string to format.</param>
            <exception cref="T:System.FormatException">
                If <paramref name="floatStr" /> is not a properly formated, LSL float formatting
                rules apply.
            </exception>
            <returns>The normalized float string.</returns>
        </member>
        <member name="M:LibLSLCC.Utility.LSLFormatTools.GetStringSpacesEquivalent(System.String,System.Int32)">
            <summary>
                Gets the number of spaces required to exactly match the length of a given string up to the first new line
            </summary>
            <param name="str">Input string to get the length in spaces of</param>
            <param name="tabSize">Tab size in spaces, defaults to 4</param>
            <returns>Number of spaces required to match the length of the string</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="str" /> is <c>null</c>.</exception>
        </member>
        <member name="M:LibLSLCC.Utility.LSLFormatTools.CreateTabCorrectSpaceString(System.Int32,System.Int32)">
            <summary>
                Creates a spacer string using tabs up until spaces are required for alignment.
                Strings less than tabSize end up being only spaces.
            </summary>
            <param name="spaces">The number of spaces the spacer string should be equivalent to</param>
            <param name="tabSize">The size of a tab character in spaces, default value is 4</param>
            <returns>
                A string consisting of leading tabs and possibly trailing spaces that is equivalent in length
                to the number of spaces provided in the spaces parameter
            </returns>
        </member>
        <member name="M:LibLSLCC.Utility.LSLFormatTools.ShowControlCodeEscapes(System.String)">
            <summary>
                If a string has control codes in it, this will return a string with those control codes
                replaced with their symbolic representation, IE: &#92;n &#92;t ect..
                Supports every escape code supported by C# itself
            </summary>
            <param name="str">String to replace control codes in.</param>
            <returns>String with control codes replaced with symbolic representation.</returns>
        </member>
        <member name="M:LibLSLCC.Utility.LSLFormatTools.CreateRepeatingString(System.Int32,System.String)">
            <summary>
                Create a repeating string by repeating the content string a number of times.
            </summary>
            <param name="repeats">The number of times the 'content' string should repeat.</param>
            <param name="content">The content string to repeat.</param>
            <returns><paramref name="content" /> concatenated <paramref name="repeats" /> number of times.</returns>
        </member>
        <member name="M:LibLSLCC.Utility.LSLFormatTools.CreateSpacesString(System.Int32)">
            <summary>
                Generate a string with N number of spaces in it
            </summary>
            <param name="spaces">Number of spaces</param>
            <returns>A string containing 'spaces' number of spaces</returns>
        </member>
        <member name="M:LibLSLCC.Utility.LSLFormatTools.CreateTabsString(System.Int32)">
            <summary>
                Generate a string with N number of tabs in it
            </summary>
            <param name="tabs">Number of tabs</param>
            <returns>A string containing 'tabs' number of tabs</returns>
        </member>
        <member name="M:LibLSLCC.Utility.LSLFormatTools.CreateNewLinesString(System.Int32)">
            <summary>
                Generate a string with N number of newlines in it.
                The newlines are explicitly '\n' characters, not <see cref="P:System.Environment.NewLine" />
            </summary>
            <param name="newLines">Number of newlines</param>
            <returns>A string containing 'newLines' number of newlines</returns>
        </member>
    </members>
</doc>
